package com.vxlisp.vx

object vx_core {

  interface Type_replfunc {
    fun vx_repl(vx_core.Type_anylist arglist) : vx_core.Type_any
  }

  interface Type_replfunc_async {
    fun vx_repl(vx_core.Type_anylist arglist) : CompletableFuture<vx_core.Type_any>
  }

  val emptylistany : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>()

  val emptymapany : Map<String, vx_core.Type_any> = vx_core.immutablemap(new LinkedHashMap<String, vx_core.Type_any>())

  fun <T> immutablelist(
    listany : List<T>
  ) : List<T> {
    return listany.toList()
  }

  fun <T> immutablemap(
    mapany : Map<String, T>
  ) : Map<String, T> {
    return LinkedHashMap<String, T>(mapany)
  }

  open class Class_base {
    internal var vx_iref : Int = 0
    internal var vx_p_constdef : vx_core.Type_constdef? = null
    internal var vxmsgblock : vx_core.Type_msgblock? = null
    fun vx_constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef
      val constdef : vx_core.Type_constdef? = this.vx_p_constdef
      if (constdef == null) {
        output = vx_core.e_constdef
      } else {
        output = constdef
      }
      return output
    }
    fun vx_dispose() : List<Type_any> {
      this.vx_iref = 0
      this.vxmsgblock = null
      return vx_core.emptylistany
    }
    fun vx_msgblock() : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock
      val msgblock : vx_core.Type_msgblock? = this.vxmsgblock
      if (msgblock == null) {
        output = vx_core.e_msgblock
      } else {
        output = msgblock
      }
      return output
    }
    fun vx_release() : Boolean {
      var output : Boolean = false
      if (this.vx_iref < 0) {
      } else if (this.vx_iref == 0) {
        this.vx_iref = -1
        output = true
      } else {
        this.vx_iref -= 1
      }
      return output
    }
    fun vx_reserve() : Unit {
      this.vx_iref += 1
    }
  }

  class KeyValue<T> {
    var key : String = ""
    var value : T = null
  }

  fun constdef_new(
    pkgname : String,
    name : String,
    typ : vx_core.Type_any
  ) : vx_core.Type_constdef {
    var output : vx_core.Class_constdef = vx_core.Class_constdef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_type = typ
    return output
  }

  fun funcdef_new(
    pkgname : String,
    name : String,
    idx : int,
    async : boolean,
    typ : vx_core.Type_any
  ) : vx_core.Type_funcdef {
    var output : vx_core.Class_funcdef = vx_core.Class_funcdef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_idx = vx_core.vx_new_int(idx)
    output.vx_p_async = vx_core.vx_new_boolean(async)
    output.vx_p_type = typ
    return output
  }

  fun arrayany_from_anylist(
    list : vx_core.Type_anylist
  ) : Array<vx_core.Type_any> {
    val listany : List<vx_core.Type_any> = list.vx_list()
    val output : Array<vx_core.Type_any> = listany.toTypedArray()
    return output
  }

  //@SafeVarargs
  fun <T> arraylist_from_array(
    varargs items : T
  ) : List<T> {
    val output : List<T> = ArrayList<T>(Arrays.asList(items))
    output = vx_core.immutablelist(output)
    return output
  }

  fun <T extends vx_core.Type_any, U extends vx_core.Type_any> arraylist_from_arraylist(
    generic_any_1 : T,
    listval : List<U>
  ) : List<T> {
    var output : List<T> = List<>()
    for (value : vx_core.Type_any in listval) {
      val t_val : T = vx_core.f_any_from_any(generic_any_1, value)
      output.add(t_val)
    }
    output = vx_core.immutablelist(output)
    return output
  }

  fun <T, U> arraylist_from_arraylist_fn(
    listval : List<U>,
    fn_any_from_any : Function<U, T>
  ) : List<T> {
    List<T> output = List<>()
    for (U value_u : listval) {
      T t_val = fn_any_from_any.apply(value_u)
      output.add(t_val)
    }
    output = vx_core.immutablelist(output)
    return output
  }

  fun <T extends vx_core.Type_any, U extends vx_core.Type_any> arraylist_from_linkedhashmap(
    generic_any_1 : T,
    mapval : Map<String, U>
  ) : List<T> {
    val output : List<T> = ArrayList<T>()
    val keys : Set<String> = mapval.keySet()
    for (key : String in keys) {
      val u_val : U = mapval.get(key)
      val t_val : T = vx_core.f_any_from_any(generic_any_1, u_val)
      output.add(t_val)
    }
    output = vx_core.immutablelist(output)
    return output
  }

  fun <T, U> arraylist_from_linkedhashmap_fn(
    mapval : Map<String, U>,
    fn_any_from_key_value : BiFunction<String, U, T>
  ) : List<T> {
    val output : List<T> = ArrayList<T>()
    val keys : Set<String> = mapval.keySet()
    for (key : String in keys) {
      val u_val : U = mapval.get(key)
      val t_val : T = fn_any_from_key_value.apply(key, u_val)
      output.add(t_val)
    }
    return output
  }

  fun <T> async_new_completed(val : T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = CompletableFuture.completedFuture(val)
    return output
  }

  fun <T extends vx_core.Type_any, U extends vx_core.Type_any> async_from_async(
    T generic_any_1,
    CompletableFuture<U> future
  ) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply(val -> {
      return vx_core.f_any_from_any(generic_any_1, val)
    })
    return output
  }

  fun <T, U> async_from_async_fn(
    future : CompletableFuture<U>,
    fn : Function<? super U, ? extends T>
  ) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply(fn)
    return output
  }

  fun <T> async_arraylist_from_arraylist_async(
    list_future : List<CompletableFuture<T>>
  ) : CompletableFuture<List<T>> {
    val allFutures : CompletableFuture<Void> = CompletableFuture.allOf(
      list_future.toArray(new CompletableFuture[list_future.size()])
    )
    val output : CompletableFuture<List<T>> = allFutures.thenApply(v -> {
      val list : List<T> = list_future.stream()
        .map(future -> future.join())
        .collect(Collectors.toList())
      return vx_core.immutablelist(list)
    })
    return output
  }

  //@SafeVarargs
  fun <T> hashmap_from_keyvalues(
    varargs keyvalues : KeyValue<T>
  ) : LinkedHashMap<String, T> {
    val output : LinkedHashMap<String, T> = LinkedHashMap<String, T>()
    for (keyvalue : KeyValue<T> in keyvalues) {
      val key : String = keyvalue.key
      val value : T = keyvalue.value
      output.put(key, value)
    }
    return output
  }

  fun <T> keyvalue_from_key_value(
    String key : String,
    value : T
  ) : KeyValue<T> {
    val output : KeyValue<T> = KeyValue<T>()
    output.key = key
    output.value = value
    return output
  }

  fun <T> map_from_list_fn(
    listval : List<T>,
    fn_any_from_any : Function<T, vx_core.Type_string>
  ) : Map<String, T> {
    var output : Map<String, T> = LinkedHashMap<>()
    for (val : T in listval) {
      val valkey : vx_core.Type_string = fn_any_from_any.apply(val)
      val key : String = valkey.vx_string()
      output.put(key, val)
    }
    return output
  }

  fun <T extends vx_core.Type_any> map_from_map(
    mapval : LinkedHashMap<String, vx_core.Type_any>
  ) : LinkedHashMap<String, T> {
    LinkedHashMap<String, T> output = LinkedHashMap<String, T>()
    Set<String> keys = mapval.keySet()
    for (String key : keys) {
      vx_core.Type_any value = mapval.get(key)
      try {
        @SuppressWarnings("unchecked")
        T castval = (T)value
        output.put(key, castval)
      } catch (Exception ex) {
        vx_core.vx_log("map<-map", ex)
      }
    }
    return output
  }

  // vx_boolean_from_string_ends(string, string)
  fun vx_boolean_from_string_ends(
    text : String,
    ends : String
  ) : boolean {
    return text.endsWith(ends)
  }

  // vx_boolean_from_string_find(string, string)
  fun vx_boolean_from_string_find(
    text : String,
    find : String
  ) : boolean {
    return text.contains(find)
  }

  // vx_boolean_from_string_starts(string, string)
  fun vx_boolean_from_string_starts(
    text : String,
    starts : String
  ) : boolean {
    return text.startsWith(starts)
  }

  // vx_eqeq(any, any)
  fun vx_eqeq(
    val1 : vx_core.Type_any,
    val2 : vx_core.Type_any
  ) : boolean {
    var output : boolean = false
    if (val1 == val2) {
      output = true
    } else if (val1.vx_msgblock() != vx_core.e_msgblock) {
    } else if (val2.vx_msgblock() != vx_core.e_msgblock) {
    } else {
      val type1 : vx_core.Type_any = val1.vx_type()
      val type2 : vx_core.Type_any = val2.vx_type()
      if (type1 != type2) {
      } else if (type1 == vx_core.t_int) {
        val valint1 : vx_core.Type_int = val1 as vx_core.Type_int
        val valint2 : vx_core.Type_int = val1 as vx_core.Type_int
        if (valint1.vx_int() == valint2.vx_int()) {
          output = true
        }
      } else if (type1 == vx_core.t_float) {
        val valfloat1 : vx_core.Type_float = val1 as vx_core.Type_float
        val valfloat2 : vx_core.Type_float = val2 as vx_core.Type_float
        if (valfloat1.vx_float() == valfloat2.vx_float()) {
          output = true
        }
      } else if (type1 == vx_core.t_decimal) {
        val valdecimal1 : vx_core.Type_decimal = val1 as vx_core.Type_decimal
        val valdecimal2 : vx_core.Type_decimal = val2 as vx_core.Type_decimal
        if (valdecimal1.vx_string() == valdecimal2.vx_string()) {
          output = true
        }
      } else if (type1 == vx_core.t_string) {
        val valstring1 : vx_core.Type_string = val1 as vx_core.Type_string
        val valstring2 : vx_core.Type_string = val2 as vx_core.Type_string
        if (valstring1.vx_string() == valstring2.vx_string()) {
          output = true
        }
      }
    }
    return output
  }

  // vx_float_from_string(string)
  fun vx_float_from_string(
    text : String
  ) : float {
    var output : float = 0
    try {
      output = Float.parseFloat(text)
    } catch (Exception e) {
    }    
    return output
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  fun vx_global_package_set(
    pkgname : String,
    maptype : Map<String, vx_core.Type_any>,
    mapconst : Map<String, vx_core.Type_any>,
    mapfunc : Map<String, vx_core.Type_func>
  ) : Unit {
    val typemap : vx_core.Class_typemap = vx_core.Class_typemap()
		  typemap.vx_p_map = vx_core.immutablemap(maptype)
	   val constmap : vx_core.Class_constmap = vx_core.Class_constmap()
		  constmap.vx_p_map = vx_core.immutablemap(mapconst)
		  val funcmap : vx_core.Class_funcmap = vx_core.Class_funcmap()
		  funcmap.vx_p_map = vx_core.immutablemap(mapfunc)
    val global : vx_core.Class_project = vx_core.c_global as vx_core.Class_project
    var packagemap : vx_core.Class_packagemap = global.vx_p_packagemap as vx_core.Class_packagemap
    if (packagemap == null) {
      packagemap = vx_core.Class_packagemap()
      global.vx_p_packagemap = packagemap
    }
    val mappackage : Map<String, vx_core.Type_package> = LinkedHashMap<>(packagemap.vx_p_map)
		  val pkg : vx_core.Class_package = vx_core.Class_package()
		  pkg.vx_p_constmap = constmap
		  pkg.vx_p_typemap = typemap
		  pkg.vx_p_funcmap = funcmap
    mappackage.put(pkgname, pkg)
    packagemap.vx_p_map = vx_core.immutablemap(mappackage)
  }

  // vx_int_from_string(string)
  fun vx_int_from_string(
    text : String
  ) int {
    var output : int = 0
    try {
      output = Integer.parseInt(text)
    } catch (Exception e) {
    }    
    return output
  }

  // vx_int_from_string_find(string, string)
  fun vx_int_from_string_find(
    text : String,
    find : String
  ) : int {
    return text.indexOf(find)
  }

  // vx_int_from_string_findlast(string, string)
  fun vx_int_from_string_findlast(
    text : String,
    findlast : String
  ) : int {
    return text.lastIndexOf(findlast)
  }

  // vx_is_float(string)
  fun vx_is_float(
    text : String
  ) : boolean {
    var output : boolean = false
    try {
      Float.parseFloat(text)
      output = true
    } catch (Exception e) {
    }    
    return output
  }

  // vx_is_float(any)
  fun vx_is_float(
    value : vx_core.Type_any
  ) : boolean {
    var output : boolean = false
    if (value is vx_core.Type_number) {
      output = true
    } else if (value is vx_core.Type_string) {
      val valuestring : vx_core.Type_string = value as vx_core.Type_string
      output = vx_core.vx_is_float(valuestring.vx_string())
    }
    return output
  }

  // vx_is_int(string)
  fun vx_is_int(
    text : String
  ) : boolean {
    var output : boolean = false
    switch (text) {
    case "notanumber":
    case "infinity":
    case "neginfinity":
      output = true
      break
    default:
      try {
        Integer.parseInt(text)
        output = true
      } catch (Exception e) {
      }
      break
    }
    return output
  }

  // vx_is_int(any)
  fun vx_is_int(
    value : vx_core.Type_any
  ) : boolean {
    var result : boolean = false
    if (value == vx_core.c_infinity) {
      result = true
    } else if (value == vx_core.c_neginfinity) {
      result = true
    } else if (value == vx_core.c_notanumber) {
      result = true
    } else if (value is vx_core.Type_int) {
      result = true
    } else if (value is vx_core.Type_float) {
      val valfloat : vx_core.Type_float = value as vx_core.Type_float
      val floatval : float = valfloat.vx_float()
      if ((int)floatval == floatval) {
        result = true
      }
    } else if (value is vx_core.Type_decimal) {
      val valdec : vx_core.Type_decimal = value as vx_core.Type_decimal
      val strval : String = valdec.vx_string()
      try {
        if (Integer.parseInt(strval) == Float.parseFloat(strval)) {
          result = true
        }
      } catch (Exception ex) {
      }
    } else if (value is vx_core.Type_string) {
      val valstr : vx_core.Type_string = value as vx_core.Type_string
      val strval : String = valstr.vx_string()
      result = vx_is_int(strval)
    }
    return result
  }

  // vx_log(object...)
  fun vx_log(
    varags values : Any
  ) : Unit {
    for (value : Any in values) {
      var text : String = ""
      if (value == null) {
        text = "null"
      } else if (value is vx_core.Type_string) {
        val valstring : vx_core.Type_string = value as vx_core.Type_string
        text = valstring.vx_string()
      } else if (value is vx_core.Type_any) {
        val valany : vx_core.Type_any = value as vx_core.Type_anyvalue
        val valstring : vx_core.Type_string = vx_core.f_string_from_any(valany)
        text = valstring.vx_string()
      } else {
        text = value.toString()
      }
      println(text)
    }
  }

  // vx_msg_error
  fun vx_msg_error(
    text : String
  ) : Type_msg {
    val output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_exception
  fun vx_msg_from_exception(
    text : String,
    err : Exception
  ) : Type_msg {
    val output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    output.err = err
    vx_core.vx_log(output)
    return output
  }

  // vx_new(generic_any_1, args...)
  fun <T : vx_core.Type_any> vx_new(
    generic_any_1 : T,
    vararg vals : Any
  ) : T {
    val value : vx_core.Type_any = generic_any_1.vx_new(vals)
    val output : T = vx_core.f_any_from_any(generic_any_1, value)
    return output
  }

  // vx_copy(generic_any_1, args...)
  fun <T : vx_core.Type_any> vx_copy(
    copyval : T,
    vararg vals : Any
  ) : T {
    val value : vx_core.Type_any = copyval.vx_copy(vals)
    val output : T = vx_core.f_any_from_any(copyval, value)
    return output
  }

  // vx_empty(generic_any_1)
  fun <T : vx_core.Type_any> vx_empty(
    type : T
  ) : T {
    @Suppress("UNCHECKED_CAST")
    val output : T = type.vx_empty() as T
    return output
  }

  // vx_type(generic_any_1)
  fun <T : vx_core.Type_any> vx_type(
    type : T
  ) : T {
    @Suppress("UNCHECKED_CAST")
    val output : T = type.vx_type() as T
    return output
  }

  fun vx_new_boolean(
    isval : boolean
  ) : Type_boolean {
    var output : Type_boolean = vx_core.c_false
    if (isval) {
      output = vx_core.c_true
    }
    return output
  }

  fun vx_new_float(
    fval : float
  ) : Type_float {
    var output : Class_float = vx_core.Class_float()
    output.vxfloat = fval
    return output
  }

  fun vx_new_int(
    ival : int
  ) : Type_int {
    var output : Type_int
    if ((ival == 0) && vx_core.e_int != null) {
      output = vx_core.e_int
    } else {
      val work : Class_int = vx_core.Class_int()
      work.vxint = ival
      output = work
    }
    return output
  }

  fun vx_new_string(
    text : String
  ) : Type_string {
    var output : Type_string
    if (text.equals("") && vx_core.e_string != null) {
      output = vx_core.e_string
    } else {
      val work : Class_string = vx_core.Class_string()
      work.vxstring = text
      output = work
    }
    return output
  }

  fun vx_string_from_any(
    value : vx_core.Type_any
  ) : String {
    return vx_string_from_any_indent(value, 0, false)
  }

  fun vx_string_from_any_indent(
    value : vx_core.Type_any,
    indent : int,
    linefeed : boolean
  ) : String {
    val indenttext : String = " ".repeat(indent)
    var output : String = ""
    if (indent > 50) {
      output = "Error: Max Depth Exceeded"
    } else if (value == null) {
      output = "null"
    } else if (value == value.vx_type()) {
      if (value is vx_core.Type_func) {
        val valuefunc : vx_core.Type_func = value as vx_core.Type_func
        val funcdef : vx_core.Type_funcdef = valuefunc.vx_funcdef()
        output = funcdef.pkgname().vx_string() + "/" + funcdef.name().vx_string()
      } else {
        val typedef : vx_core.Type_typedef = value.vx_typedef()
        output = typedef.pkgname().vx_string() + "/" + typedef.name().vx_string()
      }
    } else if (value is vx_core.Type_boolean) {
      val valbool : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, value)
      if (valbool.vx_boolean() == true) {
        output = "true"
      } else {
        output = "false"
      }
    } else if (value is vx_core.Type_decimal) {
      val valdec : vx_core.Type_decimal = vx_core.f_any_from_any(vx_core.t_decimal, value)
      output = valdec.vx_string()
    } else if (value is vx_core.Type_float) {
      val valfloat : vx_core.Type_float = vx_core.f_any_from_any(vx_core.t_float, value)
      output = Float.toString(valfloat.vx_float())
      if (output.endsWith(".0")) {
        output = output.substring(0, output.length() - 2)
      }
    } else if (value is vx_core.Type_int) {
      if (value == vx_core.c_notanumber) {
        output = "notanumber"
      } else if (value == vx_core.c_infinity) {
        output = "infinity"
      } else if (value == vx_core.c_neginfinity) {
        output = "neginfinity"
      } else {
        val valint : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, value)
        output = Integer.toString(valint.vx_int())
      }
    } else if (value is vx_core.Type_string) {
      val valstring : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, value)
      output = "\"" + valstring.vx_string() + "\""
    } else if (value.vx_constdef() != vx_core.e_constdef) {
      val constdef : vx_core.Type_constdef = value.vx_constdef()
      val constpkg : String = constdef.pkgname().vx_string()
      val constname : String = constdef.name().vx_string()
      if (constpkg.equals("vx/core")) {
        output = constname
      } else {
        output = constpkg + "/" + constname
      }
    } else if (value is vx_core.Type_list) {
      val vallist : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, value)
      val typedef : vx_core.Type_typedef = vallist.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint : int = indent
      indentint += 1
      val listval : List<vx_core.Type_any> = vallist.vx_list()
      for (valsub : vx_core.Type_any in listval) {
        val valtext : String = vx_core.vx_string_from_any_indent(valsub, indentint, linefeed)
        output += "\n " + indenttext + valtext
      }
      if (vallist.vx_msgblock() != null) {
        val msgtext : String = vx_core.vx_string_from_any_indent(vallist.vx_msgblock(), indentint, linefeed)
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_map) {
      val valmap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, value)
      val typedef : vx_core.Type_typedef = valmap.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint : int = indent
      indentint += 2
      val mapval : Map<String, vx_core.Type_any> = valmap.vx_map()
      val keys : Set<String> = mapval.keySet()
      for (val key : String in keys) {
        val valsub : vx_core.Type_any = mapval.get(key)
        if (!key.startsWith(":")) {
          key = ":" + key
        }
        var strval : String = vx_core.vx_string_from_any_indent(valsub, indentint, linefeed)
        if (strval.contains("\n")) {
          strval = "\n  " + indenttext + strval
        } else {
          strval = " " + strval
        }
        output += "\n" + indenttext + " " + key + strval
      }
      if (valmap.vx_msgblock() != null) {
        val msgtext : String = vx_core.vx_string_from_any_indent(valmap.vx_msgblock(), indentint, linefeed)
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_struct) {
      val valstruct : vx_core.Type_struct = vx_core.f_any_from_any(vx_core.t_struct, value)
      val typedef : vx_core.Type_typedef = valstruct.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint2 : int = indent
      indentint2 += 2
      val mapval2 : Map<String, vx_core.Type_any> = valstruct.vx_map()
      val keys2 : Set<String> = mapval2.keySet()
      for (val : String in keys2) {
        val valsub2 : vx_core.Type_any = mapval2.get(key)
        if (!vx_ore.f_is_empty_1(valsub2).vx_boolean()) {
          if (!key.startsWith(":")) {
            key = ":" + key
          }
          val strval2 : String = vx_core.vx_string_from_any_indent(valsub2, indentint2, linefeed)
          if (strval2.contains("\n")) {
            strval2 = "\n  " + indenttext + strval2
          } else {
            strval2 = " " + strval2
          }
          output += "\n" + indenttext + " " + key + strval2
        }
      }
      if (valstruct.vx_msgblock() != null) {
        val msgtext2 : String = vx_core.vx_string_from_any_indent(valstruct.vx_msgblock(), indentint2, linefeed)
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext2
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_func) {
      val valfunc : vx_core.Type_func = vx_core.f_any_from_any(vx_core.t_func, value)
      val funcdef : vx_core.Type_funcdef = valfunc.vx_funcdef()
      val funcdefname : vx_core.Type_string = vx_core.f_funcname_from_funcdef(funcdef)
      output = funcdefname.vx_string()
      if (valfunc.vx_msgblock() != null) {
        val msgtext : String = vx_core.vx_string_from_any_indent(valfunc.vx_msgblock(), indent, linefeed)
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + output + ")"
    }
    return output
  }

  fun vx_string_from_string_start_end(
    text : String,
    start : int,
    end : int
  ) : String {
    var output : String = ""
    maxlen : int = text.length()
    if (end < 0) {
     end += maxlen
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end >= maxlen) {
        end = maxlen
      }
      output = text.substring(start - 1, end)
    }
    return output
  }

  fun typedef_new(
    pkgname : String,
    name : String,
    extend : String,
    traits : vx_core.Type_typelist,
    allowtypes : vx_core.Type_typelist,
    disallowtypes : vx_core.Type_typelist,
    allowfuncs : vx_core.Type_funclist,
    disallowfuncs : vx_core.Type_funclist,
    allowvalues : vx_core.Type_anylist,
    disallowvalues : vx_core.Type_anylist,
    properties : vx_core.Type_argmap
  ) : vx_core.Type_typedef {
    val output : vx_core.Class_typedef = vx_core.Class_typedef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_extend = vx_core.vx_new_string(extend)
    output.vx_p_traits = traits
    output.vx_p_allowtypes = allowtypes
    output.vx_p_disallowtypes = disallowtypes
    output.vx_p_allowfuncs = disallowfuncs
    output.vx_p_disallowfuncs = disallowfuncs
    output.vx_p_allowvalues = disallowvalues
    output.vx_p_disallowvalues = disallowvalues
    output.vx_p_properties = properties
    return output
  }

  fun vx_anylist_from_arraystring(
    arraystring : Array<String>
  ) : vx_core.Type_anylist {
    val listany : MutableList<Any> = mutableListOf()
    for (svalue : String in arraystring) {
      val value : vx_core.Type_string = vx_core.vx_new_string(svalue)
      listany.add(value)
    }
    val arrayany : Array<Any> = listany.toTypedArray()
    val output : vx_core.Type_anylist = vx_core.vx_new(
      vx_core.t_anylist,
      *arrayany)
    return output
  }

  // Warning!: Blocking
  fun <T extends vx_core.Type_any> vx_sync_from_async(
    generic_any_1 : T,
    future : CompletableFuture<T>
  ) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    try {
      output = future.get()
    } catch (Exception e) {
      val msg : vx_core.Type_msg = vx_core.vx_msg_from_exception("sync<-async", e)
      val val : vx_core.Type_any = generic_any_1.vx_new(msg)
      output = vx_core.f_any_from_any(generic_any_1, val)
    }
    return output
  }

  interface Type_any {
    fun vx_new(vararg vals : Any) : vx_core.Type_any
    fun vx_copy(vararg vals : Any) : vx_core.Type_any
    fun vx_empty() : vx_core.Type_any
    fun vx_type() : vx_core.Type_any
    fun vx_typedef() : vx_core.Type_typedef
    fun vx_constdef() : vx_core.Type_constdef
    fun vx_dispose() : List<vx_core.Type_any>
    fun vx_msgblock() : vx_core.Type_msgblock
    fun vx_release() : Boolean
    fun vx_reserve() : Unit
  }

  class Class_any : vx_core.Class_base, Type_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.vx_copy(vx_core.e_any, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any = this
      var ischanged : Boolean = false
      var value : vx_core.Class_any = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_any = vx_core.Class_any()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "any", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_any : vx_core.Type_any = vx_core.Class_any()
  val t_any : vx_core.Type_any = vx_core.Class_any()

  interface Type_any_async_from_func : vx_core.Type_any {
  }

  class Class_any_async_from_func : vx_core.Class_base, Type_any_async_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any_async_from_func {
      var output : vx_core.Type_any_async_from_func = vx_core.vx_copy(vx_core.e_any_async_from_func, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any_async_from_func = this
      var ischanged : Boolean = false
      var value : vx_core.Class_any_async_from_func = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_any_async_from_func = vx_core.Class_any_async_from_func()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_async_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_async_from_func
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "any-async<-func", // name
        ":func", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_any_async_from_func : vx_core.Type_any_async_from_func = vx_core.Class_any_async_from_func()
  val t_any_async_from_func : vx_core.Type_any_async_from_func = vx_core.Class_any_async_from_func()

  interface Type_any_from_anylist : vx_core.Type_list {
    fun vx_listany_from_any() : List<vx_core.Func_any_from_any>
    fun vx_any_from_any(index : vx_core.Type_int) : vx_core.Func_any_from_any
  }

  class Class_any_from_anylist : vx_core.Class_base, Type_any_from_anylist {
    constructor() {}

    var vx_p_list : List<vx_core.Func_any_from_any> = vx_core.immutablelist(
      ArrayList<vx_core.Func_any_from_any>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_any_from_any(index : vx_core.Type_int) : vx_core.Func_any_from_any {
      var output : vx_core.Func_any_from_any = vx_core.e_any_from_any
      var list : vx_core.Class_any_from_anylist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Func_any_from_any> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listany_from_any() : List<vx_core.Func_any_from_any> {
      var output : List<vx_core.Func_any_from_any> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Func_any_from_any = this.vx_any_from_any(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any_from_anylist {
      var output : vx_core.Type_any_from_anylist = vx_core.vx_copy(vx_core.e_any_from_anylist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any_from_anylist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_any_from_anylist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Func_any_from_any> = ArrayList<vx_core.Func_any_from_any>(value.vx_listany_from_any())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Func_any_from_any) {
          var allowsub : vx_core.Func_any_from_any = valsub as vx_core.Func_any_from_any
          ischanged = true
          
        } else if (valsub is vx_core.Type_any_from_anylist) {
          var multi : vx_core.Type_any_from_anylist = valsub as vx_core.Type_any_from_anylist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_any_from_anylist = vx_core.Class_any_from_anylist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_anylist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_anylist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "any<-anylist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_any_from_anylist : vx_core.Type_any_from_anylist = vx_core.Class_any_from_anylist()
  val t_any_from_anylist : vx_core.Type_any_from_anylist = vx_core.Class_any_from_anylist()

  interface Type_anylist : vx_core.Type_list {
  }

  class Class_anylist : vx_core.Class_base, Type_anylist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_anylist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_anylist {
      var output : vx_core.Type_anylist = vx_core.vx_copy(vx_core.e_anylist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anylist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_anylist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          
        } else if (valsub is vx_core.Type_anylist) {
          var multi : vx_core.Type_anylist = valsub as vx_core.Type_anylist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/anylist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/anylist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_anylist = vx_core.Class_anylist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_anylist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_anylist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "anylist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_anylist : vx_core.Type_anylist = vx_core.Class_anylist()
  val t_anylist : vx_core.Type_anylist = vx_core.Class_anylist()

  interface Type_anymap : vx_core.Type_map {
  }

  class Class_anymap : vx_core.Class_base, Type_anymap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_anymap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = 
      return output
    }

    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_anymap = vx_core.Class_anymap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/anymap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_anymap {
      var output : vx_core.Type_anymap = vx_core.vx_copy(vx_core.e_anymap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anymap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_anymap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/anymap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = null
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/anymap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_anymap = vx_core.Class_anymap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_anymap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_anymap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "anymap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_anymap : vx_core.Type_anymap = vx_core.Class_anymap()
  val t_anymap : vx_core.Type_anymap = vx_core.Class_anymap()

  interface Type_anytype : vx_core.Type_any {
  }

  class Class_anytype : vx_core.Class_base, Type_anytype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_anytype {
      var output : vx_core.Type_anytype = vx_core.vx_copy(vx_core.e_anytype, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anytype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_anytype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_anytype = vx_core.Class_anytype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_anytype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_anytype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "anytype", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_anytype : vx_core.Type_anytype = vx_core.Class_anytype()
  val t_anytype : vx_core.Type_anytype = vx_core.Class_anytype()

  interface Type_arg : vx_core.Type_struct {
    fun name() : vx_core.Type_string
    fun argtype() : vx_core.Type_any
    fun fn_any() : vx_core.Func_any_from_func
    fun doc() : vx_core.Type_string
  }

  class Class_arg : vx_core.Class_base, Type_arg {
    constructor() {}

    var vx_p_name : vx_core.Type_string = null

    fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_name != null) {
        output = this.vx_p_name
      }
      return output
    }

    var vx_p_argtype : vx_core.Type_any = null

    fun argtype() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_argtype != null) {
        output = this.vx_p_argtype
      }
      return output
    }

    var vx_p_fn_any : vx_core.Func_any_from_func = null

    fun fn_any() : vx_core.Func_any_from_func {
      var output : vx_core.Func_any_from_func = vx_core.e_any_from_func
      if (this.vx_p_fn_any != null) {
        output = this.vx_p_fn_any
      }
      return output
    }

    var vx_p_doc : vx_core.Type_string = null

    fun doc() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_doc != null) {
        output = this.vx_p_doc
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":name":
        output = this.name()
        break
      case ":argtype":
        output = this.argtype()
        break
      case ":fn-any":
        output = this.fn_any()
        break
      case ":doc":
        output = this.doc()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":name", this.name())
      output.put(":argtype", this.argtype())
      output.put(":fn-any", this.fn_any())
      output.put(":doc", this.doc())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.vx_copy(vx_core.e_arg, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_arg = this
      var ischanged : Boolean = false
      var value : vx_core.Class_arg = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_argtype : vx_core.Type_any = value.argtype()
      var vx_p_fn_any : vx_core.Func_any_from_func = value.fn_any()
      var vx_p_doc : vx_core.Type_string = value.doc()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":name":
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":argtype":
            if (valsub == vx_p_argtype) {
            } else if (valsub is vx_core.Type_any) {
              var valargtype : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_argtype = valargtype
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("argtype"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":fn-any":
            if (valsub == vx_p_fn_any) {
            } else if (valsub is vx_core.Func_any_from_func) {
              var valfn_any : vx_core.Func_any_from_func = valsub as vx_core.Func_any_from_func
              ischanged = true
              vx_p_fn_any = valfn_any
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-any"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":doc":
            if (valsub == vx_p_doc) {
            } else if (valsub is vx_core.Type_string) {
              var valdoc : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_doc = valdoc
            } else if (valsub is String) {
              ischanged = true
              vx_p_doc = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("doc"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_arg = vx_core.Class_arg()
        work.vx_p_name = vx_p_name
        work.vx_p_argtype = vx_p_argtype
        work.vx_p_fn_any = vx_p_fn_any
        work.vx_p_doc = vx_p_doc
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_arg
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_arg
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "arg", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_arg : vx_core.Type_arg = vx_core.Class_arg()
  val t_arg : vx_core.Type_arg = vx_core.Class_arg()

  interface Type_arglist : vx_core.Type_list {
    fun vx_listarg() : List<vx_core.Type_arg>
    fun vx_arg(index : vx_core.Type_int) : vx_core.Type_arg
  }

  class Class_arglist : vx_core.Class_base, Type_arglist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_arg> = vx_core.immutablelist(
      ArrayList<vx_core.Type_arg>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_arg(index : vx_core.Type_int) : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.e_arg
      var list : vx_core.Class_arglist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_arg> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listarg() : List<vx_core.Type_arg> {
      var output : List<vx_core.Type_arg> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_arg = this.vx_arg(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_arglist {
      var output : vx_core.Type_arglist = vx_core.vx_copy(vx_core.e_arglist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_arglist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_arglist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_arg> = ArrayList<vx_core.Type_arg>(value.vx_listarg())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_arg) {
          var allowsub : vx_core.Type_arg = valsub as vx_core.Type_arg
          ischanged = true
          
        } else if (valsub is vx_core.Type_arg) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_arglist) {
          var multi : vx_core.Type_arglist = valsub as vx_core.Type_arglist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/arglist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/arglist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_arglist = vx_core.Class_arglist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_arglist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_arglist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "arglist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_arg), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_arglist : vx_core.Type_arglist = vx_core.Class_arglist()
  val t_arglist : vx_core.Type_arglist = vx_core.Class_arglist()

  interface Type_argmap : vx_core.Type_map {
    fun vx_maparg() : Map<String, vx_core.Type_arg>
    fun vx_arg(key : vx_core.Type_string) : vx_core.Type_arg
  }

  class Class_argmap : vx_core.Class_base, Type_argmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_arg> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_arg>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_arg) {
        var castval : vx_core.Type_arg = value as vx_core.Type_arg
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_arg> = LinkedHashMap<String, vx_core.Type_arg>(this.vx_p_map)
        if (castval == vx_core.e_arg) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_arg(key : vx_core.Type_string) : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.e_arg
      var map : vx_core.Class_argmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_arg> = map.vx_p_map
      output = 
      return output
    }

    fun vx_maparg() : Map<String, vx_core.Type_arg> {
      var output : Map<String, vx_core.Type_arg> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_arg(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_argmap = vx_core.Class_argmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_arg> = LinkedHashMap<String, vx_core.Type_arg>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_arg) {
          var castval : vx_core.Type_arg = value as vx_core.Type_arg
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/argmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_argmap {
      var output : vx_core.Type_argmap = vx_core.vx_copy(vx_core.e_argmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_argmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_argmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_arg> = LinkedHashMap<String, vx_core.Type_arg>(value.vx_maparg())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/argmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_arg = null
          if (false) {
          } else if (valsub is vx_core.Type_arg) {
            var valallowed : vx_core.Type_arg = valsub as vx_core.Type_arg
            valany = valallowed
          } else if (valsub is vx_core.Type_arg) {
            valany = valsub as vx_core.Type_arg
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/argmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_argmap = vx_core.Class_argmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_argmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_argmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "argmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_arg), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_argmap : vx_core.Type_argmap = vx_core.Class_argmap()
  val t_argmap : vx_core.Type_argmap = vx_core.Class_argmap()

  interface Type_boolean : vx_core.Type_any {
    fun vx_boolean() : Boolean
  }

  class Class_boolean : vx_core.Class_base, Type_boolean {
    constructor() {}

    internal val vxboolean : Boolean = false
    
    // :implements
    override fun vx_boolean() : Boolean {
      return vxboolean;
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.vx_copy(vx_core.e_boolean, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_boolean = this
      var ischanged : Boolean = false
      var value : vx_core.Class_boolean = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var booleanval : Boolean = value.vx_boolean()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_boolean) {
          var valboolean : vx_core.Type_boolean = valsub as vx_core.Type_boolean
          booleanval = booleanval || valboolean.vx_boolean()
        } else if (valsub is Boolean) {
          var issubval : Boolean = valsub as Boolean
          booleanval = booleanval || issubval
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_boolean = vx_core.Class_boolean()
        work.vxboolean = booleanval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      } else if (booleanval) {
        output = vx_core.c_true
      } else {
        output = vx_core.c_false
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "boolean", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val t_boolean : vx_core.Type_boolean = vx_core.Class_boolean()

  interface Type_booleanlist : vx_core.Type_list {
    fun vx_listboolean() : List<vx_core.Type_boolean>
    fun vx_boolean(index : vx_core.Type_int) : vx_core.Type_boolean
  }

  class Class_booleanlist : vx_core.Class_base, Type_booleanlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_boolean> = vx_core.immutablelist(
      ArrayList<vx_core.Type_boolean>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_boolean(index : vx_core.Type_int) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.e_boolean
      var list : vx_core.Class_booleanlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_boolean> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listboolean() : List<vx_core.Type_boolean> {
      var output : List<vx_core.Type_boolean> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_boolean = this.vx_boolean(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_booleanlist {
      var output : vx_core.Type_booleanlist = vx_core.vx_copy(vx_core.e_booleanlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_booleanlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_booleanlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_boolean> = ArrayList<vx_core.Type_boolean>(value.vx_listboolean())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_boolean) {
          var allowsub : vx_core.Type_boolean = valsub as vx_core.Type_boolean
          ischanged = true
          
        } else if (valsub is vx_core.Type_boolean) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_booleanlist) {
          var multi : vx_core.Type_booleanlist = valsub as vx_core.Type_booleanlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_booleanlist = vx_core.Class_booleanlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_booleanlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_booleanlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "booleanlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_boolean), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_booleanlist : vx_core.Type_booleanlist = vx_core.Class_booleanlist()
  val t_booleanlist : vx_core.Type_booleanlist = vx_core.Class_booleanlist()

  interface Type_collection : vx_core.Type_any {
  }

  class Class_collection : vx_core.Class_base, Type_collection {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_collection {
      var output : vx_core.Type_collection = vx_core.vx_copy(vx_core.e_collection, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_collection = this
      var ischanged : Boolean = false
      var value : vx_core.Class_collection = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_collection = vx_core.Class_collection()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_collection
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_collection
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "collection", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_list, vx_core.t_map), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_collection : vx_core.Type_collection = vx_core.Class_collection()
  val t_collection : vx_core.Type_collection = vx_core.Class_collection()

  interface Type_compilelanguages : vx_core.Type_any {
  }

  class Class_compilelanguages : vx_core.Class_base, Type_compilelanguages {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_compilelanguages {
      var output : vx_core.Type_compilelanguages = vx_core.vx_copy(vx_core.e_compilelanguages, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_compilelanguages = this
      var ischanged : Boolean = false
      var value : vx_core.Class_compilelanguages = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_compilelanguages = vx_core.Class_compilelanguages()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_compilelanguages
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_compilelanguages
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "compilelanguages", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_compilelanguages : vx_core.Type_compilelanguages = vx_core.Class_compilelanguages()
  val t_compilelanguages : vx_core.Type_compilelanguages = vx_core.Class_compilelanguages()

  interface Type_connect : vx_core.Type_any {
  }

  class Class_connect : vx_core.Class_base, Type_connect {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_connect {
      var output : vx_core.Type_connect = vx_core.vx_copy(vx_core.e_connect, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connect = this
      var ischanged : Boolean = false
      var value : vx_core.Class_connect = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_connect = vx_core.Class_connect()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_connect
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_connect
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "connect", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_connect : vx_core.Type_connect = vx_core.Class_connect()
  val t_connect : vx_core.Type_connect = vx_core.Class_connect()

  interface Type_connectlist : vx_core.Type_list {
    fun vx_listconnect() : List<vx_core.Type_connect>
    fun vx_connect(index : vx_core.Type_int) : vx_core.Type_connect
  }

  class Class_connectlist : vx_core.Class_base, Type_connectlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_connect> = vx_core.immutablelist(
      ArrayList<vx_core.Type_connect>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_connect(index : vx_core.Type_int) : vx_core.Type_connect {
      var output : vx_core.Type_connect = vx_core.e_connect
      var list : vx_core.Class_connectlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_connect> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listconnect() : List<vx_core.Type_connect> {
      var output : List<vx_core.Type_connect> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_connect = this.vx_connect(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_connectlist {
      var output : vx_core.Type_connectlist = vx_core.vx_copy(vx_core.e_connectlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connectlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_connectlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_connect> = ArrayList<vx_core.Type_connect>(value.vx_listconnect())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_connect) {
          var allowsub : vx_core.Type_connect = valsub as vx_core.Type_connect
          ischanged = true
          
        } else if (valsub is vx_core.Type_connect) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_connectlist) {
          var multi : vx_core.Type_connectlist = valsub as vx_core.Type_connectlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_connectlist = vx_core.Class_connectlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_connectlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_connectlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "connectlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_connect), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_connectlist : vx_core.Type_connectlist = vx_core.Class_connectlist()
  val t_connectlist : vx_core.Type_connectlist = vx_core.Class_connectlist()

  interface Type_connectmap : vx_core.Type_map {
    fun vx_mapconnect() : Map<String, vx_core.Type_connect>
    fun vx_connect(key : vx_core.Type_string) : vx_core.Type_connect
  }

  class Class_connectmap : vx_core.Class_base, Type_connectmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_connect> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_connect>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_connect) {
        var castval : vx_core.Type_connect = value as vx_core.Type_connect
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_connect> = LinkedHashMap<String, vx_core.Type_connect>(this.vx_p_map)
        if (castval == vx_core.e_connect) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_connect(key : vx_core.Type_string) : vx_core.Type_connect {
      var output : vx_core.Type_connect = vx_core.e_connect
      var map : vx_core.Class_connectmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_connect> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapconnect() : Map<String, vx_core.Type_connect> {
      var output : Map<String, vx_core.Type_connect> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_connect(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_connectmap = vx_core.Class_connectmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_connect> = LinkedHashMap<String, vx_core.Type_connect>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_connect) {
          var castval : vx_core.Type_connect = value as vx_core.Type_connect
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/connectmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_connectmap {
      var output : vx_core.Type_connectmap = vx_core.vx_copy(vx_core.e_connectmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connectmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_connectmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_connect> = LinkedHashMap<String, vx_core.Type_connect>(value.vx_mapconnect())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/connectmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_connect = null
          if (false) {
          } else if (valsub is vx_core.Type_connect) {
            var valallowed : vx_core.Type_connect = valsub as vx_core.Type_connect
            valany = valallowed
          } else if (valsub is vx_core.Type_connect) {
            valany = valsub as vx_core.Type_connect
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/connectmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_connectmap = vx_core.Class_connectmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_connectmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_connectmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "connectmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_connect), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_connectmap : vx_core.Type_connectmap = vx_core.Class_connectmap()
  val t_connectmap : vx_core.Type_connectmap = vx_core.Class_connectmap()

  interface Type_const : vx_core.Type_any {
  }

  class Class_const : vx_core.Class_base, Type_const {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_const {
      var output : vx_core.Type_const = vx_core.vx_copy(vx_core.e_const, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_const = this
      var ischanged : Boolean = false
      var value : vx_core.Class_const = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_const = vx_core.Class_const()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_const
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_const
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "const", // name
        ":const", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_const : vx_core.Type_const = vx_core.Class_const()
  val t_const : vx_core.Type_const = vx_core.Class_const()

  interface Type_constdef : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun name() : vx_core.Type_string
    fun type() : vx_core.Type_any
  }

  class Class_constdef : vx_core.Class_base, Type_constdef {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string = null

    fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_pkgname != null) {
        output = this.vx_p_pkgname
      }
      return output
    }

    var vx_p_name : vx_core.Type_string = null

    fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_name != null) {
        output = this.vx_p_name
      }
      return output
    }

    var vx_p_type : vx_core.Type_any = null

    fun type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_type != null) {
        output = this.vx_p_type
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":pkgname":
        output = this.pkgname()
        break
      case ":name":
        output = this.name()
        break
      case ":type":
        output = this.type()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":pkgname", this.pkgname())
      output.put(":name", this.name())
      output.put(":type", this.type())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.vx_copy(vx_core.e_constdef, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constdef = this
      var ischanged : Boolean = false
      var value : vx_core.Class_constdef = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_type : vx_core.Type_any = value.type()
      List<String> validkeys = ArrayList<String>()
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":pkgname":
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":name":
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":type":
            if (valsub == vx_p_type) {
            } else if (valsub is vx_core.Type_any) {
              var valtype : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_type = valtype
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("type"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_constdef = vx_core.Class_constdef()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_name = vx_p_name
        work.vx_p_type = vx_p_type
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_constdef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_constdef
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "constdef", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_constdef : vx_core.Type_constdef = vx_core.Class_constdef()
  val t_constdef : vx_core.Type_constdef = vx_core.Class_constdef()

  interface Type_constlist : vx_core.Type_list {
  }

  class Class_constlist : vx_core.Class_base, Type_constlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_constlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_constlist {
      var output : vx_core.Type_constlist = vx_core.vx_copy(vx_core.e_constlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_constlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          
        } else if (valsub is vx_core.Type_constlist) {
          var multi : vx_core.Type_constlist = valsub as vx_core.Type_constlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/constlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/constlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_constlist = vx_core.Class_constlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_constlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_constlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "constlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_constlist : vx_core.Type_constlist = vx_core.Class_constlist()
  val t_constlist : vx_core.Type_constlist = vx_core.Class_constlist()

  interface Type_constmap : vx_core.Type_map {
  }

  class Class_constmap : vx_core.Class_base, Type_constmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_constmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = 
      return output
    }

    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_constmap = vx_core.Class_constmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/constmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_constmap {
      var output : vx_core.Type_constmap = vx_core.vx_copy(vx_core.e_constmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_constmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/constmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = null
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/constmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_constmap = vx_core.Class_constmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_constmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_constmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "constmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_constmap : vx_core.Type_constmap = vx_core.Class_constmap()
  val t_constmap : vx_core.Type_constmap = vx_core.Class_constmap()

  interface Type_context : vx_core.Type_struct {
    fun code() : vx_core.Type_string
    fun session() : vx_core.Type_session
    fun setting() : vx_core.Type_setting
    fun state() : vx_core.Type_state
  }

  class Class_context : vx_core.Class_base, Type_context {
    constructor() {}

    var vx_p_code : vx_core.Type_string = null

    fun code() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_code != null) {
        output = this.vx_p_code
      }
      return output
    }

    var vx_p_session : vx_core.Type_session = null

    fun session() : vx_core.Type_session {
      var output : vx_core.Type_session = vx_core.e_session
      if (this.vx_p_session != null) {
        output = this.vx_p_session
      }
      return output
    }

    var vx_p_setting : vx_core.Type_setting = null

    fun setting() : vx_core.Type_setting {
      var output : vx_core.Type_setting = vx_core.e_setting
      if (this.vx_p_setting != null) {
        output = this.vx_p_setting
      }
      return output
    }

    var vx_p_state : vx_core.Type_state = null

    fun state() : vx_core.Type_state {
      var output : vx_core.Type_state = vx_core.e_state
      if (this.vx_p_state != null) {
        output = this.vx_p_state
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":code":
        output = this.code()
        break
      case ":session":
        output = this.session()
        break
      case ":setting":
        output = this.setting()
        break
      case ":state":
        output = this.state()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":code", this.code())
      output.put(":session", this.session())
      output.put(":setting", this.setting())
      output.put(":state", this.state())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_context {
      var output : vx_core.Type_context = vx_core.vx_copy(vx_core.e_context, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_context = this
      var ischanged : Boolean = false
      var value : vx_core.Class_context = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_code : vx_core.Type_string = value.code()
      var vx_p_session : vx_core.Type_session = value.session()
      var vx_p_setting : vx_core.Type_setting = value.setting()
      var vx_p_state : vx_core.Type_state = value.state()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":code":
            if (valsub == vx_p_code) {
            } else if (valsub is vx_core.Type_string) {
              var valcode : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_code = valcode
            } else if (valsub is String) {
              ischanged = true
              vx_p_code = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("code"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":session":
            if (valsub == vx_p_session) {
            } else if (valsub is vx_core.Type_session) {
              var valsession : vx_core.Type_session = valsub as vx_core.Type_session
              ischanged = true
              vx_p_session = valsession
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("session"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":setting":
            if (valsub == vx_p_setting) {
            } else if (valsub is vx_core.Type_setting) {
              var valsetting : vx_core.Type_setting = valsub as vx_core.Type_setting
              ischanged = true
              vx_p_setting = valsetting
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("setting"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":state":
            if (valsub == vx_p_state) {
            } else if (valsub is vx_core.Type_state) {
              var valstate : vx_core.Type_state = valsub as vx_core.Type_state
              ischanged = true
              vx_p_state = valstate
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("state"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_context = vx_core.Class_context()
        work.vx_p_code = vx_p_code
        work.vx_p_session = vx_p_session
        work.vx_p_setting = vx_p_setting
        work.vx_p_state = vx_p_state
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_context
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "context", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_context : vx_core.Type_context = vx_core.Class_context()
  val t_context : vx_core.Type_context = vx_core.Class_context()

  interface Type_date : vx_core.Type_any {
  }

  class Class_date : vx_core.Class_base, Type_date {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_date {
      var output : vx_core.Type_date = vx_core.vx_copy(vx_core.e_date, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_date = this
      var ischanged : Boolean = false
      var value : vx_core.Class_date = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_date = vx_core.Class_date()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_date
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_date
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "date", // name
        ":string", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_date : vx_core.Type_date = vx_core.Class_date()
  val t_date : vx_core.Type_date = vx_core.Class_date()

  interface Type_decimal : vx_core.Type_number {
  }

  class Class_decimal : vx_core.Class_base, Type_decimal {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_decimal {
      var output : vx_core.Type_decimal = vx_core.vx_copy(vx_core.e_decimal, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_decimal = this
      var ischanged : Boolean = false
      var value : vx_core.Class_decimal = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      String sval = value.vx_string()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_string) {
          var valstring : vx_core.Type_string = valsub as vx_core.Type_string
          ischanged = true
          sval = valstring.vx_string()
        } else if (valsub is String) {
          var svalsub : String = valsub as String
          ischanged = true
          sval = svalsub
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_decimal = vx_core.Class_decimal()
        work.vxdecimal = sval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_decimal
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_decimal
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "decimal", // name
        "", // extends
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_decimal : vx_core.Type_decimal = vx_core.Class_decimal()
  val t_decimal : vx_core.Type_decimal = vx_core.Class_decimal()

  interface Type_error : vx_core.Type_any {
  }

  class Class_error : vx_core.Class_base, Type_error {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_error {
      var output : vx_core.Type_error = vx_core.vx_copy(vx_core.e_error, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_error = this
      var ischanged : Boolean = false
      var value : vx_core.Class_error = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_error = vx_core.Class_error()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_error
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_error
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "error", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_error : vx_core.Type_error = vx_core.Class_error()
  val t_error : vx_core.Type_error = vx_core.Class_error()

  interface Type_float : vx_core.Type_number {
    fun float vx_float()
  }

  class Class_float : vx_core.Class_base, Type_float {
    constructor() {}

    internal val vxfloat : float = 0
    
    // :implements
    override fun float vx_float() {
      return vxfloat
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_float {
      var output : vx_core.Type_float = vx_core.vx_copy(vx_core.e_float, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_float = this
      var ischanged : Boolean = false
      var value : vx_core.Class_float = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      float floatval = value.vx_float()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_decimal) {
          var valdecimal : vx_core.Type_decimal = valsub as vx_core.Type_decimal
          ischanged = true
          floatval += valdecimal.vx_float()
        } else if (valsub is vx_core.Type_float) {
          var valfloat : vx_core.Type_float = valsub as vx_core.Type_float
          ischanged = true
          floatval += valfloat.vx_float()
        } else if (valsub is vx_core.Type_int) {
          var valint : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          floatval += valint.vx_int()
        } else if (valsub is vx_core.Type_string) {
          var valstring : vx_core.Type_string = valsub as vx_core.Type_string
          ischanged = true
          floatval += 
        } else if (valsub is Float) {
          var fval : Float = valsub as Float
          ischanged = true
          floatval += fval
        } else if (valsub is Integer) {
          var ival : Integer = valsub as Integer
          ischanged = true
          floatval += ival
        } else if (valsub is String) {
          var sval : String = valsub as String
          ischanged = true
          floatval += 
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_float = vx_core.Class_float()
        work.vxfloat = floatval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_float
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_float
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "float", // name
        "", // extends
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_float : vx_core.Type_float = vx_core.Class_float()
  val t_float : vx_core.Type_float = vx_core.Class_float()

  interface Type_func : vx_core.Type_any {
    fun vx_funcdef() : vx_core.Type_funcdef
  }

  class Class_func : vx_core.Class_base, Type_func {
    constructor() {}

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.e_funcdef
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_func {
      var output : vx_core.Type_func = vx_core.vx_copy(vx_core.e_func, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_func = this
      var ischanged : Boolean = false
      var value : vx_core.Class_func = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_func = vx_core.Class_func()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_func
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "func", // name
        ":func", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_func : vx_core.Type_func = vx_core.Class_func()
  val t_func : vx_core.Type_func = vx_core.Class_func()

  interface Type_funcdef : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun name() : vx_core.Type_string
    fun idx() : vx_core.Type_int
    fun type() : vx_core.Type_any
    fun async() : vx_core.Type_boolean
  }

  class Class_funcdef : vx_core.Class_base, Type_funcdef {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string = null

    fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_pkgname != null) {
        output = this.vx_p_pkgname
      }
      return output
    }

    var vx_p_name : vx_core.Type_string = null

    fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_name != null) {
        output = this.vx_p_name
      }
      return output
    }

    var vx_p_idx : vx_core.Type_int = null

    fun idx() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      if (this.vx_p_idx != null) {
        output = this.vx_p_idx
      }
      return output
    }

    var vx_p_type : vx_core.Type_any = null

    fun type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_type != null) {
        output = this.vx_p_type
      }
      return output
    }

    var vx_p_async : vx_core.Type_boolean = null

    fun async() : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.e_boolean
      if (this.vx_p_async != null) {
        output = this.vx_p_async
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":pkgname":
        output = this.pkgname()
        break
      case ":name":
        output = this.name()
        break
      case ":idx":
        output = this.idx()
        break
      case ":type":
        output = this.type()
        break
      case ":async":
        output = this.async()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":pkgname", this.pkgname())
      output.put(":name", this.name())
      output.put(":idx", this.idx())
      output.put(":type", this.type())
      output.put(":async", this.async())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.vx_copy(vx_core.e_funcdef, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funcdef = this
      var ischanged : Boolean = false
      var value : vx_core.Class_funcdef = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_idx : vx_core.Type_int = value.idx()
      var vx_p_type : vx_core.Type_any = value.type()
      var vx_p_async : vx_core.Type_boolean = value.async()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":pkgname":
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":name":
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":idx":
            if (valsub == vx_p_idx) {
            } else if (valsub is vx_core.Type_int) {
              var validx : vx_core.Type_int = valsub as vx_core.Type_int
              ischanged = true
              vx_p_idx = validx
            } else if (valsub is Integer) {
              ischanged = true
              vx_p_idx = vx_core.vx_new(vx_core.t_int, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("idx"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":type":
            if (valsub == vx_p_type) {
            } else if (valsub is vx_core.Type_any) {
              var valtype : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_type = valtype
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("type"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":async":
            if (valsub == vx_p_async) {
            } else if (valsub is vx_core.Type_boolean) {
              var valasync : vx_core.Type_boolean = valsub as vx_core.Type_boolean
              ischanged = true
              vx_p_async = valasync
            } else if (valsub is Boolean) {
              ischanged = true
              vx_p_async = vx_core.vx_new(vx_core.t_boolean, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("async"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_funcdef = vx_core.Class_funcdef()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_name = vx_p_name
        work.vx_p_idx = vx_p_idx
        work.vx_p_type = vx_p_type
        work.vx_p_async = vx_p_async
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcdef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcdef
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "funcdef", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_funcdef : vx_core.Type_funcdef = vx_core.Class_funcdef()
  val t_funcdef : vx_core.Type_funcdef = vx_core.Class_funcdef()

  interface Type_funclist : vx_core.Type_list {
    fun vx_listfunc() : List<vx_core.Type_func>
    fun vx_func(index : vx_core.Type_int) : vx_core.Type_func
  }

  class Class_funclist : vx_core.Class_base, Type_funclist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_func> = vx_core.immutablelist(
      ArrayList<vx_core.Type_func>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_func(index : vx_core.Type_int) : vx_core.Type_func {
      var output : vx_core.Type_func = vx_core.e_func
      var list : vx_core.Class_funclist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_func> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listfunc() : List<vx_core.Type_func> {
      var output : List<vx_core.Type_func> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_func = this.vx_func(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.vx_copy(vx_core.e_funclist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funclist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_funclist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_func> = ArrayList<vx_core.Type_func>(value.vx_listfunc())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_func) {
          var allowsub : vx_core.Type_func = valsub as vx_core.Type_func
          ischanged = true
          
        } else if (valsub is vx_core.Type_func) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_funclist) {
          var multi : vx_core.Type_funclist = valsub as vx_core.Type_funclist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/funclist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/funclist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_funclist = vx_core.Class_funclist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funclist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funclist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "funclist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_func), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_funclist : vx_core.Type_funclist = vx_core.Class_funclist()
  val t_funclist : vx_core.Type_funclist = vx_core.Class_funclist()

  interface Type_funcmap : vx_core.Type_map {
    fun vx_mapfunc() : Map<String, vx_core.Type_func>
    fun vx_func(key : vx_core.Type_string) : vx_core.Type_func
  }

  class Class_funcmap : vx_core.Class_base, Type_funcmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_func> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_func>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_func) {
        var castval : vx_core.Type_func = value as vx_core.Type_func
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>(this.vx_p_map)
        if (castval == vx_core.e_func) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_func(key : vx_core.Type_string) : vx_core.Type_func {
      var output : vx_core.Type_func = vx_core.e_func
      var map : vx_core.Class_funcmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_func> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapfunc() : Map<String, vx_core.Type_func> {
      var output : Map<String, vx_core.Type_func> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_func(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_funcmap = vx_core.Class_funcmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_func) {
          var castval : vx_core.Type_func = value as vx_core.Type_func
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/funcmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_funcmap {
      var output : vx_core.Type_funcmap = vx_core.vx_copy(vx_core.e_funcmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funcmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_funcmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>(value.vx_mapfunc())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/funcmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_func = null
          if (false) {
          } else if (valsub is vx_core.Type_func) {
            var valallowed : vx_core.Type_func = valsub as vx_core.Type_func
            valany = valallowed
          } else if (valsub is vx_core.Type_func) {
            valany = valsub as vx_core.Type_func
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/funcmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_funcmap = vx_core.Class_funcmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "funcmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_func), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_funcmap : vx_core.Type_funcmap = vx_core.Class_funcmap()
  val t_funcmap : vx_core.Type_funcmap = vx_core.Class_funcmap()

  interface Type_int : vx_core.Type_number {
    fun vx_int() : int
  }

  class Class_int : vx_core.Class_base, Type_int {
    constructor() {}

    internal val vxint : int = 0
    
    // :implements
    override fun vx_int() : int {
      return vxint
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.vx_copy(vx_core.e_int, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_int = this
      var ischanged : Boolean = false
      var value : vx_core.Class_int = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      int intval = value.vx_int()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_int) {
          var valint : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          intval += valint.vx_int()
        } else if (valsub is Integer) {
          var ival : Integer = valsub as Integer
          ischanged = true
          intval += ival
        } else if (valsub is String) {
          var sval : String = valsub as String
          ischanged = true
          intval += 
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_int = vx_core.Class_int()
        work.vxint = intval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_int
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_int
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "int", // name
        "", // extends
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_int : vx_core.Type_int = vx_core.Class_int()
  val t_int : vx_core.Type_int = vx_core.Class_int()

  interface Type_intlist : vx_core.Type_list {
    fun vx_listint() : List<vx_core.Type_int>
    fun vx_int(index : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_intlist : vx_core.Class_base, Type_intlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_int> = vx_core.immutablelist(
      ArrayList<vx_core.Type_int>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_int(index : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var list : vx_core.Class_intlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_int> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listint() : List<vx_core.Type_int> {
      var output : List<vx_core.Type_int> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_int = this.vx_int(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_intlist {
      var output : vx_core.Type_intlist = vx_core.vx_copy(vx_core.e_intlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_intlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_intlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_int> = ArrayList<vx_core.Type_int>(value.vx_listint())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_int) {
          var allowsub : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          
        } else if (valsub is Integer) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_intlist) {
          var multi : vx_core.Type_intlist = valsub as vx_core.Type_intlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/intlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/intlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_intlist = vx_core.Class_intlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_intlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_intlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "intlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_int), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_intlist : vx_core.Type_intlist = vx_core.Class_intlist()
  val t_intlist : vx_core.Type_intlist = vx_core.Class_intlist()

  interface Type_intmap : vx_core.Type_map {
    fun vx_mapint() : Map<String, vx_core.Type_int>
    fun vx_int(key : vx_core.Type_string) : vx_core.Type_int
  }

  class Class_intmap : vx_core.Class_base, Type_intmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_int> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_int>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_int) {
        var castval : vx_core.Type_int = value as vx_core.Type_int
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_int> = LinkedHashMap<String, vx_core.Type_int>(this.vx_p_map)
        if (castval == vx_core.e_int) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_int(key : vx_core.Type_string) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var map : vx_core.Class_intmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_int> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapint() : Map<String, vx_core.Type_int> {
      var output : Map<String, vx_core.Type_int> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_int(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_intmap = vx_core.Class_intmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_int> = LinkedHashMap<String, vx_core.Type_int>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_int) {
          var castval : vx_core.Type_int = value as vx_core.Type_int
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/intmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_intmap {
      var output : vx_core.Type_intmap = vx_core.vx_copy(vx_core.e_intmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_intmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_intmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_int> = LinkedHashMap<String, vx_core.Type_int>(value.vx_mapint())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/intmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_int = null
          if (false) {
          } else if (valsub is vx_core.Type_int) {
            var valallowed : vx_core.Type_int = valsub as vx_core.Type_int
            valany = valallowed
          } else if (valsub is Integer) {
            valany = vx_core.vx_new(vx_core.t_int, valsub)
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/intmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_intmap = vx_core.Class_intmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_intmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_intmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "intmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_int), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_intmap : vx_core.Type_intmap = vx_core.Class_intmap()
  val t_intmap : vx_core.Type_intmap = vx_core.Class_intmap()

  interface Type_list : vx_core.Type_any {
    fun vx_list() : List<vx_core.Type_any>
    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any
  }

  class Class_list : vx_core.Class_base, Type_list {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_list = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_list {
      var output : vx_core.Type_list = vx_core.vx_copy(vx_core.e_list, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_list = this
      var ischanged : Boolean = false
      var value : vx_core.Class_list = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          
        } else if (valsub is vx_core.Type_list) {
          var multi : vx_core.Type_list = valsub as vx_core.Type_list
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/list", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/list", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_list = vx_core.Class_list()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "list", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_list : vx_core.Type_list = vx_core.Class_list()
  val t_list : vx_core.Type_list = vx_core.Class_list()

  interface Type_listtype : vx_core.Type_any {
  }

  class Class_listtype : vx_core.Class_base, Type_listtype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_listtype {
      var output : vx_core.Type_listtype = vx_core.vx_copy(vx_core.e_listtype, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_listtype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_listtype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_listtype = vx_core.Class_listtype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_listtype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_listtype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "listtype", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_listtype : vx_core.Type_listtype = vx_core.Class_listtype()
  val t_listtype : vx_core.Type_listtype = vx_core.Class_listtype()

  interface Type_locale : vx_core.Type_struct {
  }

  class Class_locale : vx_core.Class_base, Type_locale {
    constructor() {}

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_locale {
      var output : vx_core.Type_locale = vx_core.vx_copy(vx_core.e_locale, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_locale = this
      var ischanged : Boolean = false
      var value : vx_core.Class_locale = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_locale = vx_core.Class_locale()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_locale
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_locale
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "locale", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_locale : vx_core.Type_locale = vx_core.Class_locale()
  val t_locale : vx_core.Type_locale = vx_core.Class_locale()

  interface Type_map : vx_core.Type_any {
    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map
    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any
    fun vx_map() : Map<String, vx_core.Type_any>
    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_map : vx_core.Class_base, Type_map {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_map = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = 
      return output
    }

    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_map = vx_core.Class_map()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/map", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_map {
      var output : vx_core.Type_map = vx_core.vx_copy(vx_core.e_map, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_map = this
      var ischanged : Boolean = false
      var value : vx_core.Class_map = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/map", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = null
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/map", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_map = vx_core.Class_map()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "map", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_map : vx_core.Type_map = vx_core.Class_map()
  val t_map : vx_core.Type_map = vx_core.Class_map()

  interface Type_maptype : vx_core.Type_any {
  }

  class Class_maptype : vx_core.Class_base, Type_maptype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_maptype {
      var output : vx_core.Type_maptype = vx_core.vx_copy(vx_core.e_maptype, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_maptype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_maptype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_maptype = vx_core.Class_maptype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_maptype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_maptype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "maptype", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_maptype : vx_core.Type_maptype = vx_core.Class_maptype()
  val t_maptype : vx_core.Type_maptype = vx_core.Class_maptype()

  interface Type_mempool : vx_core.Type_struct {
    fun valuepool() : vx_core.Type_value
  }

  class Class_mempool : vx_core.Class_base, Type_mempool {
    constructor() {}

    var vx_p_valuepool : vx_core.Type_value = null

    fun valuepool() : vx_core.Type_value {
      var output : vx_core.Type_value = vx_core.e_value
      if (this.vx_p_valuepool != null) {
        output = this.vx_p_valuepool
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":valuepool":
        output = this.valuepool()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":valuepool", this.valuepool())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_mempool {
      var output : vx_core.Type_mempool = vx_core.vx_copy(vx_core.e_mempool, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_mempool = this
      var ischanged : Boolean = false
      var value : vx_core.Class_mempool = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_valuepool : vx_core.Type_value = value.valuepool()
      List<String> validkeys = ArrayList<String>()
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":valuepool":
            if (valsub == vx_p_valuepool) {
            } else if (valsub is vx_core.Type_value) {
              var valvaluepool : vx_core.Type_value = valsub as vx_core.Type_value
              ischanged = true
              vx_p_valuepool = valvaluepool
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("valuepool"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_mempool = vx_core.Class_mempool()
        work.vx_p_valuepool = vx_p_valuepool
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_mempool
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_mempool
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "mempool", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_mempool : vx_core.Type_mempool = vx_core.Class_mempool()
  val t_mempool : vx_core.Type_mempool = vx_core.Class_mempool()

  interface Type_msg : vx_core.Type_struct {
    fun code() : vx_core.Type_string
    fun detail() : vx_core.Type_any
    fun path() : vx_core.Type_string
    fun severity() : vx_core.Type_int
    fun text() : vx_core.Type_string
  }

  class Class_msg : vx_core.Class_base, Type_msg {
    constructor() {}

    var vx_p_code : vx_core.Type_string = null

    fun code() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_code != null) {
        output = this.vx_p_code
      }
      return output
    }

    var vx_p_detail : vx_core.Type_any = null

    fun detail() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_detail != null) {
        output = this.vx_p_detail
      }
      return output
    }

    var vx_p_path : vx_core.Type_string = null

    fun path() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_path != null) {
        output = this.vx_p_path
      }
      return output
    }

    var vx_p_severity : vx_core.Type_int = null

    fun severity() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      if (this.vx_p_severity != null) {
        output = this.vx_p_severity
      }
      return output
    }

    var vx_p_text : vx_core.Type_string = null

    fun text() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_text != null) {
        output = this.vx_p_text
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":code":
        output = this.code()
        break
      case ":detail":
        output = this.detail()
        break
      case ":path":
        output = this.path()
        break
      case ":severity":
        output = this.severity()
        break
      case ":text":
        output = this.text()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":code", this.code())
      output.put(":detail", this.detail())
      output.put(":path", this.path())
      output.put(":severity", this.severity())
      output.put(":text", this.text())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.vx_copy(vx_core.e_msg, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msg = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msg = this
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_code : vx_core.Type_string = value.code()
      var vx_p_detail : vx_core.Type_any = value.detail()
      var vx_p_path : vx_core.Type_string = value.path()
      var vx_p_severity : vx_core.Type_int = value.severity()
      var vx_p_text : vx_core.Type_string = value.text()
      var key : String
      for (valsub : Any in vals) {
        if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstr.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          }
        } else {
          switch (key) {
          case ":code":
            if (valsub == vx_p_code) {
            } else if (valsub is vx_core.Type_string) {
              var valcode : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_code = valcode
            } else if (valsub is String) {
              ischanged = true
              vx_p_code = vx_core.vx_new(vx_core.t_string, valsub)
            }
            break
          case ":detail":
            if (valsub == vx_p_detail) {
            } else if (valsub is vx_core.Type_any) {
              var valdetail : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_detail = valdetail
            }
            break
          case ":path":
            if (valsub == vx_p_path) {
            } else if (valsub is vx_core.Type_string) {
              var valpath : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_path = valpath
            } else if (valsub is String) {
              ischanged = true
              vx_p_path = vx_core.vx_new(vx_core.t_string, valsub)
            }
            break
          case ":severity":
            if (valsub == vx_p_severity) {
            } else if (valsub is vx_core.Type_int) {
              var valseverity : vx_core.Type_int = valsub as vx_core.Type_int
              ischanged = true
              vx_p_severity = valseverity
            } else if (valsub is Integer) {
              ischanged = true
              vx_p_severity = vx_core.vx_new(vx_core.t_int, valsub)
            }
            break
          case ":text":
            if (valsub == vx_p_text) {
            } else if (valsub is vx_core.Type_string) {
              var valtext : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_text = valtext
            } else if (valsub is String) {
              ischanged = true
              vx_p_text = vx_core.vx_new(vx_core.t_string, valsub)
            }
            break
          }
          key = ""
        }
      }
      if (ischanged) {
        var work : vx_core.Class_msg = vx_core.Class_msg()
        work.vx_p_code = vx_p_code
        work.vx_p_detail = vx_p_detail
        work.vx_p_path = vx_p_path
        work.vx_p_severity = vx_p_severity
        work.vx_p_text = vx_p_text
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msg", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msg : vx_core.Type_msg = vx_core.Class_msg()
  val t_msg : vx_core.Type_msg = vx_core.Class_msg()

  interface Type_msgblock : vx_core.Type_struct {
    fun msgs() : vx_core.Type_msglist
    fun msgblocks() : vx_core.Type_msgblocklist
  }

  class Class_msgblock : vx_core.Class_base, Type_msgblock {
    constructor() {}

    var vx_p_msgs : vx_core.Type_msglist = null

    fun msgs() : vx_core.Type_msglist {
      var output : vx_core.Type_msglist = vx_core.e_msglist
      if (this.vx_p_msgs != null) {
        output = this.vx_p_msgs
      }
      return output
    }

    var vx_p_msgblocks : vx_core.Type_msgblocklist = null

    fun msgblocks() : vx_core.Type_msgblocklist {
      var output : vx_core.Type_msgblocklist = vx_core.e_msgblocklist
      if (this.vx_p_msgblocks != null) {
        output = this.vx_p_msgblocks
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":msgs":
        output = this.msgs()
        break
      case ":msgblocks":
        output = this.msgblocks()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":msgs", this.msgs())
      output.put(":msgblocks", this.msgblocks())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock = vx_core.vx_copy(vx_core.e_msgblock, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msgblock = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msgblock = this
      var msgblock : vx_core.Type_msgblock = this
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_msgs : vx_core.Type_msglist = value.msgs()
      var vx_p_msgblocks : vx_core.Type_msgblocklist = value.msgblocks()
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          if (valsub != vx_core.e_msgblock) {
            vx_p_msgblocks = vx_core.vx_copy(vx_p_msgblocks, valsub)
            ischanged = true
          }
        } else if (valsub is vx_core.Type_msgblocklist) {
          if (valsub != vx_core.e_msgblocklist) {
            vx_p_msgblocks = vx_core.vx_copy(vx_p_msgblocks, valsub)
            ischanged = true
          }
        } else if (valsub is vx_core.Type_msg) {
          if (valsub != vx_core.e_msg) {
            vx_p_msgs = vx_core.vx_copy(vx_p_msgs, valsub)
            ischanged = true
          }
        } else if (valsub is vx_core.Type_msglist) {
          if (valsub != vx_core.e_msglist) {
            vx_p_msgs = vx_core.vx_copy(vx_p_msgs, valsub)
            ischanged = true
          }
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstr.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          }
        } else {
          switch (key) {
          case ":msgs":
            if (valsub == vx_p_msgs) {
            } else if (valsub is vx_core.Type_msglist) {
              var valmsgs : vx_core.Type_msglist = valsub as vx_core.Type_msglist
              ischanged = true
              vx_p_msgs = valmsgs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("msgs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":msgblocks":
            if (valsub == vx_p_msgblocks) {
            } else if (valsub is vx_core.Type_msgblocklist) {
              var valmsgblocks : vx_core.Type_msgblocklist = valsub as vx_core.Type_msgblocklist
              ischanged = true
              vx_p_msgblocks = valmsgblocks
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("msgblocks"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          }
          key = ""
        }
      }
      if (ischanged) {
        if ((vx_p_msgs.vx_list().size() == 0) && (vx_p_msgblocks.vx_list().size() == 1)) {
          output = 
        } else {
          var work : vx_core.Class_msgblock = vx_core.Class_msgblock()
          work.vx_p_msgs = vx_p_msgs
          work.vx_p_msgblocks = vx_p_msgblocks
          output = work
        }
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblock
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblock
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msgblock", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msgblock : vx_core.Type_msgblock = vx_core.Class_msgblock()
  val t_msgblock : vx_core.Type_msgblock = vx_core.Class_msgblock()

  interface Type_msgblocklist : vx_core.Type_list {
    fun vx_listmsgblock() : List<vx_core.Type_msgblock>
    fun vx_msgblock(index : vx_core.Type_int) : vx_core.Type_msgblock
  }

  class Class_msgblocklist : vx_core.Class_base, Type_msgblocklist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_msgblock> = vx_core.immutablelist(
      ArrayList<vx_core.Type_msgblock>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_msgblock(index : vx_core.Type_int) : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock = vx_core.e_msgblock
      var list : vx_core.Class_msgblocklist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_msgblock> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listmsgblock() : List<vx_core.Type_msgblock> {
      var output : List<vx_core.Type_msgblock> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_msgblock = this.vx_msgblock(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_msgblocklist {
      var output : vx_core.Type_msgblocklist = vx_core.vx_copy(vx_core.e_msgblocklist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msgblocklist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msgblocklist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_msgblock> = ArrayList<vx_core.Type_msgblock>(value.vx_listmsgblock())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msgblock) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_msgblocklist) {
          var multi : vx_core.Type_msgblocklist = valsub as vx_core.Type_msgblocklist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_msgblocklist = vx_core.Class_msgblocklist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblocklist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblocklist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msgblocklist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_msgblock), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msgblocklist : vx_core.Type_msgblocklist = vx_core.Class_msgblocklist()
  val t_msgblocklist : vx_core.Type_msgblocklist = vx_core.Class_msgblocklist()

  interface Type_msglist : vx_core.Type_list {
    fun vx_listmsg() : List<vx_core.Type_msg>
    fun vx_msg(index : vx_core.Type_int) : vx_core.Type_msg
  }

  class Class_msglist : vx_core.Class_base, Type_msglist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_msg> = vx_core.immutablelist(
      ArrayList<vx_core.Type_msg>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_msg(index : vx_core.Type_int) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.e_msg
      var list : vx_core.Class_msglist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_msg> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listmsg() : List<vx_core.Type_msg> {
      var output : List<vx_core.Type_msg> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_msg = this.vx_msg(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_msglist {
      var output : vx_core.Type_msglist = vx_core.vx_copy(vx_core.e_msglist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msglist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msglist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_msg> = ArrayList<vx_core.Type_msg>(value.vx_listmsg())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_msglist) {
          var multi : vx_core.Type_msglist = valsub as vx_core.Type_msglist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/msglist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/msglist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_msglist = vx_core.Class_msglist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msglist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msglist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msglist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_msg), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msglist : vx_core.Type_msglist = vx_core.Class_msglist()
  val t_msglist : vx_core.Type_msglist = vx_core.Class_msglist()

  interface Type_none : vx_core.Type_any {
  }

  class Class_none : vx_core.Class_base, Type_none {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_none {
      var output : vx_core.Type_none = vx_core.vx_copy(vx_core.e_none, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_none = this
      var ischanged : Boolean = false
      var value : vx_core.Class_none = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_none = vx_core.Class_none()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_none
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_none
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "none", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_none : vx_core.Type_none = vx_core.Class_none()
  val t_none : vx_core.Type_none = vx_core.Class_none()

  interface Type_notype : vx_core.Type_any {
  }

  class Class_notype : vx_core.Class_base, Type_notype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_notype {
      var output : vx_core.Type_notype = vx_core.vx_copy(vx_core.e_notype, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_notype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_notype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_notype = vx_core.Class_notype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_notype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_notype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "notype", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_notype : vx_core.Type_notype = vx_core.Class_notype()
  val t_notype : vx_core.Type_notype = vx_core.Class_notype()

  interface Type_number : vx_core.Type_any {
  }

  class Class_number : vx_core.Class_base, Type_number {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.vx_copy(vx_core.e_number, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_number = this
      var ischanged : Boolean = false
      var value : vx_core.Class_number = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_number = vx_core.Class_number()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_number
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_number
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "number", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_number : vx_core.Type_number = vx_core.Class_number()
  val t_number : vx_core.Type_number = vx_core.Class_number()

  interface Type_numberlist : vx_core.Type_list {
    fun vx_listnumber() : List<vx_core.Type_number>
    fun vx_number(index : vx_core.Type_int) : vx_core.Type_number
  }

  class Class_numberlist : vx_core.Class_base, Type_numberlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_number> = vx_core.immutablelist(
      ArrayList<vx_core.Type_number>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_number(index : vx_core.Type_int) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.e_number
      var list : vx_core.Class_numberlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_number> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listnumber() : List<vx_core.Type_number> {
      var output : List<vx_core.Type_number> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_number = this.vx_number(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_numberlist {
      var output : vx_core.Type_numberlist = vx_core.vx_copy(vx_core.e_numberlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_numberlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_numberlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_number> = ArrayList<vx_core.Type_number>(value.vx_listnumber())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_number) {
          var allowsub : vx_core.Type_number = valsub as vx_core.Type_number
          ischanged = true
          
        } else if (valsub is vx_core.Type_number) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_numberlist) {
          var multi : vx_core.Type_numberlist = valsub as vx_core.Type_numberlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_numberlist = vx_core.Class_numberlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_numberlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_numberlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "numberlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_numberlist : vx_core.Type_numberlist = vx_core.Class_numberlist()
  val t_numberlist : vx_core.Type_numberlist = vx_core.Class_numberlist()

  interface Type_numbermap : vx_core.Type_map {
    fun vx_mapnumber() : Map<String, vx_core.Type_number>
    fun vx_number(key : vx_core.Type_string) : vx_core.Type_number
  }

  class Class_numbermap : vx_core.Class_base, Type_numbermap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_number> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_number>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_number) {
        var castval : vx_core.Type_number = value as vx_core.Type_number
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_number> = LinkedHashMap<String, vx_core.Type_number>(this.vx_p_map)
        if (castval == vx_core.e_number) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_number(key : vx_core.Type_string) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.e_number
      var map : vx_core.Class_numbermap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_number> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapnumber() : Map<String, vx_core.Type_number> {
      var output : Map<String, vx_core.Type_number> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_number(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_numbermap = vx_core.Class_numbermap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_number> = LinkedHashMap<String, vx_core.Type_number>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_number) {
          var castval : vx_core.Type_number = value as vx_core.Type_number
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/numbermap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_numbermap {
      var output : vx_core.Type_numbermap = vx_core.vx_copy(vx_core.e_numbermap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_numbermap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_numbermap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_number> = LinkedHashMap<String, vx_core.Type_number>(value.vx_mapnumber())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/numbermap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_number = null
          if (false) {
          } else if (valsub is vx_core.Type_number) {
            var valallowed : vx_core.Type_number = valsub as vx_core.Type_number
            valany = valallowed
          } else if (valsub is vx_core.Type_number) {
            valany = valsub as vx_core.Type_number
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/numbermap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_numbermap = vx_core.Class_numbermap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_numbermap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_numbermap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "numbermap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_numbermap : vx_core.Type_numbermap = vx_core.Class_numbermap()
  val t_numbermap : vx_core.Type_numbermap = vx_core.Class_numbermap()

  interface Type_package : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun constmap() : vx_core.Type_constmap
    fun funcmap() : vx_core.Type_funcmap
    fun typemap() : vx_core.Type_typemap
    fun emptymap() : vx_core.Type_map
  }

  class Class_package : vx_core.Class_base, Type_package {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string = null

    fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_pkgname != null) {
        output = this.vx_p_pkgname
      }
      return output
    }

    var vx_p_constmap : vx_core.Type_constmap = null

    fun constmap() : vx_core.Type_constmap {
      var output : vx_core.Type_constmap = vx_core.e_constmap
      if (this.vx_p_constmap != null) {
        output = this.vx_p_constmap
      }
      return output
    }

    var vx_p_funcmap : vx_core.Type_funcmap = null

    fun funcmap() : vx_core.Type_funcmap {
      var output : vx_core.Type_funcmap = vx_core.e_funcmap
      if (this.vx_p_funcmap != null) {
        output = this.vx_p_funcmap
      }
      return output
    }

    var vx_p_typemap : vx_core.Type_typemap = null

    fun typemap() : vx_core.Type_typemap {
      var output : vx_core.Type_typemap = vx_core.e_typemap
      if (this.vx_p_typemap != null) {
        output = this.vx_p_typemap
      }
      return output
    }

    var vx_p_emptymap : vx_core.Type_map = null

    fun emptymap() : vx_core.Type_map {
      var output : vx_core.Type_map = vx_core.e_map
      if (this.vx_p_emptymap != null) {
        output = this.vx_p_emptymap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":pkgname":
        output = this.pkgname()
        break
      case ":constmap":
        output = this.constmap()
        break
      case ":funcmap":
        output = this.funcmap()
        break
      case ":typemap":
        output = this.typemap()
        break
      case ":emptymap":
        output = this.emptymap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":pkgname", this.pkgname())
      output.put(":constmap", this.constmap())
      output.put(":funcmap", this.funcmap())
      output.put(":typemap", this.typemap())
      output.put(":emptymap", this.emptymap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_package {
      var output : vx_core.Type_package = vx_core.vx_copy(vx_core.e_package, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_package = this
      var ischanged : Boolean = false
      var value : vx_core.Class_package = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_constmap : vx_core.Type_constmap = value.constmap()
      var vx_p_funcmap : vx_core.Type_funcmap = value.funcmap()
      var vx_p_typemap : vx_core.Type_typemap = value.typemap()
      var vx_p_emptymap : vx_core.Type_map = value.emptymap()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":pkgname":
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":constmap":
            if (valsub == vx_p_constmap) {
            } else if (valsub is vx_core.Type_constmap) {
              var valconstmap : vx_core.Type_constmap = valsub as vx_core.Type_constmap
              ischanged = true
              vx_p_constmap = valconstmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("constmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":funcmap":
            if (valsub == vx_p_funcmap) {
            } else if (valsub is vx_core.Type_funcmap) {
              var valfuncmap : vx_core.Type_funcmap = valsub as vx_core.Type_funcmap
              ischanged = true
              vx_p_funcmap = valfuncmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("funcmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":typemap":
            if (valsub == vx_p_typemap) {
            } else if (valsub is vx_core.Type_typemap) {
              var valtypemap : vx_core.Type_typemap = valsub as vx_core.Type_typemap
              ischanged = true
              vx_p_typemap = valtypemap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("typemap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":emptymap":
            if (valsub == vx_p_emptymap) {
            } else if (valsub is vx_core.Type_map) {
              var valemptymap : vx_core.Type_map = valsub as vx_core.Type_map
              ischanged = true
              vx_p_emptymap = valemptymap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("emptymap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_package = vx_core.Class_package()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_constmap = vx_p_constmap
        work.vx_p_funcmap = vx_p_funcmap
        work.vx_p_typemap = vx_p_typemap
        work.vx_p_emptymap = vx_p_emptymap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_package
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_package
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "package", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_package : vx_core.Type_package = vx_core.Class_package()
  val t_package : vx_core.Type_package = vx_core.Class_package()

  interface Type_packagemap : vx_core.Type_map {
    fun vx_mappackage() : Map<String, vx_core.Type_package>
    fun vx_package(key : vx_core.Type_string) : vx_core.Type_package
  }

  class Class_packagemap : vx_core.Class_base, Type_packagemap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_package> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_package>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_package) {
        var castval : vx_core.Type_package = value as vx_core.Type_package
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>(this.vx_p_map)
        if (castval == vx_core.e_package) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_package(key : vx_core.Type_string) : vx_core.Type_package {
      var output : vx_core.Type_package = vx_core.e_package
      var map : vx_core.Class_packagemap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_package> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mappackage() : Map<String, vx_core.Type_package> {
      var output : Map<String, vx_core.Type_package> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_package(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_packagemap = vx_core.Class_packagemap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_package) {
          var castval : vx_core.Type_package = value as vx_core.Type_package
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/packagemap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_packagemap {
      var output : vx_core.Type_packagemap = vx_core.vx_copy(vx_core.e_packagemap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_packagemap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_packagemap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>(value.vx_mappackage())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/packagemap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_package = null
          if (false) {
          } else if (valsub is vx_core.Type_package) {
            var valallowed : vx_core.Type_package = valsub as vx_core.Type_package
            valany = valallowed
          } else if (valsub is vx_core.Type_package) {
            valany = valsub as vx_core.Type_package
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/packagemap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_packagemap = vx_core.Class_packagemap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_packagemap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_packagemap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "packagemap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_package), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_packagemap : vx_core.Type_packagemap = vx_core.Class_packagemap()
  val t_packagemap : vx_core.Type_packagemap = vx_core.Class_packagemap()

  interface Type_permission : vx_core.Type_struct {
    fun id() : vx_core.Type_string
  }

  class Class_permission : vx_core.Class_base, Type_permission {
    constructor() {}

    var vx_p_id : vx_core.Type_string = null

    fun id() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_id != null) {
        output = this.vx_p_id
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":id":
        output = this.id()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":id", this.id())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_permission {
      var output : vx_core.Type_permission = vx_core.vx_copy(vx_core.e_permission, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permission = this
      var ischanged : Boolean = false
      var value : vx_core.Class_permission = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_id : vx_core.Type_string = value.id()
      List<String> validkeys = ArrayList<String>()
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":id":
            if (valsub == vx_p_id) {
            } else if (valsub is vx_core.Type_string) {
              var valid : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_id = valid
            } else if (valsub is String) {
              ischanged = true
              vx_p_id = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("id"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_permission = vx_core.Class_permission()
        work.vx_p_id = vx_p_id
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permission
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permission
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "permission", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_permission : vx_core.Type_permission = vx_core.Class_permission()
  val t_permission : vx_core.Type_permission = vx_core.Class_permission()

  interface Type_permissionlist : vx_core.Type_list {
    fun vx_listpermission() : List<vx_core.Type_permission>
    fun vx_permission(index : vx_core.Type_int) : vx_core.Type_permission
  }

  class Class_permissionlist : vx_core.Class_base, Type_permissionlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_permission> = vx_core.immutablelist(
      ArrayList<vx_core.Type_permission>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_permission(index : vx_core.Type_int) : vx_core.Type_permission {
      var output : vx_core.Type_permission = vx_core.e_permission
      var list : vx_core.Class_permissionlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_permission> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listpermission() : List<vx_core.Type_permission> {
      var output : List<vx_core.Type_permission> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_permission = this.vx_permission(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_permissionlist {
      var output : vx_core.Type_permissionlist = vx_core.vx_copy(vx_core.e_permissionlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permissionlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_permissionlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_permission> = ArrayList<vx_core.Type_permission>(value.vx_listpermission())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_permission) {
          var allowsub : vx_core.Type_permission = valsub as vx_core.Type_permission
          ischanged = true
          
        } else if (valsub is vx_core.Type_permission) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_permissionlist) {
          var multi : vx_core.Type_permissionlist = valsub as vx_core.Type_permissionlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_permissionlist = vx_core.Class_permissionlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permissionlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permissionlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "permissionlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_permission), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_permissionlist : vx_core.Type_permissionlist = vx_core.Class_permissionlist()
  val t_permissionlist : vx_core.Type_permissionlist = vx_core.Class_permissionlist()

  interface Type_permissionmap : vx_core.Type_map {
    fun vx_mappermission() : Map<String, vx_core.Type_permission>
    fun vx_permission(key : vx_core.Type_string) : vx_core.Type_permission
  }

  class Class_permissionmap : vx_core.Class_base, Type_permissionmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_permission> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_permission>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_permission) {
        var castval : vx_core.Type_permission = value as vx_core.Type_permission
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_permission> = LinkedHashMap<String, vx_core.Type_permission>(this.vx_p_map)
        if (castval == vx_core.e_permission) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_permission(key : vx_core.Type_string) : vx_core.Type_permission {
      var output : vx_core.Type_permission = vx_core.e_permission
      var map : vx_core.Class_permissionmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_permission> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mappermission() : Map<String, vx_core.Type_permission> {
      var output : Map<String, vx_core.Type_permission> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_permission(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_permissionmap = vx_core.Class_permissionmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_permission> = LinkedHashMap<String, vx_core.Type_permission>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_permission) {
          var castval : vx_core.Type_permission = value as vx_core.Type_permission
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/permissionmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_permissionmap {
      var output : vx_core.Type_permissionmap = vx_core.vx_copy(vx_core.e_permissionmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permissionmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_permissionmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_permission> = LinkedHashMap<String, vx_core.Type_permission>(value.vx_mappermission())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/permissionmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_permission = null
          if (false) {
          } else if (valsub is vx_core.Type_permission) {
            var valallowed : vx_core.Type_permission = valsub as vx_core.Type_permission
            valany = valallowed
          } else if (valsub is vx_core.Type_permission) {
            valany = valsub as vx_core.Type_permission
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/permissionmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_permissionmap = vx_core.Class_permissionmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permissionmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permissionmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "permissionmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_permission), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_permissionmap : vx_core.Type_permissionmap = vx_core.Class_permissionmap()
  val t_permissionmap : vx_core.Type_permissionmap = vx_core.Class_permissionmap()

  interface Type_project : vx_core.Type_struct {
    fun packagemap() : vx_core.Type_packagemap
  }

  class Class_project : vx_core.Class_base, Type_project {
    constructor() {}

    var vx_p_packagemap : vx_core.Type_packagemap = null

    fun packagemap() : vx_core.Type_packagemap {
      var output : vx_core.Type_packagemap = vx_core.e_packagemap
      if (this.vx_p_packagemap != null) {
        output = this.vx_p_packagemap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":packagemap":
        output = this.packagemap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":packagemap", this.packagemap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_project {
      var output : vx_core.Type_project = vx_core.vx_copy(vx_core.e_project, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_project = this
      var ischanged : Boolean = false
      var value : vx_core.Class_project = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_packagemap : vx_core.Type_packagemap = value.packagemap()
      List<String> validkeys = ArrayList<String>()
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":packagemap":
            if (valsub == vx_p_packagemap) {
            } else if (valsub is vx_core.Type_packagemap) {
              var valpackagemap : vx_core.Type_packagemap = valsub as vx_core.Type_packagemap
              ischanged = true
              vx_p_packagemap = valpackagemap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("packagemap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_project = vx_core.Class_project()
        work.vx_p_packagemap = vx_p_packagemap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_project
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_project
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "project", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_project : vx_core.Type_project = vx_core.Class_project()
  val t_project : vx_core.Type_project = vx_core.Class_project()

  interface Type_security : vx_core.Type_struct {
    fun allowfuncs() : vx_core.Type_funclist
    fun permissions() : vx_core.Type_permissionlist
    fun permissionmap() : vx_core.Type_permissionmap
  }

  class Class_security : vx_core.Class_base, Type_security {
    constructor() {}

    var vx_p_allowfuncs : vx_core.Type_funclist = null

    fun allowfuncs() : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.e_funclist
      if (this.vx_p_allowfuncs != null) {
        output = this.vx_p_allowfuncs
      }
      return output
    }

    var vx_p_permissions : vx_core.Type_permissionlist = null

    fun permissions() : vx_core.Type_permissionlist {
      var output : vx_core.Type_permissionlist = vx_core.e_permissionlist
      if (this.vx_p_permissions != null) {
        output = this.vx_p_permissions
      }
      return output
    }

    var vx_p_permissionmap : vx_core.Type_permissionmap = null

    fun permissionmap() : vx_core.Type_permissionmap {
      var output : vx_core.Type_permissionmap = vx_core.e_permissionmap
      if (this.vx_p_permissionmap != null) {
        output = this.vx_p_permissionmap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":allowfuncs":
        output = this.allowfuncs()
        break
      case ":permissions":
        output = this.permissions()
        break
      case ":permissionmap":
        output = this.permissionmap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":allowfuncs", this.allowfuncs())
      output.put(":permissions", this.permissions())
      output.put(":permissionmap", this.permissionmap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_security {
      var output : vx_core.Type_security = vx_core.vx_copy(vx_core.e_security, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_security = this
      var ischanged : Boolean = false
      var value : vx_core.Class_security = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_allowfuncs : vx_core.Type_funclist = value.allowfuncs()
      var vx_p_permissions : vx_core.Type_permissionlist = value.permissions()
      var vx_p_permissionmap : vx_core.Type_permissionmap = value.permissionmap()
      List<String> validkeys = ArrayList<String>()
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":allowfuncs":
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub is vx_core.Type_funclist) {
              var valallowfuncs : vx_core.Type_funclist = valsub as vx_core.Type_funclist
              ischanged = true
              vx_p_allowfuncs = valallowfuncs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowfuncs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":permissions":
            if (valsub == vx_p_permissions) {
            } else if (valsub is vx_core.Type_permissionlist) {
              var valpermissions : vx_core.Type_permissionlist = valsub as vx_core.Type_permissionlist
              ischanged = true
              vx_p_permissions = valpermissions
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("permissions"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":permissionmap":
            if (valsub == vx_p_permissionmap) {
            } else if (valsub is vx_core.Type_permissionmap) {
              var valpermissionmap : vx_core.Type_permissionmap = valsub as vx_core.Type_permissionmap
              ischanged = true
              vx_p_permissionmap = valpermissionmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("permissionmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_security = vx_core.Class_security()
        work.vx_p_allowfuncs = vx_p_allowfuncs
        work.vx_p_permissions = vx_p_permissions
        work.vx_p_permissionmap = vx_p_permissionmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_security
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_security
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "security", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_security : vx_core.Type_security = vx_core.Class_security()
  val t_security : vx_core.Type_security = vx_core.Class_security()

  interface Type_session : vx_core.Type_struct {
    fun user() : vx_core.Type_user
    fun connectlist() : vx_core.Type_connectlist
    fun connectmap() : vx_core.Type_connectmap
    fun locale() : vx_core.Type_locale
    fun translation() : vx_core.Type_translation
    fun translationmap() : vx_core.Type_translationmap
  }

  class Class_session : vx_core.Class_base, Type_session {
    constructor() {}

    var vx_p_user : vx_core.Type_user = null

    fun user() : vx_core.Type_user {
      var output : vx_core.Type_user = vx_core.e_user
      if (this.vx_p_user != null) {
        output = this.vx_p_user
      }
      return output
    }

    var vx_p_connectlist : vx_core.Type_connectlist = null

    fun connectlist() : vx_core.Type_connectlist {
      var output : vx_core.Type_connectlist = vx_core.e_connectlist
      if (this.vx_p_connectlist != null) {
        output = this.vx_p_connectlist
      }
      return output
    }

    var vx_p_connectmap : vx_core.Type_connectmap = null

    fun connectmap() : vx_core.Type_connectmap {
      var output : vx_core.Type_connectmap = vx_core.e_connectmap
      if (this.vx_p_connectmap != null) {
        output = this.vx_p_connectmap
      }
      return output
    }

    var vx_p_locale : vx_core.Type_locale = null

    fun locale() : vx_core.Type_locale {
      var output : vx_core.Type_locale = vx_core.e_locale
      if (this.vx_p_locale != null) {
        output = this.vx_p_locale
      }
      return output
    }

    var vx_p_translation : vx_core.Type_translation = null

    fun translation() : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.e_translation
      if (this.vx_p_translation != null) {
        output = this.vx_p_translation
      }
      return output
    }

    var vx_p_translationmap : vx_core.Type_translationmap = null

    fun translationmap() : vx_core.Type_translationmap {
      var output : vx_core.Type_translationmap = vx_core.e_translationmap
      if (this.vx_p_translationmap != null) {
        output = this.vx_p_translationmap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":user":
        output = this.user()
        break
      case ":connectlist":
        output = this.connectlist()
        break
      case ":connectmap":
        output = this.connectmap()
        break
      case ":locale":
        output = this.locale()
        break
      case ":translation":
        output = this.translation()
        break
      case ":translationmap":
        output = this.translationmap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":user", this.user())
      output.put(":connectlist", this.connectlist())
      output.put(":connectmap", this.connectmap())
      output.put(":locale", this.locale())
      output.put(":translation", this.translation())
      output.put(":translationmap", this.translationmap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_session {
      var output : vx_core.Type_session = vx_core.vx_copy(vx_core.e_session, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_session = this
      var ischanged : Boolean = false
      var value : vx_core.Class_session = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_user : vx_core.Type_user = value.user()
      var vx_p_connectlist : vx_core.Type_connectlist = value.connectlist()
      var vx_p_connectmap : vx_core.Type_connectmap = value.connectmap()
      var vx_p_locale : vx_core.Type_locale = value.locale()
      var vx_p_translation : vx_core.Type_translation = value.translation()
      var vx_p_translationmap : vx_core.Type_translationmap = value.translationmap()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":user":
            if (valsub == vx_p_user) {
            } else if (valsub is vx_core.Type_user) {
              var valuser : vx_core.Type_user = valsub as vx_core.Type_user
              ischanged = true
              vx_p_user = valuser
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("user"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":connectlist":
            if (valsub == vx_p_connectlist) {
            } else if (valsub is vx_core.Type_connectlist) {
              var valconnectlist : vx_core.Type_connectlist = valsub as vx_core.Type_connectlist
              ischanged = true
              vx_p_connectlist = valconnectlist
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("connectlist"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":connectmap":
            if (valsub == vx_p_connectmap) {
            } else if (valsub is vx_core.Type_connectmap) {
              var valconnectmap : vx_core.Type_connectmap = valsub as vx_core.Type_connectmap
              ischanged = true
              vx_p_connectmap = valconnectmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("connectmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":locale":
            if (valsub == vx_p_locale) {
            } else if (valsub is vx_core.Type_locale) {
              var vallocale : vx_core.Type_locale = valsub as vx_core.Type_locale
              ischanged = true
              vx_p_locale = vallocale
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("locale"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":translation":
            if (valsub == vx_p_translation) {
            } else if (valsub is vx_core.Type_translation) {
              var valtranslation : vx_core.Type_translation = valsub as vx_core.Type_translation
              ischanged = true
              vx_p_translation = valtranslation
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("translation"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":translationmap":
            if (valsub == vx_p_translationmap) {
            } else if (valsub is vx_core.Type_translationmap) {
              var valtranslationmap : vx_core.Type_translationmap = valsub as vx_core.Type_translationmap
              ischanged = true
              vx_p_translationmap = valtranslationmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("translationmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_session = vx_core.Class_session()
        work.vx_p_user = vx_p_user
        work.vx_p_connectlist = vx_p_connectlist
        work.vx_p_connectmap = vx_p_connectmap
        work.vx_p_locale = vx_p_locale
        work.vx_p_translation = vx_p_translation
        work.vx_p_translationmap = vx_p_translationmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_session
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_session
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "session", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_session : vx_core.Type_session = vx_core.Class_session()
  val t_session : vx_core.Type_session = vx_core.Class_session()

  interface Type_setting : vx_core.Type_struct {
    fun pathmap() : vx_core.Type_stringmap
  }

  class Class_setting : vx_core.Class_base, Type_setting {
    constructor() {}

    var vx_p_pathmap : vx_core.Type_stringmap = null

    fun pathmap() : vx_core.Type_stringmap {
      var output : vx_core.Type_stringmap = vx_core.e_stringmap
      if (this.vx_p_pathmap != null) {
        output = this.vx_p_pathmap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":pathmap":
        output = this.pathmap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":pathmap", this.pathmap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_setting {
      var output : vx_core.Type_setting = vx_core.vx_copy(vx_core.e_setting, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_setting = this
      var ischanged : Boolean = false
      var value : vx_core.Class_setting = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pathmap : vx_core.Type_stringmap = value.pathmap()
      List<String> validkeys = ArrayList<String>()
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":pathmap":
            if (valsub == vx_p_pathmap) {
            } else if (valsub is vx_core.Type_stringmap) {
              var valpathmap : vx_core.Type_stringmap = valsub as vx_core.Type_stringmap
              ischanged = true
              vx_p_pathmap = valpathmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pathmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_setting = vx_core.Class_setting()
        work.vx_p_pathmap = vx_p_pathmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_setting
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_setting
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "setting", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_setting : vx_core.Type_setting = vx_core.Class_setting()
  val t_setting : vx_core.Type_setting = vx_core.Class_setting()

  interface Type_state : vx_core.Type_struct {
    fun statelistenermap() : vx_core.Type_statelistenermap
  }

  class Class_state : vx_core.Class_base, Type_state {
    constructor() {}

    var vx_p_statelistenermap : vx_core.Type_statelistenermap = null

    fun statelistenermap() : vx_core.Type_statelistenermap {
      var output : vx_core.Type_statelistenermap = vx_core.e_statelistenermap
      if (this.vx_p_statelistenermap != null) {
        output = this.vx_p_statelistenermap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":statelistenermap":
        output = this.statelistenermap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":statelistenermap", this.statelistenermap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_state {
      var output : vx_core.Type_state = vx_core.vx_copy(vx_core.e_state, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_state = this
      var ischanged : Boolean = false
      var value : vx_core.Class_state = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_statelistenermap : vx_core.Type_statelistenermap = value.statelistenermap()
      List<String> validkeys = ArrayList<String>()
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":statelistenermap":
            if (valsub == vx_p_statelistenermap) {
            } else if (valsub is vx_core.Type_statelistenermap) {
              var valstatelistenermap : vx_core.Type_statelistenermap = valsub as vx_core.Type_statelistenermap
              ischanged = true
              vx_p_statelistenermap = valstatelistenermap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("statelistenermap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_state = vx_core.Class_state()
        work.vx_p_statelistenermap = vx_p_statelistenermap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_state
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_state
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "state", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_state : vx_core.Type_state = vx_core.Class_state()
  val t_state : vx_core.Type_state = vx_core.Class_state()

  interface Type_statelistener : vx_core.Type_struct {
    fun name() : vx_core.Type_string
    fun value() : vx_core.Type_any
    fun fn_boolean() : vx_core.Func_boolean_from_none
  }

  class Class_statelistener : vx_core.Class_base, Type_statelistener {
    constructor() {}

    var vx_p_name : vx_core.Type_string = null

    fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_name != null) {
        output = this.vx_p_name
      }
      return output
    }

    var vx_p_value : vx_core.Type_any = null

    fun value() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_value != null) {
        output = this.vx_p_value
      }
      return output
    }

    var vx_p_fn_boolean : vx_core.Func_boolean_from_none = null

    fun fn_boolean() : vx_core.Func_boolean_from_none {
      var output : vx_core.Func_boolean_from_none = vx_core.e_boolean_from_none
      if (this.vx_p_fn_boolean != null) {
        output = this.vx_p_fn_boolean
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":name":
        output = this.name()
        break
      case ":value":
        output = this.value()
        break
      case ":fn-boolean":
        output = this.fn_boolean()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":name", this.name())
      output.put(":value", this.value())
      output.put(":fn-boolean", this.fn_boolean())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_statelistener {
      var output : vx_core.Type_statelistener = vx_core.vx_copy(vx_core.e_statelistener, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_statelistener = this
      var ischanged : Boolean = false
      var value : vx_core.Class_statelistener = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_value : vx_core.Type_any = value.value()
      var vx_p_fn_boolean : vx_core.Func_boolean_from_none = value.fn_boolean()
      List<String> validkeys = ArrayList<String>()
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":name":
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":value":
            if (valsub == vx_p_value) {
            } else if (valsub is vx_core.Type_any) {
              var valvalue : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_value = valvalue
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("value"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":fn-boolean":
            if (valsub == vx_p_fn_boolean) {
            } else if (valsub is vx_core.Func_boolean_from_none) {
              var valfn_boolean : vx_core.Func_boolean_from_none = valsub as vx_core.Func_boolean_from_none
              ischanged = true
              vx_p_fn_boolean = valfn_boolean
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-boolean"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_statelistener = vx_core.Class_statelistener()
        work.vx_p_name = vx_p_name
        work.vx_p_value = vx_p_value
        work.vx_p_fn_boolean = vx_p_fn_boolean
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_statelistener
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_statelistener
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "statelistener", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_statelistener : vx_core.Type_statelistener = vx_core.Class_statelistener()
  val t_statelistener : vx_core.Type_statelistener = vx_core.Class_statelistener()

  interface Type_statelistenermap : vx_core.Type_map {
    fun vx_mapstatelistener() : Map<String, vx_core.Type_statelistener>
    fun vx_statelistener(key : vx_core.Type_string) : vx_core.Type_statelistener
  }

  class Class_statelistenermap : vx_core.Class_base, Type_statelistenermap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_statelistener> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_statelistener>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_statelistener) {
        var castval : vx_core.Type_statelistener = value as vx_core.Type_statelistener
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_statelistener> = LinkedHashMap<String, vx_core.Type_statelistener>(this.vx_p_map)
        if (castval == vx_core.e_statelistener) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_statelistener(key : vx_core.Type_string) : vx_core.Type_statelistener {
      var output : vx_core.Type_statelistener = vx_core.e_statelistener
      var map : vx_core.Class_statelistenermap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_statelistener> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapstatelistener() : Map<String, vx_core.Type_statelistener> {
      var output : Map<String, vx_core.Type_statelistener> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_statelistener(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_statelistenermap = vx_core.Class_statelistenermap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_statelistener> = LinkedHashMap<String, vx_core.Type_statelistener>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_statelistener) {
          var castval : vx_core.Type_statelistener = value as vx_core.Type_statelistener
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/statelistenermap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_statelistenermap {
      var output : vx_core.Type_statelistenermap = vx_core.vx_copy(vx_core.e_statelistenermap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_statelistenermap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_statelistenermap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_statelistener> = LinkedHashMap<String, vx_core.Type_statelistener>(value.vx_mapstatelistener())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/statelistenermap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_statelistener = null
          if (false) {
          } else if (valsub is vx_core.Type_statelistener) {
            var valallowed : vx_core.Type_statelistener = valsub as vx_core.Type_statelistener
            valany = valallowed
          } else if (valsub is vx_core.Type_statelistener) {
            valany = valsub as vx_core.Type_statelistener
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/statelistenermap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_statelistenermap = vx_core.Class_statelistenermap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_statelistenermap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_statelistenermap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "statelistenermap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_statelistener), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_statelistenermap : vx_core.Type_statelistenermap = vx_core.Class_statelistenermap()
  val t_statelistenermap : vx_core.Type_statelistenermap = vx_core.Class_statelistenermap()

  interface Type_string : vx_core.Type_any {
    fun vx_string() : String
  }

  class Class_string : vx_core.Class_base, Type_string {
    constructor() {}

    internal var vxstring : String = ""
    
    // :implements
    override fun vx_string() : String {
      return vxstring
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.vx_copy(vx_core.e_string, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_string = this
      var ischanged : Boolean = false
      var value : vx_core.Class_string = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var sb : kotlin.text.StringBuilder = StringBuilder(value.vx_string())
      vx_core.Type_msg msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_string) {
          var valstring : vx_core.Type_string = valsub as vx_core.Type_string
          var ssub : String = valstring.vx_string()
          if (ssub.equals("")) {
          } else {
            ischanged = true
            sb.append(ssub)
          }
        } else if (valsub is vx_core.Type_int) {
          var valint : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          sb.append(valint.vx_int())
        } else if (valsub is vx_core.Type_float) {
          var valfloat : vx_core.Type_float = valsub as vx_core.Type_float
          ischanged = true
          sb.append(valfloat.vx_float())
        } else if (valsub is vx_core.Type_decimal) {
          var valdecimal : vx_core.Type_decimal = valsub as vx_core.Type_decimal
          ischanged = true
          sb.append(valdecimal.vx_string())
        } else if (valsub is String) {
          var sval : String = valsub as String
          if (sval.equals("")) {
          } else {
            ischanged = true
            sb.append(sval)
          }
        } else if (valsub is Integer) {
          var ival : Integer = valsub as Integer
          ischanged = true
          sb.append(ival)
        } else if (valsub is Float) {
          var fval : Float = valsub as Float
          ischanged = true
          sb.append(fval)
        } else if (valsub is vx_core.Type_any) {
          var anysub : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/string", ":invalidtype", anysub)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/string", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var vxstring : String = sb.toString()
        var work : vx_core.Class_string = vx_core.Class_string()
        work.vxstring = vxstring
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "string", // name
        ":string", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_string : vx_core.Type_string = vx_core.Class_string()
  val t_string : vx_core.Type_string = vx_core.Class_string()

  interface Type_stringlist : vx_core.Type_list {
    fun vx_liststring() : List<vx_core.Type_string>
    fun vx_string(index : vx_core.Type_int) : vx_core.Type_string
  }

  class Class_stringlist : vx_core.Class_base, Type_stringlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_string> = vx_core.immutablelist(
      ArrayList<vx_core.Type_string>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_string(index : vx_core.Type_int) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var list : vx_core.Class_stringlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_string> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_liststring() : List<vx_core.Type_string> {
      var output : List<vx_core.Type_string> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_string = this.vx_string(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_stringlist {
      var output : vx_core.Type_stringlist = vx_core.vx_copy(vx_core.e_stringlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_string> = ArrayList<vx_core.Type_string>(value.vx_liststring())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_string) {
          var allowsub : vx_core.Type_string = valsub as vx_core.Type_string
          ischanged = true
          
        } else if (valsub is String) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_stringlist) {
          var multi : vx_core.Type_stringlist = valsub as vx_core.Type_stringlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringlist = vx_core.Class_stringlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringlist : vx_core.Type_stringlist = vx_core.Class_stringlist()
  val t_stringlist : vx_core.Type_stringlist = vx_core.Class_stringlist()

  interface Type_stringlistlist : vx_core.Type_list {
    fun vx_liststringlist() : List<vx_core.Type_stringlist>
    fun vx_stringlist(index : vx_core.Type_int) : vx_core.Type_stringlist
  }

  class Class_stringlistlist : vx_core.Class_base, Type_stringlistlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_stringlist> = vx_core.immutablelist(
      ArrayList<vx_core.Type_stringlist>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_stringlist(index : vx_core.Type_int) : vx_core.Type_stringlist {
      var output : vx_core.Type_stringlist = vx_core.e_stringlist
      var list : vx_core.Class_stringlistlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_stringlist> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_liststringlist() : List<vx_core.Type_stringlist> {
      var output : List<vx_core.Type_stringlist> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_stringlist = this.vx_stringlist(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_stringlistlist {
      var output : vx_core.Type_stringlistlist = vx_core.vx_copy(vx_core.e_stringlistlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringlistlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringlistlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_stringlist> = ArrayList<vx_core.Type_stringlist>(value.vx_liststringlist())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_stringlist) {
          var allowsub : vx_core.Type_stringlist = valsub as vx_core.Type_stringlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_stringlist) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_stringlistlist) {
          var multi : vx_core.Type_stringlistlist = valsub as vx_core.Type_stringlistlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringlistlist = vx_core.Class_stringlistlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringlistlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringlistlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringlistlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_stringlist), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringlistlist : vx_core.Type_stringlistlist = vx_core.Class_stringlistlist()
  val t_stringlistlist : vx_core.Type_stringlistlist = vx_core.Class_stringlistlist()

  interface Type_stringmap : vx_core.Type_map {
    fun vx_mapstring() : Map<String, vx_core.Type_string>
    fun vx_string(key : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_stringmap : vx_core.Class_base, Type_stringmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_string> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_string>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_string) {
        var castval : vx_core.Type_string = value as vx_core.Type_string
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(this.vx_p_map)
        if (castval == vx_core.e_string) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_string(key : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var map : vx_core.Class_stringmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_string> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapstring() : Map<String, vx_core.Type_string> {
      var output : Map<String, vx_core.Type_string> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_string(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_stringmap = vx_core.Class_stringmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_string) {
          var castval : vx_core.Type_string = value as vx_core.Type_string
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/stringmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_stringmap {
      var output : vx_core.Type_stringmap = vx_core.vx_copy(vx_core.e_stringmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(value.vx_mapstring())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/stringmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_string = null
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valallowed : vx_core.Type_string = valsub as vx_core.Type_string
            valany = valallowed
          } else if (valsub is String) {
            valany = vx_core.vx_new(vx_core.t_string, valsub)
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/stringmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringmap = vx_core.Class_stringmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringmap : vx_core.Type_stringmap = vx_core.Class_stringmap()
  val t_stringmap : vx_core.Type_stringmap = vx_core.Class_stringmap()

  interface Type_stringmutablemap : vx_core.Type_map {
    fun vx_mapstring() : Map<String, vx_core.Type_string>
    fun vx_string(key : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_stringmutablemap : vx_core.Class_base, Type_stringmutablemap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_string> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_string>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_string) {
        var castval : vx_core.Type_string = value as vx_core.Type_string
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(this.vx_p_map)
        if (castval == vx_core.e_string) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_string(key : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var map : vx_core.Class_stringmutablemap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_string> = map.vx_p_map
      output = 
      return output
    }

    fun vx_mapstring() : Map<String, vx_core.Type_string> {
      var output : Map<String, vx_core.Type_string> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_string(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_stringmutablemap = vx_core.Class_stringmutablemap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_string) {
          var castval : vx_core.Type_string = value as vx_core.Type_string
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_stringmutablemap {
      var output : vx_core.Type_stringmutablemap = vx_core.vx_copy(vx_core.e_stringmutablemap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringmutablemap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringmutablemap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(value.vx_mapstring())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/stringmutablemap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_string = null
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valallowed : vx_core.Type_string = valsub as vx_core.Type_string
            valany = valallowed
          } else if (valsub is String) {
            valany = vx_core.vx_new(vx_core.t_string, valsub)
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringmutablemap = vx_core.Class_stringmutablemap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringmutablemap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringmutablemap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringmutablemap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringmutablemap : vx_core.Type_stringmutablemap = vx_core.Class_stringmutablemap()
  val t_stringmutablemap : vx_core.Type_stringmutablemap = vx_core.Class_stringmutablemap()

  interface Type_struct : vx_core.Type_any {
    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any
    fun vx_map() : Map<String, vx_core.Type_any>
  }

  class Class_struct : vx_core.Class_base, Type_struct {
    constructor() {}

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_struct {
      var output : vx_core.Type_struct = vx_core.vx_copy(vx_core.e_struct, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_struct = this
      var ischanged : Boolean = false
      var value : vx_core.Class_struct = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_struct = vx_core.Class_struct()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_struct
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_struct
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "struct", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_struct : vx_core.Type_struct = vx_core.Class_struct()
  val t_struct : vx_core.Type_struct = vx_core.Class_struct()

  interface Type_thenelse : vx_core.Type_struct {
    fun code() : vx_core.Type_string
    fun value() : vx_core.Type_any
    fun values() : vx_core.Type_list
    fun fn_cond() : vx_core.Func_boolean_from_func
    fun fn_any() : vx_core.Func_any_from_func
  }

  class Class_thenelse : vx_core.Class_base, Type_thenelse {
    constructor() {}

    var vx_p_code : vx_core.Type_string = null

    fun code() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_code != null) {
        output = this.vx_p_code
      }
      return output
    }

    var vx_p_value : vx_core.Type_any = null

    fun value() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_value != null) {
        output = this.vx_p_value
      }
      return output
    }

    var vx_p_values : vx_core.Type_list = null

    fun values() : vx_core.Type_list {
      var output : vx_core.Type_list = vx_core.e_list
      if (this.vx_p_values != null) {
        output = this.vx_p_values
      }
      return output
    }

    var vx_p_fn_cond : vx_core.Func_boolean_from_func = null

    fun fn_cond() : vx_core.Func_boolean_from_func {
      var output : vx_core.Func_boolean_from_func = vx_core.e_boolean_from_func
      if (this.vx_p_fn_cond != null) {
        output = this.vx_p_fn_cond
      }
      return output
    }

    var vx_p_fn_any : vx_core.Func_any_from_func = null

    fun fn_any() : vx_core.Func_any_from_func {
      var output : vx_core.Func_any_from_func = vx_core.e_any_from_func
      if (this.vx_p_fn_any != null) {
        output = this.vx_p_fn_any
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":code":
        output = this.code()
        break
      case ":value":
        output = this.value()
        break
      case ":values":
        output = this.values()
        break
      case ":fn-cond":
        output = this.fn_cond()
        break
      case ":fn-any":
        output = this.fn_any()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":code", this.code())
      output.put(":value", this.value())
      output.put(":values", this.values())
      output.put(":fn-cond", this.fn_cond())
      output.put(":fn-any", this.fn_any())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.vx_copy(vx_core.e_thenelse, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_thenelse = this
      var ischanged : Boolean = false
      var value : vx_core.Class_thenelse = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_code : vx_core.Type_string = value.code()
      var vx_p_value : vx_core.Type_any = value.value()
      var vx_p_values : vx_core.Type_list = value.values()
      var vx_p_fn_cond : vx_core.Func_boolean_from_func = value.fn_cond()
      var vx_p_fn_any : vx_core.Func_any_from_func = value.fn_any()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":code":
            if (valsub == vx_p_code) {
            } else if (valsub is vx_core.Type_string) {
              var valcode : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_code = valcode
            } else if (valsub is String) {
              ischanged = true
              vx_p_code = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("code"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":value":
            if (valsub == vx_p_value) {
            } else if (valsub is vx_core.Type_any) {
              var valvalue : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_value = valvalue
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("value"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":values":
            if (valsub == vx_p_values) {
            } else if (valsub is vx_core.Type_list) {
              var valvalues : vx_core.Type_list = valsub as vx_core.Type_list
              ischanged = true
              vx_p_values = valvalues
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("values"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":fn-cond":
            if (valsub == vx_p_fn_cond) {
            } else if (valsub is vx_core.Func_boolean_from_func) {
              var valfn_cond : vx_core.Func_boolean_from_func = valsub as vx_core.Func_boolean_from_func
              ischanged = true
              vx_p_fn_cond = valfn_cond
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-cond"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":fn-any":
            if (valsub == vx_p_fn_any) {
            } else if (valsub is vx_core.Func_any_from_func) {
              var valfn_any : vx_core.Func_any_from_func = valsub as vx_core.Func_any_from_func
              ischanged = true
              vx_p_fn_any = valfn_any
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-any"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_thenelse = vx_core.Class_thenelse()
        work.vx_p_code = vx_p_code
        work.vx_p_value = vx_p_value
        work.vx_p_values = vx_p_values
        work.vx_p_fn_cond = vx_p_fn_cond
        work.vx_p_fn_any = vx_p_fn_any
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_thenelse
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_thenelse
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "thenelse", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_thenelse : vx_core.Type_thenelse = vx_core.Class_thenelse()
  val t_thenelse : vx_core.Type_thenelse = vx_core.Class_thenelse()

  interface Type_thenelselist : vx_core.Type_list {
    fun vx_listthenelse() : List<vx_core.Type_thenelse>
    fun vx_thenelse(index : vx_core.Type_int) : vx_core.Type_thenelse
  }

  class Class_thenelselist : vx_core.Class_base, Type_thenelselist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_thenelse> = vx_core.immutablelist(
      ArrayList<vx_core.Type_thenelse>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_thenelse(index : vx_core.Type_int) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.e_thenelse
      var list : vx_core.Class_thenelselist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_thenelse> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listthenelse() : List<vx_core.Type_thenelse> {
      var output : List<vx_core.Type_thenelse> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_thenelse = this.vx_thenelse(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_thenelselist {
      var output : vx_core.Type_thenelselist = vx_core.vx_copy(vx_core.e_thenelselist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_thenelselist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_thenelselist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_thenelse> = ArrayList<vx_core.Type_thenelse>(value.vx_listthenelse())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_thenelse) {
          var allowsub : vx_core.Type_thenelse = valsub as vx_core.Type_thenelse
          ischanged = true
          
        } else if (valsub is vx_core.Type_thenelse) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_thenelselist) {
          var multi : vx_core.Type_thenelselist = valsub as vx_core.Type_thenelselist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_thenelselist = vx_core.Class_thenelselist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_thenelselist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_thenelselist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "thenelselist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_thenelse), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_thenelselist : vx_core.Type_thenelselist = vx_core.Class_thenelselist()
  val t_thenelselist : vx_core.Type_thenelselist = vx_core.Class_thenelselist()

  interface Type_translation : vx_core.Type_struct {
    fun name() : vx_core.Type_string
    fun wordmap() : vx_core.Type_stringmap
  }

  class Class_translation : vx_core.Class_base, Type_translation {
    constructor() {}

    var vx_p_name : vx_core.Type_string = null

    fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_name != null) {
        output = this.vx_p_name
      }
      return output
    }

    var vx_p_wordmap : vx_core.Type_stringmap = null

    fun wordmap() : vx_core.Type_stringmap {
      var output : vx_core.Type_stringmap = vx_core.e_stringmap
      if (this.vx_p_wordmap != null) {
        output = this.vx_p_wordmap
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":name":
        output = this.name()
        break
      case ":wordmap":
        output = this.wordmap()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":name", this.name())
      output.put(":wordmap", this.wordmap())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.vx_copy(vx_core.e_translation, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translation = this
      var ischanged : Boolean = false
      var value : vx_core.Class_translation = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_wordmap : vx_core.Type_stringmap = value.wordmap()
      List<String> validkeys = ArrayList<String>()
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":name":
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":wordmap":
            if (valsub == vx_p_wordmap) {
            } else if (valsub is vx_core.Type_stringmap) {
              var valwordmap : vx_core.Type_stringmap = valsub as vx_core.Type_stringmap
              ischanged = true
              vx_p_wordmap = valwordmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("wordmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_translation = vx_core.Class_translation()
        work.vx_p_name = vx_p_name
        work.vx_p_wordmap = vx_p_wordmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_translation
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_translation
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "translation", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_translation : vx_core.Type_translation = vx_core.Class_translation()
  val t_translation : vx_core.Type_translation = vx_core.Class_translation()

  interface Type_translationlist : vx_core.Type_list {
    fun vx_listtranslation() : List<vx_core.Type_translation>
    fun vx_translation(index : vx_core.Type_int) : vx_core.Type_translation
  }

  class Class_translationlist : vx_core.Class_base, Type_translationlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_translation> = vx_core.immutablelist(
      ArrayList<vx_core.Type_translation>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_translation(index : vx_core.Type_int) : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.e_translation
      var list : vx_core.Class_translationlist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_translation> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    fun vx_listtranslation() : List<vx_core.Type_translation> {
      var output : List<vx_core.Type_translation> = this.vx_p_list
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_translation = this.vx_translation(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_translationlist {
      var output : vx_core.Type_translationlist = vx_core.vx_copy(vx_core.e_translationlist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translationlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_translationlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_translation> = ArrayList<vx_core.Type_translation>(value.vx_listtranslation())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_translation) {
          var allowsub : vx_core.Type_translation = valsub as vx_core.Type_translation
          ischanged = true
          
        } else if (valsub is vx_core.Type_translation) {
          ischanged = true
          
        } else if (valsub is vx_core.Type_translationlist) {
          var multi : vx_core.Type_translationlist = valsub as vx_core.Type_translationlist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_translationlist = vx_core.Class_translationlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_translationlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_translationlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "translationlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_translation), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_translationlist : vx_core.Type_translationlist = vx_core.Class_translationlist()
  val t_translationlist : vx_core.Type_translationlist = vx_core.Class_translationlist()

  interface Type_translationmap : vx_core.Type_map {
    fun vx_maptranslation() : Map<String, vx_core.Type_translation>
    fun vx_translation(key : vx_core.Type_string) : vx_core.Type_translation
  }

  class Class_translationmap : vx_core.Class_base, Type_translationmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_translation> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_translation>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_translation) {
        var castval : vx_core.Type_translation = value as vx_core.Type_translation
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_translation> = LinkedHashMap<String, vx_core.Type_translation>(this.vx_p_map)
        if (castval == vx_core.e_translation) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_translation(key : vx_core.Type_string) : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.e_translation
      var map : vx_core.Class_translationmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_translation> = map.vx_p_map
      output = 
      return output
    }

    fun vx_maptranslation() : Map<String, vx_core.Type_translation> {
      var output : Map<String, vx_core.Type_translation> = this.vx_p_map
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_translation(key)
      return output
    }


    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_translationmap = vx_core.Class_translationmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_translation> = LinkedHashMap<String, vx_core.Type_translation>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_translation) {
          var castval : vx_core.Type_translation = value as vx_core.Type_translation
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/translationmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_translationmap {
      var output : vx_core.Type_translationmap = vx_core.vx_copy(vx_core.e_translationmap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translationmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_translationmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_translation> = LinkedHashMap<String, vx_core.Type_translation>(value.vx_maptranslation())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/translationmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_translation = null
          if (false) {
          } else if (valsub is vx_core.Type_translation) {
            var valallowed : vx_core.Type_translation = valsub as vx_core.Type_translation
            valany = valallowed
          } else if (valsub is vx_core.Type_translation) {
            valany = valsub as vx_core.Type_translation
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/translationmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_translationmap = vx_core.Class_translationmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_translationmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_translationmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "translationmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_translation), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_translationmap : vx_core.Type_translationmap = vx_core.Class_translationmap()
  val t_translationmap : vx_core.Type_translationmap = vx_core.Class_translationmap()

  interface Type_type : vx_core.Type_any {
  }

  class Class_type : vx_core.Class_base, Type_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_type {
      var output : vx_core.Type_type = vx_core.vx_copy(vx_core.e_type, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_type = this
      var ischanged : Boolean = false
      var value : vx_core.Class_type = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_type = vx_core.Class_type()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_type
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "type", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_type : vx_core.Type_type = vx_core.Class_type()
  val t_type : vx_core.Type_type = vx_core.Class_type()

  interface Type_typedef : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun name() : vx_core.Type_string
    fun extend() : vx_core.Type_string
    fun allowfuncs() : vx_core.Type_funclist
    fun allowtypes() : vx_core.Type_typelist
    fun allowvalues() : vx_core.Type_anylist
    fun disallowfuncs() : vx_core.Type_funclist
    fun disallowtypes() : vx_core.Type_typelist
    fun disallowvalues() : vx_core.Type_anylist
    fun properties() : vx_core.Type_argmap
    fun proplast() : vx_core.Type_arg
    fun traits() : vx_core.Type_typelist
  }

  class Class_typedef : vx_core.Class_base, Type_typedef {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string = null

    fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_pkgname != null) {
        output = this.vx_p_pkgname
      }
      return output
    }

    var vx_p_name : vx_core.Type_string = null

    fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_name != null) {
        output = this.vx_p_name
      }
      return output
    }

    var vx_p_extend : vx_core.Type_string = null

    fun extend() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_extend != null) {
        output = this.vx_p_extend
      }
      return output
    }

    var vx_p_allowfuncs : vx_core.Type_funclist = null

    fun allowfuncs() : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.e_funclist
      if (this.vx_p_allowfuncs != null) {
        output = this.vx_p_allowfuncs
      }
      return output
    }

    var vx_p_allowtypes : vx_core.Type_typelist = null

    fun allowtypes() : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.e_typelist
      if (this.vx_p_allowtypes != null) {
        output = this.vx_p_allowtypes
      }
      return output
    }

    var vx_p_allowvalues : vx_core.Type_anylist = null

    fun allowvalues() : vx_core.Type_anylist {
      var output : vx_core.Type_anylist = vx_core.e_anylist
      if (this.vx_p_allowvalues != null) {
        output = this.vx_p_allowvalues
      }
      return output
    }

    var vx_p_disallowfuncs : vx_core.Type_funclist = null

    fun disallowfuncs() : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.e_funclist
      if (this.vx_p_disallowfuncs != null) {
        output = this.vx_p_disallowfuncs
      }
      return output
    }

    var vx_p_disallowtypes : vx_core.Type_typelist = null

    fun disallowtypes() : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.e_typelist
      if (this.vx_p_disallowtypes != null) {
        output = this.vx_p_disallowtypes
      }
      return output
    }

    var vx_p_disallowvalues : vx_core.Type_anylist = null

    fun disallowvalues() : vx_core.Type_anylist {
      var output : vx_core.Type_anylist = vx_core.e_anylist
      if (this.vx_p_disallowvalues != null) {
        output = this.vx_p_disallowvalues
      }
      return output
    }

    var vx_p_properties : vx_core.Type_argmap = null

    fun properties() : vx_core.Type_argmap {
      var output : vx_core.Type_argmap = vx_core.e_argmap
      if (this.vx_p_properties != null) {
        output = this.vx_p_properties
      }
      return output
    }

    var vx_p_proplast : vx_core.Type_arg = null

    fun proplast() : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.e_arg
      if (this.vx_p_proplast != null) {
        output = this.vx_p_proplast
      }
      return output
    }

    var vx_p_traits : vx_core.Type_typelist = null

    fun traits() : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.e_typelist
      if (this.vx_p_traits != null) {
        output = this.vx_p_traits
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":pkgname":
        output = this.pkgname()
        break
      case ":name":
        output = this.name()
        break
      case ":extends":
        output = this.extend()
        break
      case ":allowfuncs":
        output = this.allowfuncs()
        break
      case ":allowtypes":
        output = this.allowtypes()
        break
      case ":allowvalues":
        output = this.allowvalues()
        break
      case ":disallowfuncs":
        output = this.disallowfuncs()
        break
      case ":disallowtypes":
        output = this.disallowtypes()
        break
      case ":disallowvalues":
        output = this.disallowvalues()
        break
      case ":properties":
        output = this.properties()
        break
      case ":proplast":
        output = this.proplast()
        break
      case ":traits":
        output = this.traits()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":pkgname", this.pkgname())
      output.put(":name", this.name())
      output.put(":extends", this.extend())
      output.put(":allowfuncs", this.allowfuncs())
      output.put(":allowtypes", this.allowtypes())
      output.put(":allowvalues", this.allowvalues())
      output.put(":disallowfuncs", this.disallowfuncs())
      output.put(":disallowtypes", this.disallowtypes())
      output.put(":disallowvalues", this.disallowvalues())
      output.put(":properties", this.properties())
      output.put(":proplast", this.proplast())
      output.put(":traits", this.traits())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.vx_copy(vx_core.e_typedef, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typedef = this
      var ischanged : Boolean = false
      var value : vx_core.Class_typedef = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_extend : vx_core.Type_string = value.extend()
      var vx_p_allowfuncs : vx_core.Type_funclist = value.allowfuncs()
      var vx_p_allowtypes : vx_core.Type_typelist = value.allowtypes()
      var vx_p_allowvalues : vx_core.Type_anylist = value.allowvalues()
      var vx_p_disallowfuncs : vx_core.Type_funclist = value.disallowfuncs()
      var vx_p_disallowtypes : vx_core.Type_typelist = value.disallowtypes()
      var vx_p_disallowvalues : vx_core.Type_anylist = value.disallowvalues()
      var vx_p_properties : vx_core.Type_argmap = value.properties()
      var vx_p_proplast : vx_core.Type_arg = value.proplast()
      var vx_p_traits : vx_core.Type_typelist = value.traits()
      List<String> validkeys = ArrayList<String>()
      
      
      
      
      
      
      
      
      
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":pkgname":
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":name":
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":extends":
            if (valsub == vx_p_extend) {
            } else if (valsub is vx_core.Type_string) {
              var valextend : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_extend = valextend
            } else if (valsub is String) {
              ischanged = true
              vx_p_extend = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("extends"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":allowfuncs":
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub is vx_core.Type_funclist) {
              var valallowfuncs : vx_core.Type_funclist = valsub as vx_core.Type_funclist
              ischanged = true
              vx_p_allowfuncs = valallowfuncs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowfuncs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":allowtypes":
            if (valsub == vx_p_allowtypes) {
            } else if (valsub is vx_core.Type_typelist) {
              var valallowtypes : vx_core.Type_typelist = valsub as vx_core.Type_typelist
              ischanged = true
              vx_p_allowtypes = valallowtypes
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowtypes"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":allowvalues":
            if (valsub == vx_p_allowvalues) {
            } else if (valsub is vx_core.Type_anylist) {
              var valallowvalues : vx_core.Type_anylist = valsub as vx_core.Type_anylist
              ischanged = true
              vx_p_allowvalues = valallowvalues
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowvalues"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":disallowfuncs":
            if (valsub == vx_p_disallowfuncs) {
            } else if (valsub is vx_core.Type_funclist) {
              var valdisallowfuncs : vx_core.Type_funclist = valsub as vx_core.Type_funclist
              ischanged = true
              vx_p_disallowfuncs = valdisallowfuncs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("disallowfuncs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":disallowtypes":
            if (valsub == vx_p_disallowtypes) {
            } else if (valsub is vx_core.Type_typelist) {
              var valdisallowtypes : vx_core.Type_typelist = valsub as vx_core.Type_typelist
              ischanged = true
              vx_p_disallowtypes = valdisallowtypes
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("disallowtypes"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":disallowvalues":
            if (valsub == vx_p_disallowvalues) {
            } else if (valsub is vx_core.Type_anylist) {
              var valdisallowvalues : vx_core.Type_anylist = valsub as vx_core.Type_anylist
              ischanged = true
              vx_p_disallowvalues = valdisallowvalues
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("disallowvalues"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":properties":
            if (valsub == vx_p_properties) {
            } else if (valsub is vx_core.Type_argmap) {
              var valproperties : vx_core.Type_argmap = valsub as vx_core.Type_argmap
              ischanged = true
              vx_p_properties = valproperties
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("properties"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":proplast":
            if (valsub == vx_p_proplast) {
            } else if (valsub is vx_core.Type_arg) {
              var valproplast : vx_core.Type_arg = valsub as vx_core.Type_arg
              ischanged = true
              vx_p_proplast = valproplast
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("proplast"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":traits":
            if (valsub == vx_p_traits) {
            } else if (valsub is vx_core.Type_typelist) {
              var valtraits : vx_core.Type_typelist = valsub as vx_core.Type_typelist
              ischanged = true
              vx_p_traits = valtraits
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("traits"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_typedef = vx_core.Class_typedef()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_name = vx_p_name
        work.vx_p_extend = vx_p_extend
        work.vx_p_allowfuncs = vx_p_allowfuncs
        work.vx_p_allowtypes = vx_p_allowtypes
        work.vx_p_allowvalues = vx_p_allowvalues
        work.vx_p_disallowfuncs = vx_p_disallowfuncs
        work.vx_p_disallowtypes = vx_p_disallowtypes
        work.vx_p_disallowvalues = vx_p_disallowvalues
        work.vx_p_properties = vx_p_properties
        work.vx_p_proplast = vx_p_proplast
        work.vx_p_traits = vx_p_traits
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typedef
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "typedef", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_typedef : vx_core.Type_typedef = vx_core.Class_typedef()
  val t_typedef : vx_core.Type_typedef = vx_core.Class_typedef()

  interface Type_typelist : vx_core.Type_list {
  }

  class Class_typelist : vx_core.Class_base, Type_typelist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_typelist = this
      var iindex : Integer = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size()) {
        output = 
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.vx_copy(vx_core.e_typelist, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typelist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_typelist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          
        } else if (valsub is vx_core.Type_typelist) {
          var multi : vx_core.Type_typelist = valsub as vx_core.Type_typelist
          ischanged = true
          
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/typelist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/typelist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_typelist = vx_core.Class_typelist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typelist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typelist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "typelist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_typelist : vx_core.Type_typelist = vx_core.Class_typelist()
  val t_typelist : vx_core.Type_typelist = vx_core.Class_typelist()

  interface Type_typemap : vx_core.Type_map {
  }

  class Class_typemap : vx_core.Class_base, Type_typemap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    fun vx_map() : Map<String, vx_core.Type_any> {
      return vx_core.immutablemap(map)
    }

    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        String key = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_typemap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = 
      return output
    }

    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_typemap = vx_core.Class_typemap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      Set<String> keys = mapval.keySet()
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.get(key)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/typemap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_typemap {
      var output : vx_core.Type_typemap = vx_core.vx_copy(vx_core.e_typemap, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typemap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_typemap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var msg : vx_core.Type_msg = null
      var key : String
      var msgval : vx_core.Type_any = null
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/typemap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = null
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/typemap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != null) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_typemap = vx_core.Class_typemap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typemap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typemap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "typemap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_typemap : vx_core.Type_typemap = vx_core.Class_typemap()
  val t_typemap : vx_core.Type_typemap = vx_core.Class_typemap()

  interface Type_user : vx_core.Type_struct {
    fun security() : vx_core.Type_security
    fun username() : vx_core.Type_string
    fun token() : vx_core.Type_string
  }

  class Class_user : vx_core.Class_base, Type_user {
    constructor() {}

    var vx_p_security : vx_core.Type_security = null

    fun security() : vx_core.Type_security {
      var output : vx_core.Type_security = vx_core.e_security
      if (this.vx_p_security != null) {
        output = this.vx_p_security
      }
      return output
    }

    var vx_p_username : vx_core.Type_string = null

    fun username() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_username != null) {
        output = this.vx_p_username
      }
      return output
    }

    var vx_p_token : vx_core.Type_string = null

    fun token() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      if (this.vx_p_token != null) {
        output = this.vx_p_token
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":security":
        output = this.security()
        break
      case ":username":
        output = this.username()
        break
      case ":token":
        output = this.token()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":security", this.security())
      output.put(":username", this.username())
      output.put(":token", this.token())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_user {
      var output : vx_core.Type_user = vx_core.vx_copy(vx_core.e_user, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_user = this
      var ischanged : Boolean = false
      var value : vx_core.Class_user = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_security : vx_core.Type_security = value.security()
      var vx_p_username : vx_core.Type_string = value.username()
      var vx_p_token : vx_core.Type_string = value.token()
      List<String> validkeys = ArrayList<String>()
      
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":security":
            if (valsub == vx_p_security) {
            } else if (valsub is vx_core.Type_security) {
              var valsecurity : vx_core.Type_security = valsub as vx_core.Type_security
              ischanged = true
              vx_p_security = valsecurity
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("security"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":username":
            if (valsub == vx_p_username) {
            } else if (valsub is vx_core.Type_string) {
              var valusername : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_username = valusername
            } else if (valsub is String) {
              ischanged = true
              vx_p_username = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("username"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":token":
            if (valsub == vx_p_token) {
            } else if (valsub is vx_core.Type_string) {
              var valtoken : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_token = valtoken
            } else if (valsub is String) {
              ischanged = true
              vx_p_token = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("token"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_user = vx_core.Class_user()
        work.vx_p_security = vx_p_security
        work.vx_p_username = vx_p_username
        work.vx_p_token = vx_p_token
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_user
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_user
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "user", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_user : vx_core.Type_user = vx_core.Class_user()
  val t_user : vx_core.Type_user = vx_core.Class_user()

  interface Type_value : vx_core.Type_struct {
    fun next() : vx_core.Type_any
    fun refs() : vx_core.Type_int
  }

  class Class_value : vx_core.Class_base, Type_value {
    constructor() {}

    var vx_p_next : vx_core.Type_any = null

    fun next() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      if (this.vx_p_next != null) {
        output = this.vx_p_next
      }
      return output
    }

    var vx_p_refs : vx_core.Type_int = null

    fun refs() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      if (this.vx_p_refs != null) {
        output = this.vx_p_refs
      }
      return output
    }

    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      switch (skey) {
      case ":next":
        output = this.next()
        break
      case ":refs":
        output = this.refs()
        break
      }
      return output
    }

    fun vx_map() : Map<String, vx_core.Type_any> {
      var output : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      output.put(":next", this.next())
      output.put(":refs", this.refs())
      output = vx_core.immutablemap(output)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_value {
      var output : vx_core.Type_value = vx_core.vx_copy(vx_core.e_value, vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_value = this
      var ischanged : Boolean = false
      var value : vx_core.Class_value = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_next : vx_core.Type_any = value.next()
      var vx_p_refs : vx_core.Type_int = value.refs()
      List<String> validkeys = ArrayList<String>()
      
      
      String key = ""
      vx_core.Type_msg msg
      vx_core.Type_any msgval
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          switch (key) {
          case ":next":
            if (valsub == vx_p_next) {
            } else if (valsub is vx_core.Type_any) {
              var valnext : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_next = valnext
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("next"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          case ":refs":
            if (valsub == vx_p_refs) {
            } else if (valsub is vx_core.Type_int) {
              var valrefs : vx_core.Type_int = valsub as vx_core.Type_int
              ischanged = true
              vx_p_refs = valrefs
            } else if (valsub is Integer) {
              ischanged = true
              vx_p_refs = vx_core.vx_new(vx_core.t_int, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("refs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
            break
          default:
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
            break
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_value = vx_core.Class_value()
        work.vx_p_next = vx_p_next
        work.vx_p_refs = vx_p_refs
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_value
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "value", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_value : vx_core.Type_value = vx_core.Class_value()
  val t_value : vx_core.Type_value = vx_core.Class_value()

  class Const_false {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "false", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_boolean) : Unit {
      var outval : vx_core.Class_boolean = output as vx_core.Class_boolean
      outval.vx_p_constdef = constdef()
      outval.vxboolean = false
    }

  }

  val c_false : vx_core.Type_boolean = vx_core.Class_boolean()

  val e_boolean : vx_core.Type_boolean = vx_core.c_false

  class Const_global {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "global", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "project", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_project) : Unit {
      var outval : vx_core.Class_project = output as vx_core.Class_project
      outval.vx_p_constdef = constdef()
    }

  }

  val c_global : vx_core.Type_project = vx_core.Class_project()


  class Const_infinity {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "infinity", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

  }

  val c_infinity : vx_core.Type_int = vx_core.Class_int()


  class Const_mempool_active {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "mempool-active", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "mempool", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_mempool) : Unit {
      var outval : vx_core.Class_mempool = output as vx_core.Class_mempool
      outval.vx_p_constdef = constdef()
    }

  }

  val c_mempool_active : vx_core.Type_mempool = vx_core.Class_mempool()


  class Const_msg_error {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-error", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 2
    }

  }

  val c_msg_error : vx_core.Type_int = vx_core.Class_int()


  class Const_msg_info {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-info", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

  }

  val c_msg_info : vx_core.Type_int = vx_core.Class_int()


  class Const_msg_severe {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-severe", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 3
    }

  }

  val c_msg_severe : vx_core.Type_int = vx_core.Class_int()


  class Const_msg_warning {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-warning", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 1
    }

  }

  val c_msg_warning : vx_core.Type_int = vx_core.Class_int()


  class Const_neginfinity {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "neginfinity", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

  }

  val c_neginfinity : vx_core.Type_int = vx_core.Class_int()


  class Const_newline {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "newline", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "\n"
    }

  }

  val c_newline : vx_core.Type_string = vx_core.Class_string()


  class Const_notanumber {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "notanumber", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

  }

  val c_notanumber : vx_core.Type_int = vx_core.Class_int()


  class Const_nothing {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "nothing", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "nothing"
    }

  }

  val c_nothing : vx_core.Type_string = vx_core.Class_string()


  class Const_path_test_resources {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "path-test-resources", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "app/src/test/kotlin/resources"
    }

  }

  val c_path_test_resources : vx_core.Type_string = vx_core.Class_string()


  class Const_quote {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "quote", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "\""
    }

  }

  val c_quote : vx_core.Type_string = vx_core.Class_string()


  class Const_true {
    constructor() {}
    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "true", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_boolean) : Unit {
      var outval : vx_core.Class_boolean = output as vx_core.Class_boolean
      outval.vx_p_constdef = constdef()
      outval.vxboolean = true
    }

  }

  val c_true : vx_core.Type_boolean = vx_core.Class_boolean()


  interface Func_not : vx_core.Func_any_from_any {
    fun vx_not(val : vx_core.Type_boolean) : vx_core.Type_boolean
  }

  class Class_not : vx_core.Class_base, Func_not {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_not {
      val output : vx_core.Class_not = vx_core.Class_not()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_not = vx_core.Class_not()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_not
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_not
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_boolean = value as vx_core.Type_boolean
      var outputval : vx_core.Type_any = vx_core.f_not(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_not(val)
      return output
    }

    fun vx_core.Type_boolean vx_not(vx_core.Type_boolean val) {
      return vx_core.f_not(val)
    }

  }

  val e_not : vx_core.Func_not = vx_core.Class_not()
  val t_not : vx_core.Func_not = vx_core.Class_not()

  fun f_not(val : vx_core.Type_boolean) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.vx_new_boolean(!val.vx_boolean())
    return output
  }


  interface Func_notempty : vx_core.Func_any_from_any {
    fun vx_notempty(text : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_notempty : vx_core.Class_base, Func_notempty {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_notempty {
      val output : vx_core.Class_notempty = vx_core.Class_notempty()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_notempty = vx_core.Class_notempty()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_notempty
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_notempty
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_notempty(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_notempty(text)
      return output
    }

    fun vx_core.Type_boolean vx_notempty(vx_core.Type_string text) {
      return vx_core.f_notempty(text)
    }

  }

  val e_notempty : vx_core.Func_notempty = vx_core.Class_notempty()
  val t_notempty : vx_core.Func_notempty = vx_core.Class_notempty()

  fun f_notempty(text : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_is_empty(text)
    )
    return output
  }


  interface Func_notempty_1 : vx_core.Func_any_from_any {
    fun vx_notempty_1(val : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_notempty_1 : vx_core.Class_base, Func_notempty_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_notempty_1 {
      val output : vx_core.Class_notempty_1 = vx_core.Class_notempty_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_notempty_1 = vx_core.Class_notempty_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_notempty_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_notempty_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_notempty_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_notempty_1(val)
      return output
    }

    fun vx_core.Type_boolean vx_notempty_1(vx_core.Type_any val) {
      return vx_core.f_notempty_1(val)
    }

  }

  val e_notempty_1 : vx_core.Func_notempty_1 = vx_core.Class_notempty_1()
  val t_notempty_1 : vx_core.Func_notempty_1 = vx_core.Class_notempty_1()

  fun f_notempty_1(val : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_is_empty_1(val)
    )
    return output
  }


  interface Func_ne : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_ne(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_ne : vx_core.Class_base, Func_ne {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_ne {
      val output : vx_core.Class_ne = vx_core.Class_ne()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ne = vx_core.Class_ne()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_ne
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_ne
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_ne(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_ne(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_ne(val1, val2)
    }

  }

  val e_ne : vx_core.Func_ne = vx_core.Class_ne()
  val t_ne : vx_core.Func_ne = vx_core.Class_ne()

  fun f_ne(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_eq(val1, val2)
    )
    return output
  }


  interface Func_neqeq : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_neqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_neqeq : vx_core.Class_base, Func_neqeq {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_neqeq {
      val output : vx_core.Class_neqeq = vx_core.Class_neqeq()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_neqeq = vx_core.Class_neqeq()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!==", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_neqeq
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_neqeq
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_neqeq(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_neqeq(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_neqeq(val1, val2)
    }

  }

  val e_neqeq : vx_core.Func_neqeq = vx_core.Class_neqeq()
  val t_neqeq : vx_core.Func_neqeq = vx_core.Class_neqeq()

  fun f_neqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_eqeq(val1, val2)
    )
    return output
  }


  interface Func_multiply : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_multiply(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_multiply : vx_core.Class_base, Func_multiply {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_multiply {
      val output : vx_core.Class_multiply = vx_core.Class_multiply()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply = vx_core.Class_multiply()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_multiply(num1, num2)
      return output
    }

    fun vx_core.Type_int vx_multiply(vx_core.Type_int num1, vx_core.Type_int num2) {
      return vx_core.f_multiply(num1, num2)
    }

  }

  val e_multiply : vx_core.Func_multiply = vx_core.Class_multiply()
  val t_multiply : vx_core.Func_multiply = vx_core.Class_multiply()

  fun f_multiply(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    return output
  }


  interface Func_multiply_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_multiply_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_multiply_1 : vx_core.Class_base, Func_multiply_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_multiply_1 {
      val output : vx_core.Class_multiply_1 = vx_core.Class_multiply_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_1 = vx_core.Class_multiply_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_multiply_1(num1, num2)
      return output
    }

    fun vx_core.Type_number vx_multiply_1(vx_core.Type_number num1, vx_core.Type_number num2) {
      return vx_core.f_multiply_1(num1, num2)
    }

  }

  val e_multiply_1 : vx_core.Func_multiply_1 = vx_core.Class_multiply_1()
  val t_multiply_1 : vx_core.Func_multiply_1 = vx_core.Class_multiply_1()

  fun f_multiply_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    return output
  }


  interface Func_multiply_2 : vx_core.Func_any_from_any {
    fun vx_multiply_2(nums : vx_core.Type_intlist) : vx_core.Type_int
  }

  class Class_multiply_2 : vx_core.Class_base, Func_multiply_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_multiply_2 {
      val output : vx_core.Class_multiply_2 = vx_core.Class_multiply_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_2 = vx_core.Class_multiply_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_intlist = value as vx_core.Type_intlist
      var outputval : vx_core.Type_any = vx_core.f_multiply_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_intlist = vx_core.f_any_from_any(vx_core.t_intlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_multiply_2(nums)
      return output
    }

    fun vx_core.Type_int vx_multiply_2(vx_core.Type_intlist nums) {
      return vx_core.f_multiply_2(nums)
    }

  }

  val e_multiply_2 : vx_core.Func_multiply_2 = vx_core.Class_multiply_2()
  val t_multiply_2 : vx_core.Func_multiply_2 = vx_core.Class_multiply_2()

  fun f_multiply_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_int,
      nums,
      vx_core.vx_new_int(1),
      vx_core.t_any_from_reduce.vx_fn_new((total_any, num_any)  {
        vx_core.Type_int total = vx_core.f_any_from_any(vx_core.t_int, total_any)
        vx_core.Type_int num = vx_core.f_any_from_any(vx_core.t_int, num_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_multiply(total, num)
        return output_1
      })
    )
    return output
  }


  interface Func_multiply_3 : vx_core.Func_any_from_any {
    fun vx_multiply_3(nums : vx_core.Type_numberlist) : vx_core.Type_number
  }

  class Class_multiply_3 : vx_core.Class_base, Func_multiply_3 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_multiply_3 {
      val output : vx_core.Class_multiply_3 = vx_core.Class_multiply_3()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_3 = vx_core.Class_multiply_3()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        3, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply_3
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply_3
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_numberlist = value as vx_core.Type_numberlist
      var outputval : vx_core.Type_any = vx_core.f_multiply_3(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_numberlist = vx_core.f_any_from_any(vx_core.t_numberlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_multiply_3(nums)
      return output
    }

    fun vx_core.Type_number vx_multiply_3(vx_core.Type_numberlist nums) {
      return vx_core.f_multiply_3(nums)
    }

  }

  val e_multiply_3 : vx_core.Func_multiply_3 = vx_core.Class_multiply_3()
  val t_multiply_3 : vx_core.Func_multiply_3 = vx_core.Class_multiply_3()

  fun f_multiply_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_number,
      nums,
      vx_core.vx_new_int(1),
      vx_core.t_any_from_reduce.vx_fn_new((total_any, num_any)  {
        vx_core.Type_number total = vx_core.f_any_from_any(vx_core.t_number, total_any)
        vx_core.Type_number num = vx_core.f_any_from_any(vx_core.t_number, num_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_multiply_1(total, num)
        return output_1
      })
    )
    return output
  }


  interface Func_plus : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_plus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_plus : vx_core.Class_base, Func_plus {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_plus {
      val output : vx_core.Class_plus = vx_core.Class_plus()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus = vx_core.Class_plus()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_plus(num1, num2)
      return output
    }

    fun vx_core.Type_int vx_plus(vx_core.Type_int num1, vx_core.Type_int num2) {
      return vx_core.f_plus(num1, num2)
    }

  }

  val e_plus : vx_core.Func_plus = vx_core.Class_plus()
  val t_plus : vx_core.Func_plus = vx_core.Class_plus()

  fun f_plus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    return output
  }


  interface Func_plus_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_plus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_plus_1 : vx_core.Class_base, Func_plus_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_plus_1 {
      val output : vx_core.Class_plus_1 = vx_core.Class_plus_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_1 = vx_core.Class_plus_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_plus_1(num1, num2)
      return output
    }

    fun vx_core.Type_number vx_plus_1(vx_core.Type_number num1, vx_core.Type_number num2) {
      return vx_core.f_plus_1(num1, num2)
    }

  }

  val e_plus_1 : vx_core.Func_plus_1 = vx_core.Class_plus_1()
  val t_plus_1 : vx_core.Func_plus_1 = vx_core.Class_plus_1()

  fun f_plus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    return output
  }


  interface Func_plus_2 : vx_core.Func_any_from_any {
    fun vx_plus_2(nums : vx_core.Type_intlist) : vx_core.Type_int
  }

  class Class_plus_2 : vx_core.Class_base, Func_plus_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_plus_2 {
      val output : vx_core.Class_plus_2 = vx_core.Class_plus_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_2 = vx_core.Class_plus_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_intlist = value as vx_core.Type_intlist
      var outputval : vx_core.Type_any = vx_core.f_plus_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_intlist = vx_core.f_any_from_any(vx_core.t_intlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_plus_2(nums)
      return output
    }

    fun vx_core.Type_int vx_plus_2(vx_core.Type_intlist nums) {
      return vx_core.f_plus_2(nums)
    }

  }

  val e_plus_2 : vx_core.Func_plus_2 = vx_core.Class_plus_2()
  val t_plus_2 : vx_core.Func_plus_2 = vx_core.Class_plus_2()

  fun f_plus_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_int,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new((total_any, num_any)  {
        vx_core.Type_int total = vx_core.f_any_from_any(vx_core.t_int, total_any)
        vx_core.Type_int num = vx_core.f_any_from_any(vx_core.t_int, num_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_plus(total, num)
        return output_1
      })
    )
    return output
  }


  interface Func_plus_3 : vx_core.Func_any_from_any {
    fun vx_plus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number
  }

  class Class_plus_3 : vx_core.Class_base, Func_plus_3 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_plus_3 {
      val output : vx_core.Class_plus_3 = vx_core.Class_plus_3()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_3 = vx_core.Class_plus_3()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        3, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus_3
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus_3
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_numberlist = value as vx_core.Type_numberlist
      var outputval : vx_core.Type_any = vx_core.f_plus_3(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_numberlist = vx_core.f_any_from_any(vx_core.t_numberlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_plus_3(nums)
      return output
    }

    fun vx_core.Type_number vx_plus_3(vx_core.Type_numberlist nums) {
      return vx_core.f_plus_3(nums)
    }

  }

  val e_plus_3 : vx_core.Func_plus_3 = vx_core.Class_plus_3()
  val t_plus_3 : vx_core.Func_plus_3 = vx_core.Class_plus_3()

  fun f_plus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_number,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new((total_any, num_any)  {
        vx_core.Type_number total = vx_core.f_any_from_any(vx_core.t_number, total_any)
        vx_core.Type_number num = vx_core.f_any_from_any(vx_core.t_number, num_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_plus_1(total, num)
        return output_1
      })
    )
    return output
  }


  interface Func_plus1 : vx_core.Func_any_from_any {
    fun vx_plus1(num : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_plus1 : vx_core.Class_base, Func_plus1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_plus1 {
      val output : vx_core.Class_plus1 = vx_core.Class_plus1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus1 = vx_core.Class_plus1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+1", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_int = value as vx_core.Type_int
      var outputval : vx_core.Type_any = vx_core.f_plus1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_plus1(num)
      return output
    }

    fun vx_core.Type_int vx_plus1(vx_core.Type_int num) {
      return vx_core.f_plus1(num)
    }

  }

  val e_plus1 : vx_core.Func_plus1 = vx_core.Class_plus1()
  val t_plus1 : vx_core.Func_plus1 = vx_core.Class_plus1()

  fun f_plus1(num : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_plus(num, vx_core.vx_new_int(1))
    return output
  }


  interface Func_minus : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_minus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_minus : vx_core.Class_base, Func_minus {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_minus {
      val output : vx_core.Class_minus = vx_core.Class_minus()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus = vx_core.Class_minus()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_minus(num1, num2)
      return output
    }

    fun vx_core.Type_int vx_minus(vx_core.Type_int num1, vx_core.Type_int num2) {
      return vx_core.f_minus(num1, num2)
    }

  }

  val e_minus : vx_core.Func_minus = vx_core.Class_minus()
  val t_minus : vx_core.Func_minus = vx_core.Class_minus()

  fun f_minus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    return output
  }


  interface Func_minus_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_minus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_minus_1 : vx_core.Class_base, Func_minus_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_minus_1 {
      val output : vx_core.Class_minus_1 = vx_core.Class_minus_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_1 = vx_core.Class_minus_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_minus_1(num1, num2)
      return output
    }

    fun vx_core.Type_number vx_minus_1(vx_core.Type_number num1, vx_core.Type_number num2) {
      return vx_core.f_minus_1(num1, num2)
    }

  }

  val e_minus_1 : vx_core.Func_minus_1 = vx_core.Class_minus_1()
  val t_minus_1 : vx_core.Func_minus_1 = vx_core.Class_minus_1()

  fun f_minus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    return output
  }


  interface Func_minus_2 : vx_core.Func_any_from_any {
    fun vx_minus_2(nums : vx_core.Type_intlist) : vx_core.Type_int
  }

  class Class_minus_2 : vx_core.Class_base, Func_minus_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_minus_2 {
      val output : vx_core.Class_minus_2 = vx_core.Class_minus_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_2 = vx_core.Class_minus_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_intlist = value as vx_core.Type_intlist
      var outputval : vx_core.Type_any = vx_core.f_minus_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_intlist = vx_core.f_any_from_any(vx_core.t_intlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_minus_2(nums)
      return output
    }

    fun vx_core.Type_int vx_minus_2(vx_core.Type_intlist nums) {
      return vx_core.f_minus_2(nums)
    }

  }

  val e_minus_2 : vx_core.Func_minus_2 = vx_core.Class_minus_2()
  val t_minus_2 : vx_core.Func_minus_2 = vx_core.Class_minus_2()

  fun f_minus_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_int,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new((total_any, num_any)  {
        vx_core.Type_int total = vx_core.f_any_from_any(vx_core.t_int, total_any)
        vx_core.Type_int num = vx_core.f_any_from_any(vx_core.t_int, num_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_minus(total, num)
        return output_1
      })
    )
    return output
  }


  interface Func_minus_3 : vx_core.Func_any_from_any {
    fun vx_minus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number
  }

  class Class_minus_3 : vx_core.Class_base, Func_minus_3 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_minus_3 {
      val output : vx_core.Class_minus_3 = vx_core.Class_minus_3()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_3 = vx_core.Class_minus_3()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        3, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus_3
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus_3
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_numberlist = value as vx_core.Type_numberlist
      var outputval : vx_core.Type_any = vx_core.f_minus_3(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_numberlist = vx_core.f_any_from_any(vx_core.t_numberlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_minus_3(nums)
      return output
    }

    fun vx_core.Type_number vx_minus_3(vx_core.Type_numberlist nums) {
      return vx_core.f_minus_3(nums)
    }

  }

  val e_minus_3 : vx_core.Func_minus_3 = vx_core.Class_minus_3()
  val t_minus_3 : vx_core.Func_minus_3 = vx_core.Class_minus_3()

  fun f_minus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_number,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new((total_any, num_any)  {
        vx_core.Type_number total = vx_core.f_any_from_any(vx_core.t_number, total_any)
        vx_core.Type_number num = vx_core.f_any_from_any(vx_core.t_number, num_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_minus_1(total, num)
        return output_1
      })
    )
    return output
  }


  interface Func_minus1 : vx_core.Func_any_from_any {
    fun vx_minus1(num : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_minus1 : vx_core.Class_base, Func_minus1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_minus1 {
      val output : vx_core.Class_minus1 = vx_core.Class_minus1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus1 = vx_core.Class_minus1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-1", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_int = value as vx_core.Type_int
      var outputval : vx_core.Type_any = vx_core.f_minus1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_minus1(num)
      return output
    }

    fun vx_core.Type_int vx_minus1(vx_core.Type_int num) {
      return vx_core.f_minus1(num)
    }

  }

  val e_minus1 : vx_core.Func_minus1 = vx_core.Class_minus1()
  val t_minus1 : vx_core.Func_minus1 = vx_core.Class_minus1()

  fun f_minus1(num : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_minus(num, vx_core.vx_new_int(1))
    return output
  }


  interface Func_dotmethod : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_dotmethod(target : vx_core.Type_any, method : vx_core.Type_string, parameters : vx_core.Type_anylist) : vx_core.Type_any
  }

  class Class_dotmethod : vx_core.Class_base, Func_dotmethod {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_dotmethod {
      val output : vx_core.Class_dotmethod = vx_core.Class_dotmethod()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_dotmethod = vx_core.Class_dotmethod()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ".", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_dotmethod
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_dotmethod
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var target : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var method : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var parameters : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_dotmethod(target, method, parameters)
      return output
    }

    fun vx_core.Type_any vx_dotmethod(vx_core.Type_any target, vx_core.Type_string method, vx_core.Type_anylist parameters) {
      return vx_core.f_dotmethod(target, method, parameters)
    }

  }

  val e_dotmethod : vx_core.Func_dotmethod = vx_core.Class_dotmethod()
  val t_dotmethod : vx_core.Func_dotmethod = vx_core.Class_dotmethod()

  fun f_dotmethod(target : vx_core.Type_any, method : vx_core.Type_string, parameters : vx_core.Type_anylist) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_divide : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_divide(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_divide : vx_core.Class_base, Func_divide {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_divide {
      val output : vx_core.Class_divide = vx_core.Class_divide()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_divide = vx_core.Class_divide()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "/", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_divide
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_divide
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_divide(num1, num2)
      return output
    }

    fun vx_core.Type_number vx_divide(vx_core.Type_number num1, vx_core.Type_number num2) {
      return vx_core.f_divide(num1, num2)
    }

  }

  val e_divide : vx_core.Func_divide = vx_core.Class_divide()
  val t_divide : vx_core.Func_divide = vx_core.Class_divide()

  fun f_divide(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    return output
  }


  interface Func_lt : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_lt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_lt : vx_core.Class_base, Func_lt {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_lt {
      val output : vx_core.Class_lt = vx_core.Class_lt()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_lt = vx_core.Class_lt()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_lt
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_lt
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_lt(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_lt(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_lt(val1, val2)
    }

  }

  val e_lt : vx_core.Func_lt = vx_core.Class_lt()
  val t_lt : vx_core.Func_lt = vx_core.Class_lt()

  fun f_lt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_compare(val1, val2),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_int(-1),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(true)
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(false)
          })
        )
      )
    )
    return output
  }


  interface Func_lt_1 : vx_core.Func_any_from_any {
    fun vx_lt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_lt_1 : vx_core.Class_base, Func_lt_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_lt_1 {
      val output : vx_core.Class_lt_1 = vx_core.Class_lt_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_lt_1 = vx_core.Class_lt_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_lt_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_lt_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_lt_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_lt_1(values)
      return output
    }

    fun vx_core.Type_boolean vx_lt_1(vx_core.Type_anylist values) {
      return vx_core.f_lt_1(values)
    }

  }

  val e_lt_1 : vx_core.Func_lt_1 = vx_core.Class_lt_1()
  val t_lt_1 : vx_core.Func_lt_1 = vx_core.Class_lt_1()

  fun f_lt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(true),
      vx_core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any)  {
        vx_core.Type_boolean reduce = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        vx_core.Type_any current = vx_core.f_any_from_any(vx_core.t_any, current_any)
        vx_core.Type_any next = vx_core.f_any_from_any(vx_core.t_any, next_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_and(
            reduce,
            vx_core.f_lt(current, next)
          )
        return output_1
      })
    )
    return output
  }


  interface Func_chainfirst : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_chainfirst(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T
  }

  class Class_chainfirst : vx_core.Class_base, Func_chainfirst {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_chainfirst {
      val output : vx_core.Class_chainfirst = vx_core.Class_chainfirst()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_chainfirst = vx_core.Class_chainfirst()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<-", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_chainfirst
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_chainfirst
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fnlist : vx_core.Type_any_from_anylist = vx_core.f_any_from_any(vx_core.t_any_from_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_chainfirst(generic_any_1, value, fnlist)
      return output
    }

    fun <T : vx_core.Type_any> T vx_chainfirst(T generic_any_1, T value, vx_core.Type_any_from_anylist fnlist) {
      return vx_core.f_chainfirst(generic_any_1, value, fnlist)
    }

  }

  val e_chainfirst : vx_core.Func_chainfirst = vx_core.Class_chainfirst()
  val t_chainfirst : vx_core.Func_chainfirst = vx_core.Class_chainfirst()

  fun <T : vx_core.Type_any> f_chainfirst(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_chainlast : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_chainlast(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T
  }

  class Class_chainlast : vx_core.Class_base, Func_chainlast {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_chainlast {
      val output : vx_core.Class_chainlast = vx_core.Class_chainlast()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_chainlast = vx_core.Class_chainlast()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<<-", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_chainlast
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_chainlast
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fnlist : vx_core.Type_any_from_anylist = vx_core.f_any_from_any(vx_core.t_any_from_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_chainlast(generic_any_1, value, fnlist)
      return output
    }

    fun <T : vx_core.Type_any> T vx_chainlast(T generic_any_1, T value, vx_core.Type_any_from_anylist fnlist) {
      return vx_core.f_chainlast(generic_any_1, value, fnlist)
    }

  }

  val e_chainlast : vx_core.Func_chainlast = vx_core.Class_chainlast()
  val t_chainlast : vx_core.Func_chainlast = vx_core.Class_chainlast()

  fun <T : vx_core.Type_any> f_chainlast(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_le : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_le(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_le : vx_core.Class_base, Func_le {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_le {
      val output : vx_core.Class_le = vx_core.Class_le()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_le = vx_core.Class_le()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_le
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_le
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_le(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_le(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_le(val1, val2)
    }

  }

  val e_le : vx_core.Func_le = vx_core.Class_le()
  val t_le : vx_core.Func_le = vx_core.Class_le()

  fun f_le(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_gt(val1, val2)
    )
    return output
  }


  interface Func_le_1 : vx_core.Func_any_from_any {
    fun vx_le_1(args : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_le_1 : vx_core.Class_base, Func_le_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_le_1 {
      val output : vx_core.Class_le_1 = vx_core.Class_le_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_le_1 = vx_core.Class_le_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_le_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_le_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_le_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_le_1(args)
      return output
    }

    fun vx_core.Type_boolean vx_le_1(vx_core.Type_anylist args) {
      return vx_core.f_le_1(args)
    }

  }

  val e_le_1 : vx_core.Func_le_1 = vx_core.Class_le_1()
  val t_le_1 : vx_core.Func_le_1 = vx_core.Class_le_1()

  fun f_le_1(args : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_gt_1(args)
    )
    return output
  }


  interface Func_eq : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_eq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_eq : vx_core.Class_base, Func_eq {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_eq {
      val output : vx_core.Class_eq = vx_core.Class_eq()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eq = vx_core.Class_eq()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_eq
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_eq
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_eq(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_eq(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_eq(val1, val2)
    }

  }

  val e_eq : vx_core.Func_eq = vx_core.Class_eq()
  val t_eq : vx_core.Func_eq = vx_core.Class_eq()

  fun f_eq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_eq_1 : vx_core.Func_any_from_any {
    fun vx_eq_1(values : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_eq_1 : vx_core.Class_base, Func_eq_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_eq_1 {
      val output : vx_core.Class_eq_1 = vx_core.Class_eq_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eq_1 = vx_core.Class_eq_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_eq_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_eq_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_eq_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_eq_1(values)
      return output
    }

    fun vx_core.Type_boolean vx_eq_1(vx_core.Type_anylist values) {
      return vx_core.f_eq_1(values)
    }

  }

  val e_eq_1 : vx_core.Func_eq_1 = vx_core.Class_eq_1()
  val t_eq_1 : vx_core.Func_eq_1 = vx_core.Class_eq_1()

  fun f_eq_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(false),
      vx_core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any)  {
        vx_core.Type_boolean reduce = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        vx_core.Type_any current = vx_core.f_any_from_any(vx_core.t_any, current_any)
        vx_core.Type_any next = vx_core.f_any_from_any(vx_core.t_any, next_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_and(
            reduce,
            vx_core.f_eq(current, next)
          )
        return output_1
      })
    )
    return output
  }


  interface Func_eqeq : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_eqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_eqeq : vx_core.Class_base, Func_eqeq {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_eqeq {
      val output : vx_core.Class_eqeq = vx_core.Class_eqeq()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eqeq = vx_core.Class_eqeq()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "==", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_eqeq
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_eqeq
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_eqeq(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_eqeq(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_eqeq(val1, val2)
    }

  }

  val e_eqeq : vx_core.Func_eqeq = vx_core.Class_eqeq()
  val t_eqeq : vx_core.Func_eqeq = vx_core.Class_eqeq()

  fun f_eqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val isequal : Boolean = vx_core.vx_eqeq(val1, val2)
    output = vx_core.vx_new_boolean(isequal)
    return output
  }


  interface Func_gt : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_gt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_gt : vx_core.Class_base, Func_gt {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_gt {
      val output : vx_core.Class_gt = vx_core.Class_gt()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_gt = vx_core.Class_gt()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_gt
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_gt
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_gt(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_gt(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_gt(val1, val2)
    }

  }

  val e_gt : vx_core.Func_gt = vx_core.Class_gt()
  val t_gt : vx_core.Func_gt = vx_core.Class_gt()

  fun f_gt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_compare(val1, val2),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_int(1),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(true)
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(false)
          })
        )
      )
    )
    return output
  }


  interface Func_gt_1 : vx_core.Func_any_from_any {
    fun vx_gt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_gt_1 : vx_core.Class_base, Func_gt_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_gt_1 {
      val output : vx_core.Class_gt_1 = vx_core.Class_gt_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_gt_1 = vx_core.Class_gt_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_gt_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_gt_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_gt_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_gt_1(values)
      return output
    }

    fun vx_core.Type_boolean vx_gt_1(vx_core.Type_anylist values) {
      return vx_core.f_gt_1(values)
    }

  }

  val e_gt_1 : vx_core.Func_gt_1 = vx_core.Class_gt_1()
  val t_gt_1 : vx_core.Func_gt_1 = vx_core.Class_gt_1()

  fun f_gt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(true),
      vx_core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any)  {
        vx_core.Type_boolean reduce = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        vx_core.Type_any current = vx_core.f_any_from_any(vx_core.t_any, current_any)
        vx_core.Type_any next = vx_core.f_any_from_any(vx_core.t_any, next_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_and(
            reduce,
            vx_core.f_gt(current, next)
          )
        return output_1
      })
    )
    return output
  }


  interface Func_ge : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_ge(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_ge : vx_core.Class_base, Func_ge {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_ge {
      val output : vx_core.Class_ge = vx_core.Class_ge()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ge = vx_core.Class_ge()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_ge
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_ge
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_ge(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_ge(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_ge(val1, val2)
    }

  }

  val e_ge : vx_core.Func_ge = vx_core.Class_ge()
  val t_ge : vx_core.Func_ge = vx_core.Class_ge()

  fun f_ge(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_lt(val1, val2)
    )
    return output
  }


  interface Func_ge_1 : vx_core.Func_any_from_any {
    fun vx_ge_1(args : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_ge_1 : vx_core.Class_base, Func_ge_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_ge_1 {
      val output : vx_core.Class_ge_1 = vx_core.Class_ge_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ge_1 = vx_core.Class_ge_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_ge_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_ge_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_ge_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_ge_1(args)
      return output
    }

    fun vx_core.Type_boolean vx_ge_1(vx_core.Type_anylist args) {
      return vx_core.f_ge_1(args)
    }

  }

  val e_ge_1 : vx_core.Func_ge_1 = vx_core.Class_ge_1()
  val t_ge_1 : vx_core.Func_ge_1 = vx_core.Class_ge_1()

  fun f_ge_1(args : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_lt_1(args)
    )
    return output
  }


  interface Func_allowfuncs_from_security : vx_core.Func_any_from_any {
    fun vx_allowfuncs_from_security(security : vx_core.Type_security) : vx_core.Type_funclist
  }

  class Class_allowfuncs_from_security : vx_core.Class_base, Func_allowfuncs_from_security {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_allowfuncs_from_security {
      val output : vx_core.Class_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "allowfuncs<-security", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "funclist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_func), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_allowfuncs_from_security
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_allowfuncs_from_security
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_security = value as vx_core.Type_security
      var outputval : vx_core.Type_any = vx_core.f_allowfuncs_from_security(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var security : vx_core.Type_security = vx_core.f_any_from_any(vx_core.t_security, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_allowfuncs_from_security(security)
      return output
    }

    fun vx_core.Type_funclist vx_allowfuncs_from_security(vx_core.Type_security security) {
      return vx_core.f_allowfuncs_from_security(security)
    }

  }

  val e_allowfuncs_from_security : vx_core.Func_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()
  val t_allowfuncs_from_security : vx_core.Func_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()

  fun f_allowfuncs_from_security(security : vx_core.Type_security) : vx_core.Type_funclist {
    var output : vx_core.Type_funclist = vx_core.e_funclist
    output = security.allowfuncs()
    return output
  }


  interface Func_allowtypenames_from_typedef : vx_core.Func_any_from_any {
    fun vx_allowtypenames_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_stringlist
  }

  class Class_allowtypenames_from_typedef : vx_core.Class_base, Func_allowtypenames_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_allowtypenames_from_typedef {
      val output : vx_core.Class_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "allowtypenames<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_allowtypenames_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_allowtypenames_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_allowtypenames_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_allowtypenames_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_stringlist vx_allowtypenames_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_allowtypenames_from_typedef(vtypedef)
    }

  }

  val e_allowtypenames_from_typedef : vx_core.Func_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()
  val t_allowtypenames_from_typedef : vx_core.Func_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()

  fun f_allowtypenames_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_stringlist {
    var output : vx_core.Type_stringlist = vx_core.e_stringlist
    output = vx_core.f_typenames_from_typelist(
      vx_core.f_allowtypes_from_typedef(vtypedef)
    )
    return output
  }


  interface Func_allowtypes_from_typedef : vx_core.Func_any_from_any {
    fun vx_allowtypes_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist
  }

  class Class_allowtypes_from_typedef : vx_core.Class_base, Func_allowtypes_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_allowtypes_from_typedef {
      val output : vx_core.Class_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "allowtypes<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_allowtypes_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_allowtypes_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_allowtypes_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_allowtypes_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_typelist vx_allowtypes_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_allowtypes_from_typedef(vtypedef)
    }

  }

  val e_allowtypes_from_typedef : vx_core.Func_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()
  val t_allowtypes_from_typedef : vx_core.Func_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()

  fun f_allowtypes_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist {
    var output : vx_core.Type_typelist = vx_core.e_typelist
    output = vtypedef.allowtypes()
    return output
  }


  interface Func_and : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_and(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean
  }

  class Class_and : vx_core.Class_base, Func_and {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_and {
      val output : vx_core.Class_and = vx_core.Class_and()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_and = vx_core.Class_and()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_and
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_and
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_and(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_and(vx_core.Type_boolean val1, vx_core.Type_boolean val2) {
      return vx_core.f_and(val1, val2)
    }

  }

  val e_and : vx_core.Func_and = vx_core.Class_and()
  val t_and : vx_core.Func_and = vx_core.Class_and()

  fun f_and(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (val1.vx_boolean() && val2.vx_boolean()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }
    return output
  }


  interface Func_and_1 : vx_core.Func_any_from_any {
    fun vx_and_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean
  }

  class Class_and_1 : vx_core.Class_base, Func_and_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_and_1 {
      val output : vx_core.Class_and_1 = vx_core.Class_and_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_and_1 = vx_core.Class_and_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_and_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_and_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_booleanlist = value as vx_core.Type_booleanlist
      var outputval : vx_core.Type_any = vx_core.f_and_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_booleanlist = vx_core.f_any_from_any(vx_core.t_booleanlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_and_1(values)
      return output
    }

    fun vx_core.Type_boolean vx_and_1(vx_core.Type_booleanlist values) {
      return vx_core.f_and_1(values)
    }

  }

  val e_and_1 : vx_core.Func_and_1 = vx_core.Class_and_1()
  val t_and_1 : vx_core.Func_and_1 = vx_core.Class_and_1()

  fun f_and_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_length_1(values),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_int(0),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(true)
          })
        ),
        vx_core.f_case_1(
          vx_core.vx_new_int(1),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.f_any_from_list(vx_core.t_boolean, values, vx_core.vx_new_int(1))
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.f_any_from_list_start_reduce_next(
              vx_core.t_boolean,
              values,
              vx_core.vx_new_boolean(true),
              vx_core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any)  {
                vx_core.Type_boolean reduce = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
                vx_core.Type_boolean current = vx_core.f_any_from_any(vx_core.t_boolean, current_any)
                vx_core.Type_boolean next = vx_core.f_any_from_any(vx_core.t_boolean, next_any)
                var output_1 : vx_core.Type_any = 
                    vx_core.f_and(
                      reduce,
                      vx_core.f_and(current, next)
                    )
                return output_1
              })
            )
          })
        )
      )
    )
    return output
  }


  interface Func_any_from_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any
  }

  class Class_any_from_any : vx_core.Class_base, Func_any_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_any {
      val output : vx_core.Class_any_from_any = vx_core.Class_any_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any = vx_core.Class_any_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any
      return output
    }

    fun IFn(vx_core.Type_any value) : vx_core.Type_any

    var fn : vx_core.Class_any_from_any.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      val output : vx_core.Class_any_from_any = vx_core.Class_any_from_any()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_any(generic_any_1, value)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_any(T generic_any_1, U value) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_any : vx_core.Func_any_from_any = vx_core.Class_any_from_any()
  val t_any_from_any : vx_core.Func_any_from_any = vx_core.Class_any_from_any()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any(generic_any_1 : T, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    @Suppress("UNCHECKED_CAST")
    output = value as T
    return output
  }


  interface Func_any_from_any_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async
  }

  class Class_any_from_any_async : vx_core.Class_base, Func_any_from_any_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_any_async {
      val output : vx_core.Class_any_from_any_async = vx_core.Class_any_from_any_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_async = vx_core.Class_any_from_any_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_async
      return output
    }

    fun IFn(vx_core.Type_any value) : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_any_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async {
      val output : vx_core.Class_any_from_any_async = vx_core.Class_any_from_any_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_any_from_any_async(generic_any_1, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> <T> vx_any_from_any_async(T generic_any_1, U value) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn(value)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_any_async : vx_core.Func_any_from_any_async = vx_core.Class_any_from_any_async()
  val t_any_from_any_async : vx_core.Func_any_from_any_async = vx_core.Class_any_from_any_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_async(generic_any_1 : T, value : U) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_any_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context
  }

  class Class_any_from_any_context : vx_core.Class_base, Func_any_from_any_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_any_context {
      val output : vx_core.Class_any_from_any_context = vx_core.Class_any_from_any_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_context = vx_core.Class_any_from_any_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_context
      return output
    }

    fun IFn(vx_core.Type_context context, vx_core.Type_any value) : vx_core.Type_any

    var fn : vx_core.Class_any_from_any_context.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      val output : vx_core.Class_any_from_any_context = vx_core.Class_any_from_any_context()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_any_context(generic_any_1, context, value)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_any_context(T generic_any_1, vx_core.Type_context context, U value) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(context, value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_any_context : vx_core.Func_any_from_any_context = vx_core.Class_any_from_any_context()
  val t_any_from_any_context : vx_core.Func_any_from_any_context = vx_core.Class_any_from_any_context()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    if (value is T) {
      output = (value as T)
    }
    return output
  }


  interface Func_any_from_any_context_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context_async(generic_any_1 : T, context : vx_core.Type_context, value : U) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_any_context_async.IFn) : vx_core.Func_any_from_any_context_async
  }

  class Class_any_from_any_context_async : vx_core.Class_base, Func_any_from_any_context_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_any_context_async {
      val output : vx_core.Class_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_context_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_context_async
      return output
    }

    fun IFn(vx_core.Type_context context, vx_core.Type_any value) : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_any_context_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context_async.IFn) : vx_core.Func_any_from_any_context_async {
      val output : vx_core.Class_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_any_from_any_context_async(generic_any_1, context, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> <T> vx_any_from_any_context_async(T generic_any_1, vx_core.Type_context context, U value) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn(context, value)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_any_context_async : vx_core.Func_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
  val t_any_from_any_context_async : vx_core.Func_any_from_any_context_async = vx_core.Class_any_from_any_context_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_context_async(generic_any_1 : T, context : vx_core.Type_context, value : U) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_any_key_value : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_key_value(generic_any_1 : T, current : T, key : vx_core.Type_string, value : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_any_key_value.IFn) : vx_core.Func_any_from_any_key_value
  }

  class Class_any_from_any_key_value : vx_core.Class_base, Func_any_from_any_key_value {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_any_key_value {
      val output : vx_core.Class_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-key-value", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_key_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_key_value
      return output
    }

    fun IFn(vx_core.Type_any current, vx_core.Type_string key, vx_core.Type_any value) : vx_core.Type_any

    var fn : vx_core.Class_any_from_any_key_value.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_key_value.IFn) : vx_core.Func_any_from_any_key_value {
      val output : vx_core.Class_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_any_key_value(generic_any_1, current, key, value)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_any_key_value(T generic_any_1, T current, vx_core.Type_string key, U value) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(current, key, value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_any_key_value : vx_core.Func_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
  val t_any_from_any_key_value : vx_core.Func_any_from_any_key_value = vx_core.Class_any_from_any_key_value()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_key_value(generic_any_1 : T, current : T, key : vx_core.Type_string, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_any_from_func(generic_any_1 : T) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_any_from_func
  }

  class Class_any_from_func : vx_core.Class_base, Func_any_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_func {
      val output : vx_core.Class_any_from_func = vx_core.Class_any_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_func = vx_core.Class_any_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_func
      return output
    }

    fun IFn() : vx_core.Type_any

    var fn : vx_core.Class_any_from_func.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_any_from_func {
      val output : vx_core.Class_any_from_func = vx_core.Class_any_from_func()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_func(generic_any_1)
      return output
    }

    fun <T : vx_core.Type_any> T vx_any_from_func(T generic_any_1) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn()
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_func : vx_core.Func_any_from_func = vx_core.Class_any_from_func()
  val t_any_from_func : vx_core.Func_any_from_func = vx_core.Class_any_from_func()

  fun <T : vx_core.Type_any> f_any_from_func(generic_any_1 : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_func_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any> vx_any_from_func_async(generic_any_1 : T) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_func_async.IFn) : vx_core.Func_any_from_func_async
  }

  class Class_any_from_func_async : vx_core.Class_base, Func_any_from_func_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_func_async {
      val output : vx_core.Class_any_from_func_async = vx_core.Class_any_from_func_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_func_async = vx_core.Class_any_from_func_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-func-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_func_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_func_async
      return output
    }

    fun IFn() : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_func_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_func_async.IFn) : vx_core.Func_any_from_func_async {
      val output : vx_core.Class_any_from_func_async = vx_core.Class_any_from_func_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_any_from_func_async(generic_any_1)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any> <T> vx_any_from_func_async(T generic_any_1) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn()
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_func_async : vx_core.Func_any_from_func_async = vx_core.Class_any_from_func_async()
  val t_any_from_func_async : vx_core.Func_any_from_func_async = vx_core.Class_any_from_func_async()

  fun <T : vx_core.Type_any> f_any_from_func_async(generic_any_1 : T) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_int : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_any_from_int(generic_any_1 : T, value : vx_core.Type_int) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_int.IFn) : vx_core.Func_any_from_int
  }

  class Class_any_from_int : vx_core.Class_base, Func_any_from_int {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_int {
      val output : vx_core.Class_any_from_int = vx_core.Class_any_from_int()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_int = vx_core.Class_any_from_int()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-int", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_int
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_int
      return output
    }

    fun IFn(vx_core.Type_int value) : vx_core.Type_any

    var fn : vx_core.Class_any_from_int.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_int.IFn) : vx_core.Func_any_from_int {
      val output : vx_core.Class_any_from_int = vx_core.Class_any_from_int()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_int(generic_any_1, value)
      return output
    }

    fun <T : vx_core.Type_any> T vx_any_from_int(T generic_any_1, vx_core.Type_int value) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_int : vx_core.Func_any_from_int = vx_core.Class_any_from_int()
  val t_any_from_int : vx_core.Func_any_from_int = vx_core.Class_any_from_int()

  fun <T : vx_core.Type_any> f_any_from_int(generic_any_1 : T, value : vx_core.Type_int) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_int_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_int_any(generic_any_1 : T, num : vx_core.Type_int, val : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_int_any.IFn) : vx_core.Func_any_from_int_any
  }

  class Class_any_from_int_any : vx_core.Class_base, Func_any_from_int_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_int_any {
      val output : vx_core.Class_any_from_int_any = vx_core.Class_any_from_int_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_int_any = vx_core.Class_any_from_int_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-int-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_int_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_int_any
      return output
    }

    fun IFn(vx_core.Type_int num, vx_core.Type_any val) : vx_core.Type_any

    var fn : vx_core.Class_any_from_int_any.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_int_any.IFn) : vx_core.Func_any_from_int_any {
      val output : vx_core.Class_any_from_int_any = vx_core.Class_any_from_int_any()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_int_any(generic_any_1, num, val)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_int_any(T generic_any_1, vx_core.Type_int num, U val) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(num, val)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_int_any : vx_core.Func_any_from_int_any = vx_core.Class_any_from_int_any()
  val t_any_from_int_any : vx_core.Func_any_from_int_any = vx_core.Class_any_from_int_any()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_int_any(generic_any_1 : T, num : vx_core.Type_int, val : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_key_value : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_key_value(generic_any_1 : T, key : vx_core.Type_string, val : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_key_value.IFn) : vx_core.Func_any_from_key_value
  }

  class Class_any_from_key_value : vx_core.Class_base, Func_any_from_key_value {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_key_value {
      val output : vx_core.Class_any_from_key_value = vx_core.Class_any_from_key_value()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_key_value = vx_core.Class_any_from_key_value()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_key_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_key_value
      return output
    }

    fun IFn(vx_core.Type_string key, vx_core.Type_any val) : vx_core.Type_any

    var fn : vx_core.Class_any_from_key_value.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_key_value.IFn) : vx_core.Func_any_from_key_value {
      val output : vx_core.Class_any_from_key_value = vx_core.Class_any_from_key_value()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_key_value(generic_any_1, key, val)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_key_value(T generic_any_1, vx_core.Type_string key, U val) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(key, val)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.Class_any_from_key_value()
  val t_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.Class_any_from_key_value()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_key_value(generic_any_1 : T, key : vx_core.Type_string, val : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_key_value_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_key_value_async(generic_any_1 : T, key : vx_core.Type_string, val : U) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_key_value_async.IFn) : vx_core.Func_any_from_key_value_async
  }

  class Class_any_from_key_value_async : vx_core.Class_base, Func_any_from_key_value_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_key_value_async {
      val output : vx_core.Class_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_key_value_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_key_value_async
      return output
    }

    fun IFn(vx_core.Type_string key, vx_core.Type_any val) : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_key_value_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_key_value_async.IFn) : vx_core.Func_any_from_key_value_async {
      val output : vx_core.Class_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : vx_core.Type_any = await vx_core.f_any_from_key_value_async(generic_any_1, key, val)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> <T> vx_any_from_key_value_async(T generic_any_1, vx_core.Type_string key, U val) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn(key, val)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_key_value_async : vx_core.Func_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
  val t_any_from_key_value_async : vx_core.Func_any_from_key_value_async = vx_core.Class_any_from_key_value_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_key_value_async(generic_any_1 : T, key : vx_core.Type_string, val : U) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_list : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_any_from_list(generic_any_1 : T, values : X, index : vx_core.Type_int) : T
  }

  class Class_any_from_list : vx_core.Class_base, Func_any_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_list {
      val output : vx_core.Class_any_from_list = vx_core.Class_any_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list = vx_core.Class_any_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_list
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var index : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_list(generic_any_1, values, index)
      return output
    }

    fun <T : vx_core.Type_any, X : vx_core.Type_list> T vx_any_from_list(T generic_any_1, X values, vx_core.Type_int index) {
      return vx_core.f_any_from_list(generic_any_1, values, index)
    }

  }

  val e_any_from_list : vx_core.Func_any_from_list = vx_core.Class_any_from_list()
  val t_any_from_list : vx_core.Func_any_from_list = vx_core.Class_any_from_list()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_any_from_list(generic_any_1 : T, values : X, index : vx_core.Type_int) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val intindex : int = index.vx_int()
    val intsize : int = values.vx_list().size()
    if (intindex <= intsize) {
      val listvalue : List<vx_core.Type_any> = values.vx_list()
      val value : vx_core.Type_any = listvalue.get(intindex - 1)
      output = vx_core.f_any_from_any(generic_any_1, value)
    }
    return output
  }


  interface Func_any_from_list_start_reduce : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, Y : vx_core.Type_list> vx_any_from_list_start_reduce(generic_any_1 : T, list : Y, valstart : T, fn_reduce : vx_core.Func_any_from_reduce) : T
  }

  class Class_any_from_list_start_reduce : vx_core.Class_base, Func_any_from_list_start_reduce {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_list_start_reduce {
      val output : vx_core.Class_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_list_start_reduce
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_list_start_reduce
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var list : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valstart : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var fn_reduce : vx_core.Func_any_from_reduce = vx_core.f_any_from_any(vx_core.t_any_from_reduce, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce)
      return output
    }

    fun <T : vx_core.Type_any, Y : vx_core.Type_list> T vx_any_from_list_start_reduce(T generic_any_1, Y list, T valstart, vx_core.Func_any_from_reduce fn_reduce) {
      return vx_core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce)
    }

  }

  val e_any_from_list_start_reduce : vx_core.Func_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()
  val t_any_from_list_start_reduce : vx_core.Func_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()

  fun <T : vx_core.Type_any, Y : vx_core.Type_list> f_any_from_list_start_reduce(generic_any_1 : T, list : Y, valstart : T, fn_reduce : vx_core.Func_any_from_reduce) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce)
    return output
  }


  interface Func_any_from_list_start_reduce_next : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, Y : vx_core.Type_list> vx_any_from_list_start_reduce_next(generic_any_1 : T, list : Y, valstart : T, fn_reduce_next : vx_core.Func_any_from_reduce_next) : T
  }

  class Class_any_from_list_start_reduce_next : vx_core.Class_base, Func_any_from_list_start_reduce_next {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_list_start_reduce_next {
      val output : vx_core.Class_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce-next", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_list_start_reduce_next
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_list_start_reduce_next
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var list : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valstart : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var fn_reduce_next : vx_core.Func_any_from_reduce_next = vx_core.f_any_from_any(vx_core.t_any_from_reduce_next, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next)
      return output
    }

    fun <T : vx_core.Type_any, Y : vx_core.Type_list> T vx_any_from_list_start_reduce_next(T generic_any_1, Y list, T valstart, vx_core.Func_any_from_reduce_next fn_reduce_next) {
      return vx_core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next)
    }

  }

  val e_any_from_list_start_reduce_next : vx_core.Func_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()
  val t_any_from_list_start_reduce_next : vx_core.Func_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()

  fun <T : vx_core.Type_any, Y : vx_core.Type_list> f_any_from_list_start_reduce_next(generic_any_1 : T, list : Y, valstart : T, fn_reduce_next : vx_core.Func_any_from_reduce_next) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_map : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, T : vx_core.Type_any> vx_any_from_map(generic_any_1 : T, valuemap : N, key : vx_core.Type_string) : T
  }

  class Class_any_from_map : vx_core.Class_base, Func_any_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_map {
      val output : vx_core.Class_any_from_map = vx_core.Class_any_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_map = vx_core.Class_any_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_map
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_map(generic_any_1, valuemap, key)
      return output
    }

    fun <N : vx_core.Type_map, T : vx_core.Type_any> T vx_any_from_map(T generic_any_1, N valuemap, vx_core.Type_string key) {
      return vx_core.f_any_from_map(generic_any_1, valuemap, key)
    }

  }

  val e_any_from_map : vx_core.Func_any_from_map = vx_core.Class_any_from_map()
  val t_any_from_map : vx_core.Func_any_from_map = vx_core.Class_any_from_map()

  fun <N : vx_core.Type_map, T : vx_core.Type_any> f_any_from_map(generic_any_1 : T, valuemap : N, key : vx_core.Type_string) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_map(generic_any_1, valuemap, key)
    return output
  }


  interface Func_any_from_map_start_reduce : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, T : vx_core.Type_any> vx_any_from_map_start_reduce(generic_any_1 : T, map : N, start : T, fn_reduce : vx_core.Func_any_from_any_key_value) : T
  }

  class Class_any_from_map_start_reduce : vx_core.Class_base, Func_any_from_map_start_reduce {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_map_start_reduce {
      val output : vx_core.Class_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-map-start-reduce", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_map_start_reduce
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_map_start_reduce
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var map : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var start : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var fn_reduce : vx_core.Func_any_from_any_key_value = vx_core.f_any_from_any(vx_core.t_any_from_any_key_value, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce)
      return output
    }

    fun <N : vx_core.Type_map, T : vx_core.Type_any> T vx_any_from_map_start_reduce(T generic_any_1, N map, T start, vx_core.Func_any_from_any_key_value fn_reduce) {
      return vx_core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce)
    }

  }

  val e_any_from_map_start_reduce : vx_core.Func_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()
  val t_any_from_map_start_reduce : vx_core.Func_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()

  fun <N : vx_core.Type_map, T : vx_core.Type_any> f_any_from_map_start_reduce(generic_any_1 : T, map : N, start : T, fn_reduce : vx_core.Func_any_from_any_key_value) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce)
    return output
  }


  interface Func_any_from_none : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_any_from_none(generic_any_1 : T) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_none.IFn) : vx_core.Func_any_from_none
  }

  class Class_any_from_none : vx_core.Class_base, Func_any_from_none {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_none {
      val output : vx_core.Class_any_from_none = vx_core.Class_any_from_none()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_none = vx_core.Class_any_from_none()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-none", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_none
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_none
      return output
    }

    fun IFn() : vx_core.Type_any

    var fn : vx_core.Class_any_from_none.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_none.IFn) : vx_core.Func_any_from_none {
      val output : vx_core.Class_any_from_none = vx_core.Class_any_from_none()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_none(generic_any_1)
      return output
    }

    fun <T : vx_core.Type_any> T vx_any_from_none(T generic_any_1) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn()
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_none : vx_core.Func_any_from_none = vx_core.Class_any_from_none()
  val t_any_from_none : vx_core.Func_any_from_none = vx_core.Class_any_from_none()

  fun <T : vx_core.Type_any> f_any_from_none(generic_any_1 : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_none_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any> vx_any_from_none_async(generic_any_1 : T) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_none_async.IFn) : vx_core.Func_any_from_none_async
  }

  class Class_any_from_none_async : vx_core.Class_base, Func_any_from_none_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_none_async {
      val output : vx_core.Class_any_from_none_async = vx_core.Class_any_from_none_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_none_async = vx_core.Class_any_from_none_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-none-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_none_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_none_async
      return output
    }

    fun IFn() : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_none_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_none_async.IFn) : vx_core.Func_any_from_none_async {
      val output : vx_core.Class_any_from_none_async = vx_core.Class_any_from_none_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_any_from_none_async(generic_any_1)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any> <T> vx_any_from_none_async(T generic_any_1) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn()
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_none_async : vx_core.Func_any_from_none_async = vx_core.Class_any_from_none_async()
  val t_any_from_none_async : vx_core.Func_any_from_none_async = vx_core.Class_any_from_none_async()

  fun <T : vx_core.Type_any> f_any_from_none_async(generic_any_1 : T) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_reduce : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce(generic_any_1 : T, result : T, item : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_reduce.IFn) : vx_core.Func_any_from_reduce
  }

  class Class_any_from_reduce : vx_core.Class_base, Func_any_from_reduce {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_reduce {
      val output : vx_core.Class_any_from_reduce = vx_core.Class_any_from_reduce()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce = vx_core.Class_any_from_reduce()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce
      return output
    }

    fun IFn(vx_core.Type_any result, vx_core.Type_any item) : vx_core.Type_any

    var fn : vx_core.Class_any_from_reduce.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_reduce.IFn) : vx_core.Func_any_from_reduce {
      val output : vx_core.Class_any_from_reduce = vx_core.Class_any_from_reduce()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var item : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_reduce(generic_any_1, result, item)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_reduce(T generic_any_1, T result, U item) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(result, item)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_reduce : vx_core.Func_any_from_reduce = vx_core.Class_any_from_reduce()
  val t_any_from_reduce : vx_core.Func_any_from_reduce = vx_core.Class_any_from_reduce()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce(generic_any_1 : T, result : T, item : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_reduce_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_async(generic_any_1 : T, result : T, item : U) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_reduce_async.IFn) : vx_core.Func_any_from_reduce_async
  }

  class Class_any_from_reduce_async : vx_core.Class_base, Func_any_from_reduce_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_reduce_async {
      val output : vx_core.Class_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce_async
      return output
    }

    fun IFn(vx_core.Type_any result, vx_core.Type_any item) : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_reduce_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_reduce_async.IFn) : vx_core.Func_any_from_reduce_async {
      val output : vx_core.Class_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var item : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : vx_core.Type_any = await vx_core.f_any_from_reduce_async(generic_any_1, result, item)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> <T> vx_any_from_reduce_async(T generic_any_1, T result, U item) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn(result, item)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_reduce_async : vx_core.Func_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
  val t_any_from_reduce_async : vx_core.Func_any_from_reduce_async = vx_core.Class_any_from_reduce_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce_async(generic_any_1 : T, result : T, item : U) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_reduce_next : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_next(generic_any_1 : T, result : T, current : U, next : U) : T
    fun vx_fn_new(fn : vx_core.Class_any_from_reduce_next.IFn) : vx_core.Func_any_from_reduce_next
  }

  class Class_any_from_reduce_next : vx_core.Class_base, Func_any_from_reduce_next {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_reduce_next {
      val output : vx_core.Class_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce_next
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce_next
      return output
    }

    fun IFn(vx_core.Type_any result, vx_core.Type_any current, vx_core.Type_any next) : vx_core.Type_any

    var fn : vx_core.Class_any_from_reduce_next.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_reduce_next.IFn) : vx_core.Func_any_from_reduce_next {
      val output : vx_core.Class_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_reduce_next(generic_any_1, result, current, next)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_any_from_reduce_next(T generic_any_1, T result, U current, U next) {
      var output : T = vx_core.f_empty(generic_any_1)
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(result, current, next)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_reduce_next : vx_core.Func_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
  val t_any_from_reduce_next : vx_core.Func_any_from_reduce_next = vx_core.Class_any_from_reduce_next()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce_next(generic_any_1 : T, result : T, current : U, next : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_reduce_next_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_next_async(generic_any_1 : T, result : T, current : U, next : U) : <T>
    fun vx_fn_new(fn : vx_core.Class_any_from_reduce_next_async.IFn) : vx_core.Func_any_from_reduce_next_async
  }

  class Class_any_from_reduce_next_async : vx_core.Class_base, Func_any_from_reduce_next_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_reduce_next_async {
      val output : vx_core.Class_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce_next_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce_next_async
      return output
    }

    fun IFn(vx_core.Type_any result, vx_core.Type_any current, vx_core.Type_any next) : <vx_core.Type_any>

    var fn : vx_core.Class_any_from_reduce_next_async.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_reduce_next_async.IFn) : vx_core.Func_any_from_reduce_next_async {
      val output : vx_core.Class_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      var future : vx_core.Type_any = await vx_core.f_any_from_reduce_next_async(generic_any_1, result, current, next)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> <T> vx_any_from_reduce_next_async(T generic_any_1, T result, U current, U next) {
      var output : T
      if (fn == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : vx_core.Type_any = await fn(result, current, next)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_reduce_next_async : vx_core.Func_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
  val t_any_from_reduce_next_async : vx_core.Func_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce_next_async(generic_any_1 : T, result : T, current : U, next : U) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_struct : vx_core.Type_func, vx_core.Type_replfunc {
    fun <R : vx_core.Type_struct, T : vx_core.Type_any> vx_any_from_struct(generic_any_1 : T, vstruct : R, key : vx_core.Type_string) : T
  }

  class Class_any_from_struct : vx_core.Class_base, Func_any_from_struct {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_any_from_struct {
      val output : vx_core.Class_any_from_struct = vx_core.Class_any_from_struct()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_struct = vx_core.Class_any_from_struct()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-struct", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_struct
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_struct
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var vstruct : vx_core.Type_struct = vx_core.f_any_from_any(vx_core.t_struct, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_struct(generic_any_1, vstruct, key)
      return output
    }

    fun <R : vx_core.Type_struct, T : vx_core.Type_any> T vx_any_from_struct(T generic_any_1, R vstruct, vx_core.Type_string key) {
      return vx_core.f_any_from_struct(generic_any_1, vstruct, key)
    }

  }

  val e_any_from_struct : vx_core.Func_any_from_struct = vx_core.Class_any_from_struct()
  val t_any_from_struct : vx_core.Func_any_from_struct = vx_core.Class_any_from_struct()

  fun <R : vx_core.Type_struct, T : vx_core.Type_any> f_any_from_struct(generic_any_1 : T, vstruct : R, key : vx_core.Type_string) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val value : vx_core.Type_any = vstruct.vx_any(key)
    output = vx_core.f_any_from_any(generic_any_1, value);
    return output
  }


  interface Func_async : vx_core.Func_any_from_any_async {
    fun <T : vx_core.Type_any> vx_async(generic_any_1 : T, value : T) : <T>
  }

  class Class_async : vx_core.Class_base, Func_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_async {
      val output : vx_core.Class_async = vx_core.Class_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_async = vx_core.Class_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_async
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async {
      return vx_core.e_any_from_any_async
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : <T> {
      T inputval = vx_core.f_any_from_any(generic_any_1, value)
      <T> output = vx_core.f_async(generic_any_1, inputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_async(generic_any_1, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any> <T> vx_async(T generic_any_1, T value) {
      return vx_core.f_async(generic_any_1, value)
    }

  }

  val e_async : vx_core.Func_async = vx_core.Class_async()
  val t_async : vx_core.Func_async = vx_core.Class_async()

  fun <T : vx_core.Type_any> f_async(generic_any_1 : T, value : T) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    output = vx_core.vx_async_new_from_value(value)
    return output
  }


  interface Func_boolean_permission_from_func : vx_core.Func_any_from_any_context {
    fun vx_boolean_permission_from_func(context : vx_core.Type_context, func : vx_core.Type_func) : vx_core.Type_boolean
  }

  class Class_boolean_permission_from_func : vx_core.Class_base, Func_boolean_permission_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_boolean_permission_from_func {
      val output : vx_core.Class_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean-permission<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_permission_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_permission_from_func
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_func = value as vx_core.Type_func
      var outputval : vx_core.Type_any = vx_core.f_boolean_permission_from_func(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var func : vx_core.Type_func = vx_core.f_any_from_any(vx_core.t_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_boolean_permission_from_func(context, func)
      return output
    }

    fun vx_core.Type_boolean vx_boolean_permission_from_func(vx_core.Type_context context, vx_core.Type_func func) {
      return vx_core.f_boolean_permission_from_func(context, func)
    }

  }

  val e_boolean_permission_from_func : vx_core.Func_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()
  val t_boolean_permission_from_func : vx_core.Func_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()

  fun f_boolean_permission_from_func(context : vx_core.Type_context, func : vx_core.Type_func) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_contains_1(
      vx_core.f_allowfuncs_from_security(
        vx_core.f_security_from_context(context)
      ),
      func
    )
    return output
  }


  interface Func_boolean_write_from_map_name_value : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_write_from_map_name_value(valuemap : vx_core.Type_map, name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_boolean_write_from_map_name_value : vx_core.Class_base, Func_boolean_write_from_map_name_value {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_boolean_write_from_map_name_value {
      val output : vx_core.Class_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean-write<-map-name-value", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_write_from_map_name_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_write_from_map_name_value
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var name : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_boolean_write_from_map_name_value(valuemap, name, value)
      return output
    }

    fun vx_core.Type_boolean vx_boolean_write_from_map_name_value(vx_core.Type_map valuemap, vx_core.Type_string name, vx_core.Type_any value) {
      return vx_core.f_boolean_write_from_map_name_value(valuemap, name, value)
    }

  }

  val e_boolean_write_from_map_name_value : vx_core.Func_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()
  val t_boolean_write_from_map_name_value : vx_core.Func_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()

  fun f_boolean_write_from_map_name_value(valuemap : vx_core.Type_map, name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.vx_boolean_write_from_map_name_value(valuemap, name, value)
    return output
  }


  interface Func_boolean_from_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_from_any(value : vx_core.Type_any) : vx_core.Type_boolean
    fun vx_fn_new(fn : vx_core.Class_boolean_from_any.IFn) : vx_core.Func_boolean_from_any
  }

  class Class_boolean_from_any : vx_core.Class_base, Func_boolean_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_boolean_from_any {
      val output : vx_core.Class_boolean_from_any = vx_core.Class_boolean_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_any = vx_core.Class_boolean_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_from_any
      return output
    }

    fun IFn(vx_core.Type_any value) : vx_core.Type_any

    var fn : vx_core.Class_boolean_from_any.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_boolean_from_any.IFn) : vx_core.Func_boolean_from_any {
      val output : vx_core.Class_boolean_from_any = vx_core.Class_boolean_from_any()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_boolean_from_any(value)
      return output
    }

    fun vx_core.Type_boolean vx_boolean_from_any(vx_core.Type_any value) {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn(value)
        output = vx_core.f_any_from_any(vx_core.t_boolean, anyoutput)
      }
      return output
    }

  }

  val e_boolean_from_any : vx_core.Func_boolean_from_any = vx_core.Class_boolean_from_any()
  val t_boolean_from_any : vx_core.Func_boolean_from_any = vx_core.Class_boolean_from_any()

  fun f_boolean_from_any(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_boolean_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_from_func() : vx_core.Type_boolean
    fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_boolean_from_func
  }

  class Class_boolean_from_func : vx_core.Class_base, Func_boolean_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_boolean_from_func {
      val output : vx_core.Class_boolean_from_func = vx_core.Class_boolean_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_func = vx_core.Class_boolean_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_from_func
      return output
    }

    fun IFn() : vx_core.Type_any

    var fn : vx_core.Class_any_from_func.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_boolean_from_func {
      val output : vx_core.Class_boolean_from_func = vx_core.Class_boolean_from_func()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_boolean_from_func()
      return output
    }

    fun vx_core.Type_boolean vx_boolean_from_func() {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn()
        output = vx_core.f_any_from_any(vx_core.t_boolean, anyoutput)
      }
      return output
    }

  }

  val e_boolean_from_func : vx_core.Func_boolean_from_func = vx_core.Class_boolean_from_func()
  val t_boolean_from_func : vx_core.Func_boolean_from_func = vx_core.Class_boolean_from_func()

  fun f_boolean_from_func() : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_boolean_from_none : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_from_none() : vx_core.Type_boolean
    fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_boolean_from_none
  }

  class Class_boolean_from_none : vx_core.Class_base, Func_boolean_from_none {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_boolean_from_none {
      val output : vx_core.Class_boolean_from_none = vx_core.Class_boolean_from_none()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_none = vx_core.Class_boolean_from_none()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-none", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_from_none
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_from_none
      return output
    }

    fun IFn() : vx_core.Type_any

    var fn : vx_core.Class_any_from_func.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_boolean_from_none {
      val output : vx_core.Class_boolean_from_none = vx_core.Class_boolean_from_none()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_boolean_from_none()
      return output
    }

    fun vx_core.Type_boolean vx_boolean_from_none() {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (fn != null) {
        var anyoutput : vx_core.Type_any = fn()
        output = vx_core.f_any_from_any(vx_core.t_boolean, anyoutput)
      }
      return output
    }

  }

  val e_boolean_from_none : vx_core.Func_boolean_from_none = vx_core.Class_boolean_from_none()
  val t_boolean_from_none : vx_core.Func_boolean_from_none = vx_core.Class_boolean_from_none()

  fun f_boolean_from_none() : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_case : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_case(values : vx_core.Type_list, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_case : vx_core.Class_base, Func_case {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_case {
      val output : vx_core.Class_case = vx_core.Class_case()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_case = vx_core.Class_case()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_case
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_case
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_case(values, fn_any)
      return output
    }

    fun vx_core.Type_thenelse vx_case(vx_core.Type_list values, vx_core.Func_any_from_func fn_any) {
      return vx_core.f_case(values, fn_any)
    }

  }

  val e_case : vx_core.Func_case = vx_core.Class_case()
  val t_case : vx_core.Func_case = vx_core.Class_case()

  fun f_case(values : vx_core.Type_list, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":casemany"),
        vx_core.vx_new_string(":values"),
        values,
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_case_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_case_1(value : vx_core.Type_any, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_case_1 : vx_core.Class_base, Func_case_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_case_1 {
      val output : vx_core.Class_case_1 = vx_core.Class_case_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_case_1 = vx_core.Class_case_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_case_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_case_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_case_1(value, fn_any)
      return output
    }

    fun vx_core.Type_thenelse vx_case_1(vx_core.Type_any value, vx_core.Func_any_from_func fn_any) {
      return vx_core.f_case_1(value, fn_any)
    }

  }

  val e_case_1 : vx_core.Func_case_1 = vx_core.Class_case_1()
  val t_case_1 : vx_core.Func_case_1 = vx_core.Class_case_1()

  fun f_case_1(value : vx_core.Type_any, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":case"),
        vx_core.vx_new_string(":value"),
        value,
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_compare : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_compare(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_int
  }

  class Class_compare : vx_core.Class_base, Func_compare {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_compare {
      val output : vx_core.Class_compare = vx_core.Class_compare()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_compare = vx_core.Class_compare()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "compare", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_compare
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_compare
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_compare(val1, val2)
      return output
    }

    fun vx_core.Type_int vx_compare(vx_core.Type_any val1, vx_core.Type_any val2) {
      return vx_core.f_compare(val1, val2)
    }

  }

  val e_compare : vx_core.Func_compare = vx_core.Class_compare()
  val t_compare : vx_core.Func_compare = vx_core.Class_compare()

  fun f_compare(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.vx_compare(val1, val2)
    return output
  }


  interface Func_contains : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_contains(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_contains : vx_core.Class_base, Func_contains {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_contains {
      val output : vx_core.Class_contains = vx_core.Class_contains()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_contains = vx_core.Class_contains()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_contains
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_contains
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_contains(text, find)
      return output
    }

    fun vx_core.Type_boolean vx_contains(vx_core.Type_string text, vx_core.Type_string find) {
      return vx_core.f_contains(text, find)
    }

  }

  val e_contains : vx_core.Func_contains = vx_core.Class_contains()
  val t_contains : vx_core.Func_contains = vx_core.Class_contains()

  fun f_contains(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val check : Boolean = vx_boolean_from_string_find(
      text.vx_string(),
      find.vx_string())
    output = vx_core.vx_new_boolean(check)
    return output
  }


  interface Func_contains_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_contains_1(values : vx_core.Type_list, find : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_contains_1 : vx_core.Class_base, Func_contains_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_contains_1 {
      val output : vx_core.Class_contains_1 = vx_core.Class_contains_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_contains_1 = vx_core.Class_contains_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_contains_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_contains_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_contains_1(values, find)
      return output
    }

    fun vx_core.Type_boolean vx_contains_1(vx_core.Type_list values, vx_core.Type_any find) {
      return vx_core.f_contains_1(values, find)
    }

  }

  val e_contains_1 : vx_core.Func_contains_1 = vx_core.Class_contains_1()
  val t_contains_1 : vx_core.Func_contains_1 = vx_core.Class_contains_1()

  fun f_contains_1(values : vx_core.Type_list, find : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.vx_contains_1(values, find)
    return output
  }


  interface Func_context_main : vx_core.Func_any_from_any {
    fun vx_context_main(args : vx_core.Type_anylist) : vx_core.Type_context
  }

  class Class_context_main : vx_core.Class_base, Func_context_main {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_context_main {
      val output : vx_core.Class_context_main = vx_core.Class_context_main()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_context_main = vx_core.Class_context_main()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "context-main", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "context", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_context_main
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_context_main
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_context_main(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_context_main(args)
      return output
    }

    fun vx_core.Type_context vx_context_main(vx_core.Type_anylist args) {
      return vx_core.f_context_main(args)
    }

  }

  val e_context_main : vx_core.Func_context_main = vx_core.Class_context_main()
  val t_context_main : vx_core.Func_context_main = vx_core.Class_context_main()

  fun f_context_main(args : vx_core.Type_anylist) : vx_core.Type_context {
    var output : vx_core.Type_context = vx_core.e_context
    output = vx_core.f_empty(
      vx_core.t_context
    )
    return output
  }


  interface Func_copy : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_copy(value : T, values : vx_core.Type_anylist) : T
  }

  class Class_copy : vx_core.Class_base, Func_copy {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_copy {
      val output : vx_core.Class_copy = vx_core.Class_copy()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_copy = vx_core.Class_copy()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "copy", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_copy
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_copy
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_copy(value, values)
      return output
    }

    fun <T : vx_core.Type_any> T vx_copy(T value, vx_core.Type_anylist values) {
      return vx_core.f_copy(value, values)
    }

  }

  val e_copy : vx_core.Func_copy = vx_core.Class_copy()
  val t_copy : vx_core.Func_copy = vx_core.Class_copy()

  fun <T : vx_core.Type_any> f_copy(value : T, values : vx_core.Type_anylist) : T {
    val arrayany : vx_core.Type_any[] = vx_core.arrayany_from_anylist(
      values)
    val arrayobj : Any[] = arrayany as vx_core.Type_any[]
    T output = (T)(value.vx_copy(arrayobj))
    return output
  }


  interface Func_else : vx_core.Func_any_from_any {
    fun vx_else(fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_else : vx_core.Class_base, Func_else {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_else {
      val output : vx_core.Class_else = vx_core.Class_else()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_else = vx_core.Class_else()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "else", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_else
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_else
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Func_any_from_func = value as vx_core.Func_any_from_func
      var outputval : vx_core.Type_any = vx_core.f_else(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_else(fn_any)
      return output
    }

    fun vx_core.Type_thenelse vx_else(vx_core.Func_any_from_func fn_any) {
      return vx_core.f_else(fn_any)
    }

  }

  val e_else : vx_core.Func_else = vx_core.Class_else()
  val t_else : vx_core.Func_else = vx_core.Class_else()

  fun f_else(fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":else"),
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_empty : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_empty(type : T) : T
  }

  class Class_empty : vx_core.Class_base, Func_empty {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_empty {
      val output : vx_core.Class_empty = vx_core.Class_empty()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_empty = vx_core.Class_empty()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "empty", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_empty
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_empty
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_empty(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_empty(type)
      return output
    }

    fun <T : vx_core.Type_any> T vx_empty(T type) {
      return vx_core.f_empty(type)
    }

  }

  val e_empty : vx_core.Func_empty = vx_core.Class_empty()
  val t_empty : vx_core.Func_empty = vx_core.Class_empty()

  fun <T : vx_core.Type_any> f_empty(type : T) : T {
    val output : T = vx_core.vx_empty(type)
    return output
  }


  interface Func_extends_from_any : vx_core.Func_any_from_any {
    fun vx_extends_from_any(val : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_extends_from_any : vx_core.Class_base, Func_extends_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_extends_from_any {
      val output : vx_core.Class_extends_from_any = vx_core.Class_extends_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_extends_from_any = vx_core.Class_extends_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "extends<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_extends_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_extends_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_extends_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_extends_from_any(val)
      return output
    }

    fun vx_core.Type_string vx_extends_from_any(vx_core.Type_any val) {
      return vx_core.f_extends_from_any(val)
    }

  }

  val e_extends_from_any : vx_core.Func_extends_from_any = vx_core.Class_extends_from_any()
  val t_extends_from_any : vx_core.Func_extends_from_any = vx_core.Class_extends_from_any()

  fun f_extends_from_any(val : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_extends_from_typedef(
      vx_core.f_typedef_from_any(val)
    )
    return output
  }


  interface Func_extends_from_typedef : vx_core.Func_any_from_any {
    fun vx_extends_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_extends_from_typedef : vx_core.Class_base, Func_extends_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_extends_from_typedef {
      val output : vx_core.Class_extends_from_typedef = vx_core.Class_extends_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_extends_from_typedef = vx_core.Class_extends_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "extends<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_extends_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_extends_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_extends_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_extends_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_string vx_extends_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_extends_from_typedef(vtypedef)
    }

  }

  val e_extends_from_typedef : vx_core.Func_extends_from_typedef = vx_core.Class_extends_from_typedef()
  val t_extends_from_typedef : vx_core.Func_extends_from_typedef = vx_core.Class_extends_from_typedef()

  fun f_extends_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vtypedef.extend()
    return output
  }


  interface Func_first_from_list : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_first_from_list(generic_any_1 : T, values : X) : T
  }

  class Class_first_from_list : vx_core.Class_base, Func_first_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_first_from_list {
      val output : vx_core.Class_first_from_list = vx_core.Class_first_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_first_from_list = vx_core.Class_first_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "first<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_first_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_first_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_first_from_list(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_first_from_list(generic_any_1, values)
      return output
    }

    fun <T : vx_core.Type_any, X : vx_core.Type_list> T vx_first_from_list(T generic_any_1, X values) {
      return vx_core.f_first_from_list(generic_any_1, values)
    }

  }

  val e_first_from_list : vx_core.Func_first_from_list = vx_core.Class_first_from_list()
  val t_first_from_list : vx_core.Func_first_from_list = vx_core.Class_first_from_list()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_first_from_list(generic_any_1 : T, values : X) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.f_any_from_list(generic_any_1, values, vx_core.vx_new_int(1))
    return output
  }


  interface Func_first_from_list_any_from_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_first_from_list_any_from_any(generic_any_1 : T, values : X, fn_any_from_any : vx_core.Func_any_from_any) : T
  }

  class Class_first_from_list_any_from_any : vx_core.Class_base, Func_first_from_list_any_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_first_from_list_any_from_any {
      val output : vx_core.Class_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "first<-list-any<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_first_from_list_any_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_first_from_list_any_from_any
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any)
      return output
    }

    fun <T : vx_core.Type_any, X : vx_core.Type_list> T vx_first_from_list_any_from_any(T generic_any_1, X values, vx_core.Func_any_from_any fn_any_from_any) {
      return vx_core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any)
    }

  }

  val e_first_from_list_any_from_any : vx_core.Func_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()
  val t_first_from_list_any_from_any : vx_core.Func_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_first_from_list_any_from_any(generic_any_1 : T, values : X, fn_any_from_any : vx_core.Func_any_from_any) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val listvalue : List<vx_core.Type_any> = values.vx_list()
    for (value : vx_core.Type_any in listvalue) {
      if (value != vx_core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value)
        break
      }
    }
    return output
  }


  interface Func_float_from_string : vx_core.Func_any_from_any {
    fun vx_float_from_string(text : vx_core.Type_string) : vx_core.Type_float
  }

  class Class_float_from_string : vx_core.Class_base, Func_float_from_string {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_float_from_string {
      val output : vx_core.Class_float_from_string = vx_core.Class_float_from_string()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_float_from_string = vx_core.Class_float_from_string()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "float<-string", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "float", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_float_from_string
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_float_from_string
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_float_from_string(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_float_from_string(text)
      return output
    }

    fun vx_core.Type_float vx_float_from_string(vx_core.Type_string text) {
      return vx_core.f_float_from_string(text)
    }

  }

  val e_float_from_string : vx_core.Func_float_from_string = vx_core.Class_float_from_string()
  val t_float_from_string : vx_core.Func_float_from_string = vx_core.Class_float_from_string()

  fun f_float_from_string(text : vx_core.Type_string) : vx_core.Type_float {
    var output : vx_core.Type_float = vx_core.e_float
    val num : float = vx_core.vx_float_from_string(text.vx_string())
    output = vx_core.vx_new_float(num)
    return output
  }


  interface Func_fn : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_fn(generic_any_1 : T, parameters : vx_core.Type_arglist, fn_any : vx_core.Func_any_from_func) : T
  }

  class Class_fn : vx_core.Class_base, Func_fn {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_fn {
      val output : vx_core.Class_fn = vx_core.Class_fn()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_fn = vx_core.Class_fn()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "fn", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_fn
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var parameters : vx_core.Type_arglist = vx_core.f_any_from_any(vx_core.t_arglist, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_fn(generic_any_1, parameters, fn_any)
      return output
    }

    fun <T : vx_core.Type_any> T vx_fn(T generic_any_1, vx_core.Type_arglist parameters, vx_core.Func_any_from_func fn_any) {
      return vx_core.f_fn(generic_any_1, parameters, fn_any)
    }

  }

  val e_fn : vx_core.Func_fn = vx_core.Class_fn()
  val t_fn : vx_core.Func_fn = vx_core.Class_fn()

  fun <T : vx_core.Type_any> f_fn(generic_any_1 : T, parameters : vx_core.Type_arglist, fn_any : vx_core.Func_any_from_func) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_funcdef_from_func : vx_core.Func_any_from_any {
    fun vx_funcdef_from_func(val : vx_core.Type_func) : vx_core.Type_funcdef
  }

  class Class_funcdef_from_func : vx_core.Class_base, Func_funcdef_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_funcdef_from_func {
      val output : vx_core.Class_funcdef_from_func = vx_core.Class_funcdef_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_funcdef_from_func = vx_core.Class_funcdef_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "funcdef<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "funcdef", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcdef_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcdef_from_func
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_func = value as vx_core.Type_func
      var outputval : vx_core.Type_any = vx_core.f_funcdef_from_func(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_func = vx_core.f_any_from_any(vx_core.t_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_funcdef_from_func(val)
      return output
    }

    fun vx_core.Type_funcdef vx_funcdef_from_func(vx_core.Type_func val) {
      return vx_core.f_funcdef_from_func(val)
    }

  }

  val e_funcdef_from_func : vx_core.Func_funcdef_from_func = vx_core.Class_funcdef_from_func()
  val t_funcdef_from_func : vx_core.Func_funcdef_from_func = vx_core.Class_funcdef_from_func()

  fun f_funcdef_from_func(val : vx_core.Type_func) : vx_core.Type_funcdef {
    var output : vx_core.Type_funcdef = vx_core.e_funcdef
    output = val.vx_funcdef()
    return output
  }


  interface Func_funcname_from_funcdef : vx_core.Func_any_from_any {
    fun vx_funcname_from_funcdef(funcdef : vx_core.Type_funcdef) : vx_core.Type_string
  }

  class Class_funcname_from_funcdef : vx_core.Class_base, Func_funcname_from_funcdef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_funcname_from_funcdef {
      val output : vx_core.Class_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "funcname<-funcdef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcname_from_funcdef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcname_from_funcdef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_funcdef = value as vx_core.Type_funcdef
      var outputval : vx_core.Type_any = vx_core.f_funcname_from_funcdef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var funcdef : vx_core.Type_funcdef = vx_core.f_any_from_any(vx_core.t_funcdef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_funcname_from_funcdef(funcdef)
      return output
    }

    fun vx_core.Type_string vx_funcname_from_funcdef(vx_core.Type_funcdef funcdef) {
      return vx_core.f_funcname_from_funcdef(funcdef)
    }

  }

  val e_funcname_from_funcdef : vx_core.Func_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()
  val t_funcname_from_funcdef : vx_core.Func_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()

  fun f_funcname_from_funcdef(funcdef : vx_core.Type_funcdef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_new(
      vx_core.t_string,
      vx_core.vx_new(
        vx_core.t_anylist,
        funcdef.pkgname(),
        vx_core.vx_new_string("/"),
        funcdef.name()
      )
    )
    return output
  }


  interface Func_if : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_if(generic_any_1 : T, clause : vx_core.Type_boolean, then : T) : T
  }

  class Class_if : vx_core.Class_base, Func_if {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_if {
      val output : vx_core.Class_if = vx_core.Class_if()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if = vx_core.Class_if()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_if
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_if
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clause : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var then : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_if(generic_any_1, clause, then)
      return output
    }

    fun <T : vx_core.Type_any> T vx_if(T generic_any_1, vx_core.Type_boolean clause, T then) {
      return vx_core.f_if(generic_any_1, clause, then)
    }

  }

  val e_if : vx_core.Func_if = vx_core.Class_if()
  val t_if : vx_core.Func_if = vx_core.Class_if()

  fun <T : vx_core.Type_any> f_if(generic_any_1 : T, clause : vx_core.Type_boolean, then : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    if (clause.vx_boolean()) {
      output = then
    }
    return output
  }


  interface Func_if_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_if_1(generic_any_1 : T, clause : vx_core.Type_boolean, thenval : T, elseval : T) : T
  }

  class Class_if_1 : vx_core.Class_base, Func_if_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_if_1 {
      val output : vx_core.Class_if_1 = vx_core.Class_if_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if_1 = vx_core.Class_if_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_if_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_if_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clause : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var thenval : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var elseval : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_if_1(generic_any_1, clause, thenval, elseval)
      return output
    }

    fun <T : vx_core.Type_any> T vx_if_1(T generic_any_1, vx_core.Type_boolean clause, T thenval, T elseval) {
      return vx_core.f_if_1(generic_any_1, clause, thenval, elseval)
    }

  }

  val e_if_1 : vx_core.Func_if_1 = vx_core.Class_if_1()
  val t_if_1 : vx_core.Func_if_1 = vx_core.Class_if_1()

  fun <T : vx_core.Type_any> f_if_1(generic_any_1 : T, clause : vx_core.Type_boolean, thenval : T, elseval : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    if (clause.vx_boolean()) {
      output = thenval
    } else {
      output = elseval
    }
    return output
  }


  interface Func_if_2 : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_if_2(generic_any_1 : T, thenelselist : vx_core.Type_thenelselist) : T
  }

  class Class_if_2 : vx_core.Class_base, Func_if_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_if_2 {
      val output : vx_core.Class_if_2 = vx_core.Class_if_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if_2 = vx_core.Class_if_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_if_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_if_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_thenelselist = value as vx_core.Type_thenelselist
      var outputval : vx_core.Type_any = vx_core.f_if_2(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var thenelselist : vx_core.Type_thenelselist = vx_core.f_any_from_any(vx_core.t_thenelselist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_if_2(generic_any_1, thenelselist)
      return output
    }

    fun <T : vx_core.Type_any> T vx_if_2(T generic_any_1, vx_core.Type_thenelselist thenelselist) {
      return vx_core.f_if_2(generic_any_1, thenelselist)
    }

  }

  val e_if_2 : vx_core.Func_if_2 = vx_core.Class_if_2()
  val t_if_2 : vx_core.Func_if_2 = vx_core.Class_if_2()

  fun <T : vx_core.Type_any> f_if_2(generic_any_1 : T, thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_if_2(generic_any_1, thenelselist)
    return output
  }


  interface Func_int_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_int_from_func() : vx_core.Type_int
    fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_int_from_func
  }

  class Class_int_from_func : vx_core.Class_base, Func_int_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_int_from_func {
      val output : vx_core.Class_int_from_func = vx_core.Class_int_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_int_from_func = vx_core.Class_int_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "int<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_int_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_int_from_func
      return output
    }

    var fn : vx_core.Class_any_from_func.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_int_from_func {
      val output : vx_core.Class_int_from_func = vx_core.Class_int_from_func()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_int_from_func()
      return output
    }

    fun vx_core.Type_int vx_int_from_func() {
      return vx_core.f_int_from_func()
    }

  }

  val e_int_from_func : vx_core.Func_int_from_func = vx_core.Class_int_from_func()
  val t_int_from_func : vx_core.Func_int_from_func = vx_core.Class_int_from_func()

  fun f_int_from_func() : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    return output
  }


  interface Func_int_from_string : vx_core.Func_any_from_any {
    fun vx_int_from_string(val : vx_core.Type_string) : vx_core.Type_int
  }

  class Class_int_from_string : vx_core.Class_base, Func_int_from_string {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_int_from_string {
      val output : vx_core.Class_int_from_string = vx_core.Class_int_from_string()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_int_from_string = vx_core.Class_int_from_string()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "int<-string", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_int_from_string
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_int_from_string
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_int_from_string(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_int_from_string(val)
      return output
    }

    fun vx_core.Type_int vx_int_from_string(vx_core.Type_string val) {
      return vx_core.f_int_from_string(val)
    }

  }

  val e_int_from_string : vx_core.Func_int_from_string = vx_core.Class_int_from_string()
  val t_int_from_string : vx_core.Func_int_from_string = vx_core.Class_int_from_string()

  fun f_int_from_string(val : vx_core.Type_string) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_switch(
      vx_core.t_int,
      val,
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_string("notanumber"),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.c_notanumber
          })
        ),
        vx_core.f_case_1(
          vx_core.vx_new_string("infinity"),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.c_infinity
          })
        ),
        vx_core.f_case_1(
          vx_core.vx_new_string("neginfinity"),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.c_neginfinity
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new(()  {
          })
        )
      )
    )
    return output
  }


  interface Func_is_empty : vx_core.Func_any_from_any {
    fun vx_is_empty(text : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_is_empty : vx_core.Class_base, Func_is_empty {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_empty {
      val output : vx_core.Class_is_empty = vx_core.Class_is_empty()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_empty = vx_core.Class_is_empty()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_empty
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_empty
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_is_empty(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_empty(text)
      return output
    }

    fun vx_core.Type_boolean vx_is_empty(vx_core.Type_string text) {
      return vx_core.f_is_empty(text)
    }

  }

  val e_is_empty : vx_core.Func_is_empty = vx_core.Class_is_empty()
  val t_is_empty : vx_core.Func_is_empty = vx_core.Class_is_empty()

  fun f_is_empty(text : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (text.vx_string().Length == 0) {
      output = vx_core.c_true
    }
    return output
  }


  interface Func_is_empty_1 : vx_core.Func_any_from_any {
    fun vx_is_empty_1(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_empty_1 : vx_core.Class_base, Func_is_empty_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_empty_1 {
      val output : vx_core.Class_is_empty_1 = vx_core.Class_is_empty_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_empty_1 = vx_core.Class_is_empty_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_empty_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_empty_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_empty_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_empty_1(value)
      return output
    }

    fun vx_core.Type_boolean vx_is_empty_1(vx_core.Type_any value) {
      return vx_core.f_is_empty_1(value)
    }

  }

  val e_is_empty_1 : vx_core.Func_is_empty_1 = vx_core.Class_is_empty_1()
  val t_is_empty_1 : vx_core.Func_is_empty_1 = vx_core.Class_is_empty_1()

  fun f_is_empty_1(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (value == value.vx_empty()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }
    return output
  }


  interface Func_is_endswith : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_is_endswith(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_is_endswith : vx_core.Class_base, Func_is_endswith {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_endswith {
      val output : vx_core.Class_is_endswith = vx_core.Class_is_endswith()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_endswith = vx_core.Class_is_endswith()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-endswith", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_endswith
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_endswith
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_is_endswith(text, find)
      return output
    }

    fun vx_core.Type_boolean vx_is_endswith(vx_core.Type_string text, vx_core.Type_string find) {
      return vx_core.f_is_endswith(text, find)
    }

  }

  val e_is_endswith : vx_core.Func_is_endswith = vx_core.Class_is_endswith()
  val t_is_endswith : vx_core.Func_is_endswith = vx_core.Class_is_endswith()

  fun f_is_endswith(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val stext : String = text.vx_string()
    val sfind : String = find.vx_string()
    if (stext.endsWith(sfind)) {
      output = vx_core.c_true
    }
    return output
  }


  interface Func_is_float : vx_core.Func_any_from_any {
    fun vx_is_float(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_float : vx_core.Class_base, Func_is_float {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_float {
      val output : vx_core.Class_is_float = vx_core.Class_is_float()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_float = vx_core.Class_is_float()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-float", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_float
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_float
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_float(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_float(value)
      return output
    }

    fun vx_core.Type_boolean vx_is_float(vx_core.Type_any value) {
      return vx_core.f_is_float(value)
    }

  }

  val e_is_float : vx_core.Func_is_float = vx_core.Class_is_float()
  val t_is_float : vx_core.Func_is_float = vx_core.Class_is_float()

  fun f_is_float(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val result : Boolean = vx_core.vx_is_float(value)
    output = vx_core.vx_new_boolean(result)
    return output
  }


  interface Func_is_func : vx_core.Func_any_from_any {
    fun vx_is_func(val : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_func : vx_core.Class_base, Func_is_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_func {
      val output : vx_core.Class_is_func = vx_core.Class_is_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_func = vx_core.Class_is_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_func
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_func(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_func(val)
      return output
    }

    fun vx_core.Type_boolean vx_is_func(vx_core.Type_any val) {
      return vx_core.f_is_func(val)
    }

  }

  val e_is_func : vx_core.Func_is_func = vx_core.Class_is_func()
  val t_is_func : vx_core.Func_is_func = vx_core.Class_is_func()

  fun f_is_func(val : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (val is vx_core.Type_func) {
      output = vx_core.c_true
    }
    return output
  }


  interface Func_is_int : vx_core.Func_any_from_any {
    fun vx_is_int(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_int : vx_core.Class_base, Func_is_int {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_int {
      val output : vx_core.Class_is_int = vx_core.Class_is_int()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_int = vx_core.Class_is_int()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-int", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_int
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_int
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_int(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_int(value)
      return output
    }

    fun vx_core.Type_boolean vx_is_int(vx_core.Type_any value) {
      return vx_core.f_is_int(value)
    }

  }

  val e_is_int : vx_core.Func_is_int = vx_core.Class_is_int()
  val t_is_int : vx_core.Func_is_int = vx_core.Class_is_int()

  fun f_is_int(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val result : boolean = vx_core.vx_is_int(value)
    output = vx_core.vx_new_boolean(result)
    return output
  }


  interface Func_is_number : vx_core.Func_any_from_any {
    fun vx_is_number(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_number : vx_core.Class_base, Func_is_number {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_number {
      val output : vx_core.Class_is_number = vx_core.Class_is_number()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_number = vx_core.Class_is_number()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-number", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_number
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_number
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_number(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_number(value)
      return output
    }

    fun vx_core.Type_boolean vx_is_number(vx_core.Type_any value) {
      return vx_core.f_is_number(value)
    }

  }

  val e_is_number : vx_core.Func_is_number = vx_core.Class_is_number()
  val t_is_number : vx_core.Func_is_number = vx_core.Class_is_number()

  fun f_is_number(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_typename_from_any(value),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case(
          vx_core.f_new(
            vx_core.t_list,
            vx_core.vx_new(
              vx_core.t_anylist,
              vx_core.vx_new_string("vx/core/decimal"),
              vx_core.vx_new_string("vx/core/float"),
              vx_core.vx_new_string("vx/core/int"),
              vx_core.vx_new_string("vx/core/number")
            )
          ),
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(true)
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new(()  {
            return vx_core.vx_new_boolean(false)
          })
        )
      )
    )
    return output
  }


  interface Func_is_pass_from_permission : vx_core.Func_any_from_any_context {
    fun vx_is_pass_from_permission(context : vx_core.Type_context, permission : vx_core.Type_permission) : vx_core.Type_boolean
  }

  class Class_is_pass_from_permission : vx_core.Class_base, Func_is_pass_from_permission {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_is_pass_from_permission {
      val output : vx_core.Class_is_pass_from_permission = vx_core.Class_is_pass_from_permission()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_pass_from_permission = vx_core.Class_is_pass_from_permission()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-pass<-permission", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_pass_from_permission
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_pass_from_permission
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_permission = value as vx_core.Type_permission
      var outputval : vx_core.Type_any = vx_core.f_is_pass_from_permission(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var permission : vx_core.Type_permission = vx_core.f_any_from_any(vx_core.t_permission, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_pass_from_permission(context, permission)
      return output
    }

    fun vx_core.Type_boolean vx_is_pass_from_permission(vx_core.Type_context context, vx_core.Type_permission permission) {
      return vx_core.f_is_pass_from_permission(context, permission)
    }

  }

  val e_is_pass_from_permission : vx_core.Func_is_pass_from_permission = vx_core.Class_is_pass_from_permission()
  val t_is_pass_from_permission : vx_core.Func_is_pass_from_permission = vx_core.Class_is_pass_from_permission()

  fun f_is_pass_from_permission(context : vx_core.Type_context, permission : vx_core.Type_permission) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_let(
      vx_core.t_boolean,
      vx_core.t_any_from_func.vx_fn_new(()  {
        var id : vx_core.Type_string = permission.id()
        var lookup : vx_core.Type_permission = vx_core.f_permission_from_id_context(context, id)
        var output_1 : vx_core.Type_any = vx_core.f_eq(lookup, permission)
        return output_1
      })
    )
    return output
  }


  interface Func_last_from_list : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_last_from_list(generic_any_1 : T, values : X) : T
  }

  class Class_last_from_list : vx_core.Class_base, Func_last_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_last_from_list {
      val output : vx_core.Class_last_from_list = vx_core.Class_last_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_last_from_list = vx_core.Class_last_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "last<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_last_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_last_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_last_from_list(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_last_from_list(generic_any_1, values)
      return output
    }

    fun <T : vx_core.Type_any, X : vx_core.Type_list> T vx_last_from_list(T generic_any_1, X values) {
      return vx_core.f_last_from_list(generic_any_1, values)
    }

  }

  val e_last_from_list : vx_core.Func_last_from_list = vx_core.Class_last_from_list()
  val t_last_from_list : vx_core.Func_last_from_list = vx_core.Class_last_from_list()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_last_from_list(generic_any_1 : T, values : X) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.f_let(
      generic_any_1,
      vx_core.t_any_from_func.vx_fn_new(()  {
        var len : vx_core.Type_int = vx_core.f_length_1(values)
        var output_1 : vx_core.Type_any = vx_core.f_any_from_list(generic_any_1, values, len)
        return output_1
      })
    )
    return output
  }


  interface Func_length : vx_core.Func_any_from_any {
    fun vx_length(text : vx_core.Type_string) : vx_core.Type_int
  }

  class Class_length : vx_core.Class_base, Func_length {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_length {
      val output : vx_core.Class_length = vx_core.Class_length()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length = vx_core.Class_length()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_length
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_length
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_length(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_length(text)
      return output
    }

    fun vx_core.Type_int vx_length(vx_core.Type_string text) {
      return vx_core.f_length(text)
    }

  }

  val e_length : vx_core.Func_length = vx_core.Class_length()
  val t_length : vx_core.Func_length = vx_core.Class_length()

  fun f_length(text : vx_core.Type_string) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val len : int = text.vx_string().length()
    output = vx_core.vx_new_int(len)
    return output
  }


  interface Func_length_1 : vx_core.Func_any_from_any {
    fun vx_length_1(values : vx_core.Type_list) : vx_core.Type_int
  }

  class Class_length_1 : vx_core.Class_base, Func_length_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_length_1 {
      val output : vx_core.Class_length_1 = vx_core.Class_length_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length_1 = vx_core.Class_length_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_length_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_length_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_length_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_length_1(values)
      return output
    }

    fun vx_core.Type_int vx_length_1(vx_core.Type_list values) {
      return vx_core.f_length_1(values)
    }

  }

  val e_length_1 : vx_core.Func_length_1 = vx_core.Class_length_1()
  val t_length_1 : vx_core.Func_length_1 = vx_core.Class_length_1()

  fun f_length_1(values : vx_core.Type_list) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val intresult : int = values.vx_list().size()
    output = vx_core.vx_new_int(intresult)
    return output
  }


  interface Func_length_2 : vx_core.Func_any_from_any {
    fun vx_length_2(valuemap : vx_core.Type_map) : vx_core.Type_int
  }

  class Class_length_2 : vx_core.Class_base, Func_length_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_length_2 {
      val output : vx_core.Class_length_2 = vx_core.Class_length_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length_2 = vx_core.Class_length_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_length_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_length_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_length_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_length_2(valuemap)
      return output
    }

    fun vx_core.Type_int vx_length_2(vx_core.Type_map valuemap) {
      return vx_core.f_length_2(valuemap)
    }

  }

  val e_length_2 : vx_core.Func_length_2 = vx_core.Class_length_2()
  val t_length_2 : vx_core.Func_length_2 = vx_core.Class_length_2()

  fun f_length_2(valuemap : vx_core.Type_map) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_length_1(
      vx_core.f_stringlist_from_map(valuemap)
    )
    return output
  }


  interface Func_let : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_let(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T
  }

  class Class_let : vx_core.Class_base, Func_let {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_let {
      val output : vx_core.Class_let = vx_core.Class_let()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_let = vx_core.Class_let()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "let", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_let
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_let
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_let(generic_any_1, fn_any)
      return output
    }

    fun <T : vx_core.Type_any> T vx_let(T generic_any_1, vx_core.Func_any_from_func fn_any) {
      return vx_core.f_let(generic_any_1, fn_any)
    }

  }

  val e_let : vx_core.Func_let = vx_core.Class_let()
  val t_let : vx_core.Func_let = vx_core.Class_let()

  fun <T : vx_core.Type_any> f_let(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = fn_any.vx_any_from_func(generic_any_1)
    return output
  }


  interface Func_let_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any> vx_let_async(generic_any_1 : T, fn_any_async : vx_core.Func_any_from_func_async) : <T>
  }

  class Class_let_async : vx_core.Class_base, Func_let_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_let_async {
      val output : vx_core.Class_let_async = vx_core.Class_let_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_let_async = vx_core.Class_let_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "let-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_let_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_let_async
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_async : vx_core.Func_any_from_func_async = vx_core.f_any_from_any(vx_core.t_any_from_func_async, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_let_async(generic_any_1, fn_any_async)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any> <T> vx_let_async(T generic_any_1, vx_core.Func_any_from_func_async fn_any_async) {
      return vx_core.f_let_async(generic_any_1, fn_any_async)
    }

  }

  val e_let_async : vx_core.Func_let_async = vx_core.Class_let_async()
  val t_let_async : vx_core.Func_let_async = vx_core.Class_let_async()

  fun <T : vx_core.Type_any> f_let_async(generic_any_1 : T, fn_any_async : vx_core.Func_any_from_func_async) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    output = fn_any_async.vx_any_from_func_async(generic_any_1)
    return output
  }


  interface Func_list_join_from_list : vx_core.Func_any_from_any {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list(generic_list_1 : X, values : Y) : X
  }

  class Class_list_join_from_list : vx_core.Class_base, Func_list_join_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_join_from_list {
      val output : vx_core.Class_list_join_from_list = vx_core.Class_list_join_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_join_from_list = vx_core.Class_list_join_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_join_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_join_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_list_join_from_list(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_join_from_list(generic_list_1, values)
      return output
    }

    fun <X : vx_core.Type_list, Y : vx_core.Type_list> X vx_list_join_from_list(X generic_list_1, Y values) {
      return vx_core.f_list_join_from_list(generic_list_1, values)
    }

  }

  val e_list_join_from_list : vx_core.Func_list_join_from_list = vx_core.Class_list_join_from_list()
  val t_list_join_from_list : vx_core.Func_list_join_from_list = vx_core.Class_list_join_from_list()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_join_from_list(generic_list_1 : X, values : Y) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_join_from_list_1(
      generic_list_1,
      values,
      vx_core.t_any_from_any.vx_fn_new((value_any)  {
        vx_core.Type_any value = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        return output_1
      })
    )
    return output
  }


  interface Func_list_join_from_list_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X
  }

  class Class_list_join_from_list_1 : vx_core.Class_base, Func_list_join_from_list_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_join_from_list_1 {
      val output : vx_core.Class_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_join_from_list_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_join_from_list_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any)
      return output
    }

    fun <X : vx_core.Type_list, Y : vx_core.Type_list> X vx_list_join_from_list_1(X generic_list_1, Y values, vx_core.Func_any_from_any fn_any_from_any) {
      return vx_core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any)
    }

  }

  val e_list_join_from_list_1 : vx_core.Func_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()
  val t_list_join_from_list_1 : vx_core.Func_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_join_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_join_from_list_1(generic_list_1, values, fn_any_from_any)
    return output
  }


  interface Func_list_from_list : vx_core.Func_any_from_any {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list(generic_list_1 : X, values : Y) : X
  }

  class Class_list_from_list : vx_core.Class_base, Func_list_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_list {
      val output : vx_core.Class_list_from_list = vx_core.Class_list_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list = vx_core.Class_list_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_list_from_list(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_from_list(generic_list_1, values)
      return output
    }

    fun <X : vx_core.Type_list, Y : vx_core.Type_list> X vx_list_from_list(X generic_list_1, Y values) {
      return vx_core.f_list_from_list(generic_list_1, values)
    }

  }

  val e_list_from_list : vx_core.Func_list_from_list = vx_core.Class_list_from_list()
  val t_list_from_list : vx_core.Func_list_from_list = vx_core.Class_list_from_list()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list(generic_list_1 : X, values : Y) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_from_list_1(
      generic_list_1,
      values,
      vx_core.t_any_from_any.vx_fn_new((value_any)  {
        vx_core.Type_any value = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        return output_1
      })
    )
    return output
  }


  interface Func_list_from_list_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X
  }

  class Class_list_from_list_1 : vx_core.Class_base, Func_list_from_list_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_list_1 {
      val output : vx_core.Class_list_from_list_1 = vx_core.Class_list_from_list_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_1 = vx_core.Class_list_from_list_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_from_list_1(generic_list_1, values, fn_any_from_any)
      return output
    }

    fun <X : vx_core.Type_list, Y : vx_core.Type_list> X vx_list_from_list_1(X generic_list_1, Y values, vx_core.Func_any_from_any fn_any_from_any) {
      return vx_core.f_list_from_list_1(generic_list_1, values, fn_any_from_any)
    }

  }

  val e_list_from_list_1 : vx_core.Func_list_from_list_1 = vx_core.Class_list_from_list_1()
  val t_list_from_list_1 : vx_core.Func_list_from_list_1 = vx_core.Class_list_from_list_1()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_from_list_1(generic_list_1, values, fn_any_from_any)
    return output
  }


  interface Func_list_from_list_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_async(generic_list_1 : X, values : Y, fn_any_from_any_async : vx_core.Func_any_from_any_async) : <X>
  }

  class Class_list_from_list_async : vx_core.Class_base, Func_list_from_list_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_list_async {
      val output : vx_core.Class_list_from_list_async = vx_core.Class_list_from_list_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_async = vx_core.Class_list_from_list_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list_async
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any_async : vx_core.Func_any_from_any_async = vx_core.f_any_from_any(vx_core.t_any_from_any_async, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : vx_core.Type_list = await vx_core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <X : vx_core.Type_list, Y : vx_core.Type_list> <X> vx_list_from_list_async(X generic_list_1, Y values, vx_core.Func_any_from_any_async fn_any_from_any_async) {
      return vx_core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async)
    }

  }

  val e_list_from_list_async : vx_core.Func_list_from_list_async = vx_core.Class_list_from_list_async()
  val t_list_from_list_async : vx_core.Func_list_from_list_async = vx_core.Class_list_from_list_async()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list_async(generic_list_1 : X, values : Y, fn_any_from_any_async : vx_core.Func_any_from_any_async) : <X> {
    <X> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_list_1))
    output = vx_core.vx_list_from_list_async(generic_list_1, values, fn_any_from_any_async)
    return output
  }


  interface Func_list_from_list_intany : vx_core.Type_func, vx_core.Type_replfunc {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_intany(generic_list_1 : X, values : Y, fn_any_from_int_any : vx_core.Func_any_from_int_any) : X
  }

  class Class_list_from_list_intany : vx_core.Class_base, Func_list_from_list_intany {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_list_intany {
      val output : vx_core.Class_list_from_list_intany = vx_core.Class_list_from_list_intany()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_intany = vx_core.Class_list_from_list_intany()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-intany", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list_intany
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list_intany
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_int_any : vx_core.Func_any_from_int_any = vx_core.f_any_from_any(vx_core.t_any_from_int_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any)
      return output
    }

    fun <X : vx_core.Type_list, Y : vx_core.Type_list> X vx_list_from_list_intany(X generic_list_1, Y values, vx_core.Func_any_from_int_any fn_any_from_int_any) {
      return vx_core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any)
    }

  }

  val e_list_from_list_intany : vx_core.Func_list_from_list_intany = vx_core.Class_list_from_list_intany()
  val t_list_from_list_intany : vx_core.Func_list_from_list_intany = vx_core.Class_list_from_list_intany()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list_intany(generic_list_1 : X, values : Y, fn_any_from_int_any : vx_core.Func_any_from_int_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_from_list_intany(generic_list_1, values, fn_any_from_int_any)
    return output
  }


  interface Func_list_from_map : vx_core.Func_any_from_any {
    fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map(generic_list_1 : X, valuemap : O) : X
  }

  class Class_list_from_map : vx_core.Class_base, Func_list_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_map {
      val output : vx_core.Class_list_from_map = vx_core.Class_list_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map = vx_core.Class_list_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_map
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_list_from_map(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_from_map(generic_list_1, valuemap)
      return output
    }

    fun <O : vx_core.Type_map, X : vx_core.Type_list> X vx_list_from_map(X generic_list_1, O valuemap) {
      return vx_core.f_list_from_map(generic_list_1, valuemap)
    }

  }

  val e_list_from_map : vx_core.Func_list_from_map = vx_core.Class_list_from_map()
  val t_list_from_map : vx_core.Func_list_from_map = vx_core.Class_list_from_map()

  fun <O : vx_core.Type_map, X : vx_core.Type_list> f_list_from_map(generic_list_1 : X, valuemap : O) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_from_map_1(
      generic_list_1,
      valuemap,
      vx_core.t_any_from_key_value.vx_fn_new((key_any, value_any)  {
        vx_core.Type_string key = vx_core.f_any_from_any(vx_core.t_string, key_any)
        vx_core.Type_any value = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        return output_1
      })
    )
    return output
  }


  interface Func_list_from_map_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_1(generic_list_1 : X, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : X
  }

  class Class_list_from_map_1 : vx_core.Class_base, Func_list_from_map_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_map_1 {
      val output : vx_core.Class_list_from_map_1 = vx_core.Class_list_from_map_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map_1 = vx_core.Class_list_from_map_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_map_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_map_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.f_any_from_any(vx_core.t_any_from_key_value, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value)
      return output
    }

    fun <O : vx_core.Type_map, X : vx_core.Type_list> X vx_list_from_map_1(X generic_list_1, O valuemap, vx_core.Func_any_from_key_value fn_any_from_key_value) {
      return vx_core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value)
    }

  }

  val e_list_from_map_1 : vx_core.Func_list_from_map_1 = vx_core.Class_list_from_map_1()
  val t_list_from_map_1 : vx_core.Func_list_from_map_1 = vx_core.Class_list_from_map_1()

  fun <O : vx_core.Type_map, X : vx_core.Type_list> f_list_from_map_1(generic_list_1 : X, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value)
    return output
  }


  interface Func_list_from_map_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_async(generic_list_1 : X, valuemap : O, fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async) : <X>
  }

  class Class_list_from_map_async : vx_core.Class_base, Func_list_from_map_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_map_async {
      val output : vx_core.Class_list_from_map_async = vx_core.Class_list_from_map_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map_async = vx_core.Class_list_from_map_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-map-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_map_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_map_async
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async = vx_core.f_any_from_any(vx_core.t_any_from_key_value_async, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : vx_core.Type_list = await vx_core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <O : vx_core.Type_map, X : vx_core.Type_list> <X> vx_list_from_map_async(X generic_list_1, O valuemap, vx_core.Func_any_from_key_value_async fn_any_from_key_value_async) {
      return vx_core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async)
    }

  }

  val e_list_from_map_async : vx_core.Func_list_from_map_async = vx_core.Class_list_from_map_async()
  val t_list_from_map_async : vx_core.Func_list_from_map_async = vx_core.Class_list_from_map_async()

  fun <O : vx_core.Type_map, X : vx_core.Type_list> f_list_from_map_async(generic_list_1 : X, valuemap : O, fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async) : <X> {
    <X> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_list_1))
    return output
  }


  interface Func_list_from_type : vx_core.Func_any_from_any {
    fun vx_list_from_type(type : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_list_from_type : vx_core.Class_base, Func_list_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_list_from_type {
      val output : vx_core.Class_list_from_type = vx_core.Class_list_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_type = vx_core.Class_list_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_type
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_list_from_type(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_from_type(type)
      return output
    }

    fun vx_core.Type_any vx_list_from_type(vx_core.Type_any type) {
      return vx_core.f_list_from_type(type)
    }

  }

  val e_list_from_type : vx_core.Func_list_from_type = vx_core.Class_list_from_type()
  val t_list_from_type : vx_core.Func_list_from_type = vx_core.Class_list_from_type()

  fun f_list_from_type(type : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_log : vx_core.Func_any_from_any {
    fun vx_log(value : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_log : vx_core.Class_base, Func_log {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_log {
      val output : vx_core.Class_log = vx_core.Class_log()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_log = vx_core.Class_log()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_log
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_log
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_log(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_log(value)
      return output
    }

    fun vx_core.Type_any vx_log(vx_core.Type_any value) {
      return vx_core.f_log(value)
    }

  }

  val e_log : vx_core.Func_log = vx_core.Class_log()
  val t_log : vx_core.Func_log = vx_core.Class_log()

  fun f_log(value : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    vx_core.vx_log(value)
    output = value
    return output
  }


  interface Func_log_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_log_1(generic_any_1 : T, text : vx_core.Type_string, value : T) : T
  }

  class Class_log_1 : vx_core.Class_base, Func_log_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_log_1 {
      val output : vx_core.Class_log_1 = vx_core.Class_log_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_log_1 = vx_core.Class_log_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_log_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_log_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_log_1(generic_any_1, text, value)
      return output
    }

    fun <T : vx_core.Type_any> T vx_log_1(T generic_any_1, vx_core.Type_string text, T value) {
      return vx_core.f_log_1(generic_any_1, text, value)
    }

  }

  val e_log_1 : vx_core.Func_log_1 = vx_core.Class_log_1()
  val t_log_1 : vx_core.Func_log_1 = vx_core.Class_log_1()

  fun <T : vx_core.Type_any> f_log_1(generic_any_1 : T, text : vx_core.Type_string, value : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    vx_core.vx_log(text)
    vx_core.vx_log(value)
    output = value
    return output
  }


  interface Func_main : vx_core.Func_any_from_any {
    fun vx_main(args : vx_core.Type_anylist) : vx_core.Type_string
  }

  class Class_main : vx_core.Class_base, Func_main {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_main {
      val output : vx_core.Class_main = vx_core.Class_main()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_main = vx_core.Class_main()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "main", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_main
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_main
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_main(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_main(args)
      return output
    }

    fun vx_core.Type_string vx_main(vx_core.Type_anylist args) {
      return vx_core.f_main(args)
    }

  }

  val e_main : vx_core.Func_main = vx_core.Class_main()
  val t_main : vx_core.Func_main = vx_core.Class_main()

  fun f_main(args : vx_core.Type_anylist) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_new(
      vx_core.t_string,
      args
    )
    return output
  }


  interface Func_map_from_list : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, Y : vx_core.Type_list> vx_map_from_list(generic_map_1 : N, vallist : Y, fn_any_from_any : vx_core.Func_any_from_any) : N
  }

  class Class_map_from_list : vx_core.Class_base, Func_map_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_map_from_list {
      val output : vx_core.Class_map_from_list = vx_core.Class_map_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_list = vx_core.Class_map_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "map<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map_from_list
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_map_1 : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var vallist : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_map_from_list(generic_map_1, vallist, fn_any_from_any)
      return output
    }

    fun <N : vx_core.Type_map, Y : vx_core.Type_list> N vx_map_from_list(N generic_map_1, Y vallist, vx_core.Func_any_from_any fn_any_from_any) {
      return vx_core.f_map_from_list(generic_map_1, vallist, fn_any_from_any)
    }

  }

  val e_map_from_list : vx_core.Func_map_from_list = vx_core.Class_map_from_list()
  val t_map_from_list : vx_core.Func_map_from_list = vx_core.Class_map_from_list()

  fun <N : vx_core.Type_map, Y : vx_core.Type_list> f_map_from_list(generic_map_1 : N, vallist : Y, fn_any_from_any : vx_core.Func_any_from_any) : N {
    var output : N = vx_core.f_empty(generic_map_1)
    output = vx_core.vx_map_from_list(generic_map_1, vallist, fn_any_from_any)
    return output
  }


  interface Func_map_from_map : vx_core.Func_any_from_any {
    fun <N : vx_core.Type_map, O : vx_core.Type_map> vx_map_from_map(generic_map_1 : N, valuemap : O) : N
  }

  class Class_map_from_map : vx_core.Class_base, Func_map_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_map_from_map {
      val output : vx_core.Class_map_from_map = vx_core.Class_map_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_map = vx_core.Class_map_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map_from_map
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_map_from_map(vx_core.t_map, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_map_1 : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_map_from_map(generic_map_1, valuemap)
      return output
    }

    fun <N : vx_core.Type_map, O : vx_core.Type_map> N vx_map_from_map(N generic_map_1, O valuemap) {
      return vx_core.f_map_from_map(generic_map_1, valuemap)
    }

  }

  val e_map_from_map : vx_core.Func_map_from_map = vx_core.Class_map_from_map()
  val t_map_from_map : vx_core.Func_map_from_map = vx_core.Class_map_from_map()

  fun <N : vx_core.Type_map, O : vx_core.Type_map> f_map_from_map(generic_map_1 : N, valuemap : O) : N {
    var output : N = vx_core.f_empty(generic_map_1)
    output = vx_core.f_map_from_map_1(
      generic_map_1,
      valuemap,
      vx_core.t_any_from_key_value.vx_fn_new((key_any, value_any)  {
        vx_core.Type_string key = vx_core.f_any_from_any(vx_core.t_string, key_any)
        vx_core.Type_any value = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        return output_1
      })
    )
    return output
  }


  interface Func_map_from_map_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, O : vx_core.Type_map> vx_map_from_map_1(generic_map_1 : N, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : N
  }

  class Class_map_from_map_1 : vx_core.Class_base, Func_map_from_map_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_map_from_map_1 {
      val output : vx_core.Class_map_from_map_1 = vx_core.Class_map_from_map_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_map_1 = vx_core.Class_map_from_map_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map_from_map_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map_from_map_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_map_1 : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.f_any_from_any(vx_core.t_any_from_key_value, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value)
      return output
    }

    fun <N : vx_core.Type_map, O : vx_core.Type_map> N vx_map_from_map_1(N generic_map_1, O valuemap, vx_core.Func_any_from_key_value fn_any_from_key_value) {
      return vx_core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value)
    }

  }

  val e_map_from_map_1 : vx_core.Func_map_from_map_1 = vx_core.Class_map_from_map_1()
  val t_map_from_map_1 : vx_core.Func_map_from_map_1 = vx_core.Class_map_from_map_1()

  fun <N : vx_core.Type_map, O : vx_core.Type_map> f_map_from_map_1(generic_map_1 : N, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : N {
    var output : N = vx_core.f_empty(generic_map_1)
    output = vx_core.vx_map_from_map_fn(
      generic_map_1,
      valuemap,
      fn_any_from_key_value)
    return output
  }


  interface Func_msg_from_error : vx_core.Func_any_from_any {
    fun vx_msg_from_error(error : vx_core.Type_string) : vx_core.Type_msg
  }

  class Class_msg_from_error : vx_core.Class_base, Func_msg_from_error {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_msg_from_error {
      val output : vx_core.Class_msg_from_error = vx_core.Class_msg_from_error()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error = vx_core.Class_msg_from_error()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_error
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_error
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_msg_from_error(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var error : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_msg_from_error(error)
      return output
    }

    fun vx_core.Type_msg vx_msg_from_error(vx_core.Type_string error) {
      return vx_core.f_msg_from_error(error)
    }

  }

  val e_msg_from_error : vx_core.Func_msg_from_error = vx_core.Class_msg_from_error()
  val t_msg_from_error : vx_core.Func_msg_from_error = vx_core.Class_msg_from_error()

  fun f_msg_from_error(error : vx_core.Type_string) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_error,
        vx_core.vx_new_string(":text"),
        error
      )
    )
    return output
  }


  interface Func_msg_from_error_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msg_from_error_1(code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg
  }

  class Class_msg_from_error_1 : vx_core.Class_base, Func_msg_from_error_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_msg_from_error_1 {
      val output : vx_core.Class_msg_from_error_1 = vx_core.Class_msg_from_error_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error_1 = vx_core.Class_msg_from_error_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_error_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_error_1
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var code : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var detail : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_msg_from_error_1(code, detail)
      return output
    }

    fun vx_core.Type_msg vx_msg_from_error_1(vx_core.Type_string code, vx_core.Type_any detail) {
      return vx_core.f_msg_from_error_1(code, detail)
    }

  }

  val e_msg_from_error_1 : vx_core.Func_msg_from_error_1 = vx_core.Class_msg_from_error_1()
  val t_msg_from_error_1 : vx_core.Func_msg_from_error_1 = vx_core.Class_msg_from_error_1()

  fun f_msg_from_error_1(code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        code,
        vx_core.vx_new_string(":detail"),
        detail,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_error
      )
    )
    return output
  }


  interface Func_msg_from_error_2 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msg_from_error_2(path : vx_core.Type_string, code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg
  }

  class Class_msg_from_error_2 : vx_core.Class_base, Func_msg_from_error_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_msg_from_error_2 {
      val output : vx_core.Class_msg_from_error_2 = vx_core.Class_msg_from_error_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error_2 = vx_core.Class_msg_from_error_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_error_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_error_2
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var path : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var code : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var detail : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_msg_from_error_2(path, code, detail)
      return output
    }

    fun vx_core.Type_msg vx_msg_from_error_2(vx_core.Type_string path, vx_core.Type_string code, vx_core.Type_any detail) {
      return vx_core.f_msg_from_error_2(path, code, detail)
    }

  }

  val e_msg_from_error_2 : vx_core.Func_msg_from_error_2 = vx_core.Class_msg_from_error_2()
  val t_msg_from_error_2 : vx_core.Func_msg_from_error_2 = vx_core.Class_msg_from_error_2()

  fun f_msg_from_error_2(path : vx_core.Type_string, code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        code,
        vx_core.vx_new_string(":path"),
        path,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_error,
        vx_core.vx_new_string(":detail"),
        detail
      )
    )
    return output
  }


  interface Func_msg_from_warning : vx_core.Func_any_from_any {
    fun vx_msg_from_warning(warning : vx_core.Type_string) : vx_core.Type_msg
  }

  class Class_msg_from_warning : vx_core.Class_base, Func_msg_from_warning {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_msg_from_warning {
      val output : vx_core.Class_msg_from_warning = vx_core.Class_msg_from_warning()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_warning = vx_core.Class_msg_from_warning()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-warning", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_warning
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_warning
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_msg_from_warning(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var warning : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_msg_from_warning(warning)
      return output
    }

    fun vx_core.Type_msg vx_msg_from_warning(vx_core.Type_string warning) {
      return vx_core.f_msg_from_warning(warning)
    }

  }

  val e_msg_from_warning : vx_core.Func_msg_from_warning = vx_core.Class_msg_from_warning()
  val t_msg_from_warning : vx_core.Func_msg_from_warning = vx_core.Class_msg_from_warning()

  fun f_msg_from_warning(warning : vx_core.Type_string) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_warning,
        vx_core.vx_new_string(":text"),
        warning
      )
    )
    return output
  }


  interface Func_msgblock_from_msgblock_msg : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msgblock_from_msgblock_msg(origblock : vx_core.Type_msgblock, addmsg : vx_core.Type_msg) : vx_core.Type_msgblock
  }

  class Class_msgblock_from_msgblock_msg : vx_core.Class_base, Func_msgblock_from_msgblock_msg {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_msgblock_from_msgblock_msg {
      val output : vx_core.Class_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msg", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblock_from_msgblock_msg
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblock_from_msgblock_msg
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var origblock : vx_core.Type_msgblock = vx_core.f_any_from_any(vx_core.t_msgblock, arglist.vx_any(vx_core.vx_new_int(0)))
      var addmsg : vx_core.Type_msg = vx_core.f_any_from_any(vx_core.t_msg, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_msgblock_from_msgblock_msg(origblock, addmsg)
      return output
    }

    fun vx_core.Type_msgblock vx_msgblock_from_msgblock_msg(vx_core.Type_msgblock origblock, vx_core.Type_msg addmsg) {
      return vx_core.f_msgblock_from_msgblock_msg(origblock, addmsg)
    }

  }

  val e_msgblock_from_msgblock_msg : vx_core.Func_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()
  val t_msgblock_from_msgblock_msg : vx_core.Func_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()

  fun f_msgblock_from_msgblock_msg(origblock : vx_core.Type_msgblock, addmsg : vx_core.Type_msg) : vx_core.Type_msgblock {
    var output : vx_core.Type_msgblock = vx_core.e_msgblock
    output = vx_core.f_copy(origblock, vx_core.vx_new(
      vx_core.t_anylist,
      addmsg))
    return output
  }


  interface Func_msgblock_from_msgblock_msgblock : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msgblock_from_msgblock_msgblock(origblock : vx_core.Type_msgblock, addblock : vx_core.Type_msgblock) : vx_core.Type_msgblock
  }

  class Class_msgblock_from_msgblock_msgblock : vx_core.Class_base, Func_msgblock_from_msgblock_msgblock {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_msgblock_from_msgblock_msgblock {
      val output : vx_core.Class_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msgblock", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblock_from_msgblock_msgblock
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblock_from_msgblock_msgblock
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var origblock : vx_core.Type_msgblock = vx_core.f_any_from_any(vx_core.t_msgblock, arglist.vx_any(vx_core.vx_new_int(0)))
      var addblock : vx_core.Type_msgblock = vx_core.f_any_from_any(vx_core.t_msgblock, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_msgblock_from_msgblock_msgblock(origblock, addblock)
      return output
    }

    fun vx_core.Type_msgblock vx_msgblock_from_msgblock_msgblock(vx_core.Type_msgblock origblock, vx_core.Type_msgblock addblock) {
      return vx_core.f_msgblock_from_msgblock_msgblock(origblock, addblock)
    }

  }

  val e_msgblock_from_msgblock_msgblock : vx_core.Func_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()
  val t_msgblock_from_msgblock_msgblock : vx_core.Func_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()

  fun f_msgblock_from_msgblock_msgblock(origblock : vx_core.Type_msgblock, addblock : vx_core.Type_msgblock) : vx_core.Type_msgblock {
    var output : vx_core.Type_msgblock = vx_core.e_msgblock
    output = vx_core.f_new(
      vx_core.t_msgblock,
      vx_core.vx_new(
        vx_core.t_anylist,
        origblock,
        addblock
      )
    )
    return output
  }


  interface Func_name_from_typedef : vx_core.Func_any_from_any {
    fun vx_name_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_name_from_typedef : vx_core.Class_base, Func_name_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_name_from_typedef {
      val output : vx_core.Class_name_from_typedef = vx_core.Class_name_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_name_from_typedef = vx_core.Class_name_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "name<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_name_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_name_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_name_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_name_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_string vx_name_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_name_from_typedef(vtypedef)
    }

  }

  val e_name_from_typedef : vx_core.Func_name_from_typedef = vx_core.Class_name_from_typedef()
  val t_name_from_typedef : vx_core.Func_name_from_typedef = vx_core.Class_name_from_typedef()

  fun f_name_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vtypedef.name()
    return output
  }


  interface Func_native : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_native(generic_any_1 : T, clauses : vx_core.Type_anylist) : T
  }

  class Class_native : vx_core.Class_base, Func_native {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_native {
      val output : vx_core.Class_native = vx_core.Class_native()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_native = vx_core.Class_native()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "native", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_native
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_native
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_native(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clauses : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_native(generic_any_1, clauses)
      return output
    }

    fun <T : vx_core.Type_any> T vx_native(T generic_any_1, vx_core.Type_anylist clauses) {
      return vx_core.f_native(generic_any_1, clauses)
    }

  }

  val e_native : vx_core.Func_native = vx_core.Class_native()
  val t_native : vx_core.Func_native = vx_core.Class_native()

  fun <T : vx_core.Type_any> f_native(generic_any_1 : T, clauses : vx_core.Type_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_native_from_any : vx_core.Func_any_from_any {
    fun vx_native_from_any(value : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_native_from_any : vx_core.Class_base, Func_native_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_native_from_any {
      val output : vx_core.Class_native_from_any = vx_core.Class_native_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_native_from_any = vx_core.Class_native_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "native<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_native_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_native_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_native_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_native_from_any(value)
      return output
    }

    fun vx_core.Type_any vx_native_from_any(vx_core.Type_any value) {
      return vx_core.f_native_from_any(value)
    }

  }

  val e_native_from_any : vx_core.Func_native_from_any = vx_core.Class_native_from_any()
  val t_native_from_any : vx_core.Func_native_from_any = vx_core.Class_native_from_any()

  fun f_native_from_any(value : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_new : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_new(type : T, values : vx_core.Type_anylist) : T
  }

  class Class_new : vx_core.Class_base, Func_new {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_new {
      val output : vx_core.Class_new = vx_core.Class_new()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_new = vx_core.Class_new()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "new", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_new
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_new
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_new(type, values)
      return output
    }

    fun <T : vx_core.Type_any> T vx_new(T type, vx_core.Type_anylist values) {
      return vx_core.f_new(type, values)
    }

  }

  val e_new : vx_core.Func_new = vx_core.Class_new()
  val t_new : vx_core.Func_new = vx_core.Class_new()

  fun <T : vx_core.Type_any> f_new(type : T, values : vx_core.Type_anylist) : T {
    val arrayany : Array<vx_core.Type_any> = vx_core.arrayany_from_anylist(values)
    val arrayobj : Array<Any> = arrayany as (Array<Any>)
    val anyvalue : vx_core.Type_any = type.vx_new(arrayobj)
    val output : T = (anyvalue) as T
    return output
  }


  interface Func_number_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_number_from_func() : vx_core.Type_number
  }

  class Class_number_from_func : vx_core.Class_base, Func_number_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_number_from_func {
      val output : vx_core.Class_number_from_func = vx_core.Class_number_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_number_from_func = vx_core.Class_number_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "number<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_number_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_number_from_func
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_number_from_func()
      return output
    }

    fun vx_core.Type_number vx_number_from_func() {
      return vx_core.f_number_from_func()
    }

  }

  val e_number_from_func : vx_core.Func_number_from_func = vx_core.Class_number_from_func()
  val t_number_from_func : vx_core.Func_number_from_func = vx_core.Class_number_from_func()

  fun f_number_from_func() : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    return output
  }


  interface Func_or : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_or(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean
  }

  class Class_or : vx_core.Class_base, Func_or {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_or {
      val output : vx_core.Class_or = vx_core.Class_or()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_or = vx_core.Class_or()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_or
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_or
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_or(val1, val2)
      return output
    }

    fun vx_core.Type_boolean vx_or(vx_core.Type_boolean val1, vx_core.Type_boolean val2) {
      return vx_core.f_or(val1, val2)
    }

  }

  val e_or : vx_core.Func_or = vx_core.Class_or()
  val t_or : vx_core.Func_or = vx_core.Class_or()

  fun f_or(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_or_1 : vx_core.Func_any_from_any {
    fun vx_or_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean
  }

  class Class_or_1 : vx_core.Class_base, Func_or_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_or_1 {
      val output : vx_core.Class_or_1 = vx_core.Class_or_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_or_1 = vx_core.Class_or_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_or_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_or_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_booleanlist = value as vx_core.Type_booleanlist
      var outputval : vx_core.Type_any = vx_core.f_or_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_booleanlist = vx_core.f_any_from_any(vx_core.t_booleanlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_or_1(values)
      return output
    }

    fun vx_core.Type_boolean vx_or_1(vx_core.Type_booleanlist values) {
      return vx_core.f_or_1(values)
    }

  }

  val e_or_1 : vx_core.Func_or_1 = vx_core.Class_or_1()
  val t_or_1 : vx_core.Func_or_1 = vx_core.Class_or_1()

  fun f_or_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(false),
      vx_core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any)  {
        vx_core.Type_boolean reduce = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        vx_core.Type_boolean current = vx_core.f_any_from_any(vx_core.t_boolean, current_any)
        vx_core.Type_boolean next = vx_core.f_any_from_any(vx_core.t_boolean, next_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_or(
            reduce,
            vx_core.f_or(current, next)
          )
        return output_1
      })
    )
    return output
  }


  interface Func_package_global_from_name : vx_core.Func_any_from_any {
    fun vx_package_global_from_name(name : vx_core.Type_string) : vx_core.Type_package
  }

  class Class_package_global_from_name : vx_core.Class_base, Func_package_global_from_name {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_package_global_from_name {
      val output : vx_core.Class_package_global_from_name = vx_core.Class_package_global_from_name()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_package_global_from_name = vx_core.Class_package_global_from_name()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "package-global<-name", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "package", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_package_global_from_name
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_package_global_from_name
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_package_global_from_name(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var name : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_package_global_from_name(name)
      return output
    }

    fun vx_core.Type_package vx_package_global_from_name(vx_core.Type_string name) {
      return vx_core.f_package_global_from_name(name)
    }

  }

  val e_package_global_from_name : vx_core.Func_package_global_from_name = vx_core.Class_package_global_from_name()
  val t_package_global_from_name : vx_core.Func_package_global_from_name = vx_core.Class_package_global_from_name()

  fun f_package_global_from_name(name : vx_core.Type_string) : vx_core.Type_package {
    var output : vx_core.Type_package = vx_core.e_package
    output = vx_core.f_any_from_map(
      vx_core.t_package,
      vx_core.c_global.packagemap(),
      name
    )
    return output
  }


  interface Func_packagename_from_typedef : vx_core.Func_any_from_any {
    fun vx_packagename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_packagename_from_typedef : vx_core.Class_base, Func_packagename_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_packagename_from_typedef {
      val output : vx_core.Class_packagename_from_typedef = vx_core.Class_packagename_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_packagename_from_typedef = vx_core.Class_packagename_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "packagename<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_packagename_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_packagename_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_packagename_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_packagename_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_string vx_packagename_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_packagename_from_typedef(vtypedef)
    }

  }

  val e_packagename_from_typedef : vx_core.Func_packagename_from_typedef = vx_core.Class_packagename_from_typedef()
  val t_packagename_from_typedef : vx_core.Func_packagename_from_typedef = vx_core.Class_packagename_from_typedef()

  fun f_packagename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vtypedef.pkgname()
    return output
  }


  interface Func_path_from_context_path : vx_core.Func_any_from_any_context {
    fun vx_path_from_context_path(context : vx_core.Type_context, path : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_path_from_context_path : vx_core.Class_base, Func_path_from_context_path {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_path_from_context_path {
      val output : vx_core.Class_path_from_context_path = vx_core.Class_path_from_context_path()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_path_from_context_path = vx_core.Class_path_from_context_path()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "path<-context-path", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_path_from_context_path
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_path_from_context_path
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_path_from_context_path(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var path : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_path_from_context_path(context, path)
      return output
    }

    fun vx_core.Type_string vx_path_from_context_path(vx_core.Type_context context, vx_core.Type_string path) {
      return vx_core.f_path_from_context_path(context, path)
    }

  }

  val e_path_from_context_path : vx_core.Func_path_from_context_path = vx_core.Class_path_from_context_path()
  val t_path_from_context_path : vx_core.Func_path_from_context_path = vx_core.Class_path_from_context_path()

  fun f_path_from_context_path(context : vx_core.Type_context, path : vx_core.Type_string) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_path_from_setting_path(
      vx_core.f_setting_from_context(context),
      path
    )
    return output
  }


  interface Func_path_from_setting_path : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_path_from_setting_path(session : vx_core.Type_setting, path : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_path_from_setting_path : vx_core.Class_base, Func_path_from_setting_path {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_path_from_setting_path {
      val output : vx_core.Class_path_from_setting_path = vx_core.Class_path_from_setting_path()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_path_from_setting_path = vx_core.Class_path_from_setting_path()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "path<-setting-path", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_path_from_setting_path
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_path_from_setting_path
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var session : vx_core.Type_setting = vx_core.f_any_from_any(vx_core.t_setting, arglist.vx_any(vx_core.vx_new_int(0)))
      var path : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_path_from_setting_path(session, path)
      return output
    }

    fun vx_core.Type_string vx_path_from_setting_path(vx_core.Type_setting session, vx_core.Type_string path) {
      return vx_core.f_path_from_setting_path(session, path)
    }

  }

  val e_path_from_setting_path : vx_core.Func_path_from_setting_path = vx_core.Class_path_from_setting_path()
  val t_path_from_setting_path : vx_core.Func_path_from_setting_path = vx_core.Class_path_from_setting_path()

  fun f_path_from_setting_path(session : vx_core.Type_setting, path : vx_core.Type_string) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_permission_from_id_context : vx_core.Func_any_from_any_context {
    fun vx_permission_from_id_context(context : vx_core.Type_context, id : vx_core.Type_string) : vx_core.Type_permission
  }

  class Class_permission_from_id_context : vx_core.Class_base, Func_permission_from_id_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_permission_from_id_context {
      val output : vx_core.Class_permission_from_id_context = vx_core.Class_permission_from_id_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_permission_from_id_context = vx_core.Class_permission_from_id_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "permission<-id-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "permission", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permission_from_id_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permission_from_id_context
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_permission_from_id_context(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var id : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_permission_from_id_context(context, id)
      return output
    }

    fun vx_core.Type_permission vx_permission_from_id_context(vx_core.Type_context context, vx_core.Type_string id) {
      return vx_core.f_permission_from_id_context(context, id)
    }

  }

  val e_permission_from_id_context : vx_core.Func_permission_from_id_context = vx_core.Class_permission_from_id_context()
  val t_permission_from_id_context : vx_core.Func_permission_from_id_context = vx_core.Class_permission_from_id_context()

  fun f_permission_from_id_context(context : vx_core.Type_context, id : vx_core.Type_string) : vx_core.Type_permission {
    var output : vx_core.Type_permission = vx_core.e_permission
    output = vx_core.f_let(
      vx_core.t_permission,
      vx_core.t_any_from_func.vx_fn_new(()  {
        var user : vx_core.Type_user = vx_core.f_user_from_context(context)
        var security : vx_core.Type_security = user.security()
        var permissionmap : vx_core.Type_permissionmap = security.permissionmap()
        var output_1 : vx_core.Type_any = vx_core.f_any_from_map(vx_core.t_permission, permissionmap, vx_core.vx_new_string(":id"))
        return output_1
      })
    )
    return output
  }


  interface Func_properties_from_typedef : vx_core.Func_any_from_any {
    fun vx_properties_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_argmap
  }

  class Class_properties_from_typedef : vx_core.Class_base, Func_properties_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_properties_from_typedef {
      val output : vx_core.Class_properties_from_typedef = vx_core.Class_properties_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_properties_from_typedef = vx_core.Class_properties_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "properties<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "argmap", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_arg), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_properties_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_properties_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_properties_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_properties_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_argmap vx_properties_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_properties_from_typedef(vtypedef)
    }

  }

  val e_properties_from_typedef : vx_core.Func_properties_from_typedef = vx_core.Class_properties_from_typedef()
  val t_properties_from_typedef : vx_core.Func_properties_from_typedef = vx_core.Class_properties_from_typedef()

  fun f_properties_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_argmap {
    var output : vx_core.Type_argmap = vx_core.e_argmap
    output = vtypedef.properties()
    return output
  }


  interface Func_proplast_from_typedef : vx_core.Func_any_from_any {
    fun vx_proplast_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_arg
  }

  class Class_proplast_from_typedef : vx_core.Class_base, Func_proplast_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_proplast_from_typedef {
      val output : vx_core.Class_proplast_from_typedef = vx_core.Class_proplast_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_proplast_from_typedef = vx_core.Class_proplast_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "proplast<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "arg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_proplast_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_proplast_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_proplast_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_proplast_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_arg vx_proplast_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_proplast_from_typedef(vtypedef)
    }

  }

  val e_proplast_from_typedef : vx_core.Func_proplast_from_typedef = vx_core.Class_proplast_from_typedef()
  val t_proplast_from_typedef : vx_core.Func_proplast_from_typedef = vx_core.Class_proplast_from_typedef()

  fun f_proplast_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_arg {
    var output : vx_core.Type_arg = vx_core.e_arg
    output = vtypedef.proplast()
    return output
  }


  interface Func_resolve : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_resolve(generic_any_1 : T, value : T) : T
  }

  class Class_resolve : vx_core.Class_base, Func_resolve {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_resolve {
      val output : vx_core.Class_resolve = vx_core.Class_resolve()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve = vx_core.Class_resolve()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_resolve(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve(generic_any_1, value)
      return output
    }

    fun <T : vx_core.Type_any> T vx_resolve(T generic_any_1, T value) {
      return vx_core.f_resolve(generic_any_1, value)
    }

  }

  val e_resolve : vx_core.Func_resolve = vx_core.Class_resolve()
  val t_resolve : vx_core.Func_resolve = vx_core.Class_resolve()

  fun <T : vx_core.Type_any> f_resolve(generic_any_1 : T, value : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = value
    return output
  }


  interface Func_resolve_1 : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_resolve_1(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T
  }

  class Class_resolve_1 : vx_core.Class_base, Func_resolve_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_resolve_1 {
      val output : vx_core.Class_resolve_1 = vx_core.Class_resolve_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_1 = vx_core.Class_resolve_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Func_any_from_func = value as vx_core.Func_any_from_func
      var outputval : vx_core.Type_any = vx_core.f_resolve_1(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve_1(generic_any_1, fn_any)
      return output
    }

    fun <T : vx_core.Type_any> T vx_resolve_1(T generic_any_1, vx_core.Func_any_from_func fn_any) {
      return vx_core.f_resolve_1(generic_any_1, fn_any)
    }

  }

  val e_resolve_1 : vx_core.Func_resolve_1 = vx_core.Class_resolve_1()
  val t_resolve_1 : vx_core.Func_resolve_1 = vx_core.Class_resolve_1()

  fun <T : vx_core.Type_any> f_resolve_1(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_resolve_async : vx_core.Func_any_from_any_async {
    fun <T : vx_core.Type_any> vx_resolve_async(generic_any_1 : T, fn_any : vx_core.Func_any_from_func_async) : <T>
  }

  class Class_resolve_async : vx_core.Class_base, Func_resolve_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_resolve_async {
      val output : vx_core.Class_resolve_async = vx_core.Class_resolve_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_async = vx_core.Class_resolve_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_async
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async {
      return vx_core.e_any_from_any_async
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : <T> {
      T inputval = vx_core.f_any_from_any(generic_any_1, value)
      <T> output = vx_core.f_async(generic_any_1, inputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : <vx_core.Type_any> {
      var output : vx_core.Type_any = await vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func_async = vx_core.f_any_from_any(vx_core.t_any_from_func_async, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : vx_core.Type_any = await vx_core.f_resolve_async(generic_any_1, fn_any)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    fun <T : vx_core.Type_any> <T> vx_resolve_async(T generic_any_1, vx_core.Func_any_from_func_async fn_any) {
      return vx_core.f_resolve_async(generic_any_1, fn_any)
    }

  }

  val e_resolve_async : vx_core.Func_resolve_async = vx_core.Class_resolve_async()
  val t_resolve_async : vx_core.Func_resolve_async = vx_core.Class_resolve_async()

  fun <T : vx_core.Type_any> f_resolve_async(generic_any_1 : T, fn_any : vx_core.Func_any_from_func_async) : <T> {
    <T> output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_resolve_first : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_resolve_first(generic_any_1 : T, clauses : X) : T
  }

  class Class_resolve_first : vx_core.Class_base, Func_resolve_first {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_resolve_first {
      val output : vx_core.Class_resolve_first = vx_core.Class_resolve_first()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_first = vx_core.Class_resolve_first()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve-first", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_first
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_first
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_resolve_first(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clauses : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve_first(generic_any_1, clauses)
      return output
    }

    fun <T : vx_core.Type_any, X : vx_core.Type_list> T vx_resolve_first(T generic_any_1, X clauses) {
      return vx_core.f_resolve_first(generic_any_1, clauses)
    }

  }

  val e_resolve_first : vx_core.Func_resolve_first = vx_core.Class_resolve_first()
  val t_resolve_first : vx_core.Func_resolve_first = vx_core.Class_resolve_first()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_resolve_first(generic_any_1 : T, clauses : X) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.f_first_from_list_any_from_any(
      generic_any_1,
      clauses,
      vx_core.t_resolve
    )
    return output
  }


  interface Func_resolve_list : vx_core.Func_any_from_any {
    fun <X : vx_core.Type_list> vx_resolve_list(generic_list_1 : X, clauses : X) : X
  }

  class Class_resolve_list : vx_core.Class_base, Func_resolve_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_resolve_list {
      val output : vx_core.Class_resolve_list = vx_core.Class_resolve_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_list = vx_core.Class_resolve_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_resolve_list(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var clauses : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve_list(generic_list_1, clauses)
      return output
    }

    fun <X : vx_core.Type_list> X vx_resolve_list(X generic_list_1, X clauses) {
      return vx_core.f_resolve_list(generic_list_1, clauses)
    }

  }

  val e_resolve_list : vx_core.Func_resolve_list = vx_core.Class_resolve_list()
  val t_resolve_list : vx_core.Func_resolve_list = vx_core.Class_resolve_list()

  fun <X : vx_core.Type_list> f_resolve_list(generic_list_1 : X, clauses : X) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_from_list_1(
      generic_list_1,
      clauses,
      vx_core.t_resolve
    )
    return output
  }


  interface Func_security_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_security_from_context(context : vx_core.Type_context) : vx_core.Type_security
  }

  class Class_security_from_context : vx_core.Class_base, Func_security_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_security_from_context {
      val output : vx_core.Class_security_from_context = vx_core.Class_security_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_security_from_context = vx_core.Class_security_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "security<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_security_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_security_from_context
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_security_from_context(context)
      return output
    }

    fun vx_core.Type_security vx_security_from_context(vx_core.Type_context context) {
      return vx_core.f_security_from_context(context)
    }

  }

  val e_security_from_context : vx_core.Func_security_from_context = vx_core.Class_security_from_context()
  val t_security_from_context : vx_core.Func_security_from_context = vx_core.Class_security_from_context()

  fun f_security_from_context(context : vx_core.Type_context) : vx_core.Type_security {
    var output : vx_core.Type_security = vx_core.e_security
    output = vx_core.f_security_from_user(
      vx_core.f_user_from_context(context)
    )
    return output
  }


  interface Func_security_from_user : vx_core.Func_any_from_any {
    fun vx_security_from_user(user : vx_core.Type_user) : vx_core.Type_security
  }

  class Class_security_from_user : vx_core.Class_base, Func_security_from_user {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_security_from_user {
      val output : vx_core.Class_security_from_user = vx_core.Class_security_from_user()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_security_from_user = vx_core.Class_security_from_user()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "security<-user", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_security_from_user
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_security_from_user
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_user = value as vx_core.Type_user
      var outputval : vx_core.Type_any = vx_core.f_security_from_user(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var user : vx_core.Type_user = vx_core.f_any_from_any(vx_core.t_user, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_security_from_user(user)
      return output
    }

    fun vx_core.Type_security vx_security_from_user(vx_core.Type_user user) {
      return vx_core.f_security_from_user(user)
    }

  }

  val e_security_from_user : vx_core.Func_security_from_user = vx_core.Class_security_from_user()
  val t_security_from_user : vx_core.Func_security_from_user = vx_core.Class_security_from_user()

  fun f_security_from_user(user : vx_core.Type_user) : vx_core.Type_security {
    var output : vx_core.Type_security = vx_core.e_security
    output = user.security()
    return output
  }


  interface Func_session_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_session_from_context(context : vx_core.Type_context) : vx_core.Type_session
  }

  class Class_session_from_context : vx_core.Class_base, Func_session_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_session_from_context {
      val output : vx_core.Class_session_from_context = vx_core.Class_session_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_session_from_context = vx_core.Class_session_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "session<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "session", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_session_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_session_from_context
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_session_from_context(context)
      return output
    }

    fun vx_core.Type_session vx_session_from_context(vx_core.Type_context context) {
      return vx_core.f_session_from_context(context)
    }

  }

  val e_session_from_context : vx_core.Func_session_from_context = vx_core.Class_session_from_context()
  val t_session_from_context : vx_core.Func_session_from_context = vx_core.Class_session_from_context()

  fun f_session_from_context(context : vx_core.Type_context) : vx_core.Type_session {
    var output : vx_core.Type_session = vx_core.e_session
    output = context.session()
    return output
  }


  interface Func_setting_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_setting_from_context(context : vx_core.Type_context) : vx_core.Type_setting
  }

  class Class_setting_from_context : vx_core.Class_base, Func_setting_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_setting_from_context {
      val output : vx_core.Class_setting_from_context = vx_core.Class_setting_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_setting_from_context = vx_core.Class_setting_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "setting<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "setting", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_setting_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_setting_from_context
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_setting_from_context(context)
      return output
    }

    fun vx_core.Type_setting vx_setting_from_context(vx_core.Type_context context) {
      return vx_core.f_setting_from_context(context)
    }

  }

  val e_setting_from_context : vx_core.Func_setting_from_context = vx_core.Class_setting_from_context()
  val t_setting_from_context : vx_core.Func_setting_from_context = vx_core.Class_setting_from_context()

  fun f_setting_from_context(context : vx_core.Type_context) : vx_core.Type_setting {
    var output : vx_core.Type_setting = vx_core.e_setting
    output = context.setting()
    return output
  }


  interface Func_string_repeat : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_repeat(text : vx_core.Type_string, repeat : vx_core.Type_int) : vx_core.Type_string
  }

  class Class_string_repeat : vx_core.Class_base, Func_string_repeat {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_string_repeat {
      val output : vx_core.Class_string_repeat = vx_core.Class_string_repeat()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_repeat = vx_core.Class_string_repeat()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string-repeat", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_repeat
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_repeat
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var repeat : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_string_repeat(text, repeat)
      return output
    }

    fun vx_core.Type_string vx_string_repeat(vx_core.Type_string text, vx_core.Type_int repeat) {
      return vx_core.f_string_repeat(text, repeat)
    }

  }

  val e_string_repeat : vx_core.Func_string_repeat = vx_core.Class_string_repeat()
  val t_string_repeat : vx_core.Func_string_repeat = vx_core.Class_string_repeat()

  fun f_string_repeat(text : vx_core.Type_string, repeat : vx_core.Type_int) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_string_from_any : vx_core.Func_any_from_any {
    fun vx_string_from_any(value : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_string_from_any : vx_core.Class_base, Func_string_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_string_from_any {
      val output : vx_core.Class_string_from_any = vx_core.Class_string_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_any = vx_core.Class_string_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_string_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_string_from_any(value)
      return output
    }

    fun vx_core.Type_string vx_string_from_any(vx_core.Type_any value) {
      return vx_core.f_string_from_any(value)
    }

  }

  val e_string_from_any : vx_core.Func_string_from_any = vx_core.Class_string_from_any()
  val t_string_from_any : vx_core.Func_string_from_any = vx_core.Class_string_from_any()

  fun f_string_from_any(value : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_string_from_any_indent(
      value,
      vx_core.vx_new_int(0),
      vx_core.vx_new_boolean(true)
    )
    return output
  }


  interface Func_string_from_any_indent : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_from_any_indent(value : vx_core.Type_any, indent : vx_core.Type_int, linefeed : vx_core.Type_boolean) : vx_core.Type_string
  }

  class Class_string_from_any_indent : vx_core.Class_base, Func_string_from_any_indent {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_string_from_any_indent {
      val output : vx_core.Class_string_from_any_indent = vx_core.Class_string_from_any_indent()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_any_indent = vx_core.Class_string_from_any_indent()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-any-indent", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_any_indent
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_any_indent
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var indent : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      var linefeed : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_string_from_any_indent(value, indent, linefeed)
      return output
    }

    fun vx_core.Type_string vx_string_from_any_indent(vx_core.Type_any value, vx_core.Type_int indent, vx_core.Type_boolean linefeed) {
      return vx_core.f_string_from_any_indent(value, indent, linefeed)
    }

  }

  val e_string_from_any_indent : vx_core.Func_string_from_any_indent = vx_core.Class_string_from_any_indent()
  val t_string_from_any_indent : vx_core.Func_string_from_any_indent = vx_core.Class_string_from_any_indent()

  fun f_string_from_any_indent(value : vx_core.Type_any, indent : vx_core.Type_int, linefeed : vx_core.Type_boolean) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_string_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_from_func() : vx_core.Type_string
    fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_string_from_func
  }

  class Class_string_from_func : vx_core.Class_base, Func_string_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_string_from_func {
      val output : vx_core.Class_string_from_func = vx_core.Class_string_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_func = vx_core.Class_string_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_func
      return output
    }

    var fn : vx_core.Class_any_from_func.IFn = null

    override fun vx_fn_new(fn : vx_core.Class_any_from_func.IFn) : vx_core.Func_string_from_func {
      val output : vx_core.Class_string_from_func = vx_core.Class_string_from_func()
      output.fn = fn
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_string_from_func()
      return output
    }

    fun vx_core.Type_string vx_string_from_func() {
      return vx_core.f_string_from_func()
    }

  }

  val e_string_from_func : vx_core.Func_string_from_func = vx_core.Class_string_from_func()
  val t_string_from_func : vx_core.Func_string_from_func = vx_core.Class_string_from_func()

  fun f_string_from_func() : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_string_from_string_find_replace : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_from_string_find_replace(text : vx_core.Type_string, find : vx_core.Type_string, replace : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_string_from_string_find_replace : vx_core.Class_base, Func_string_from_string_find_replace {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_string_from_string_find_replace {
      val output : vx_core.Class_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-string-find-replace", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_string_find_replace
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_string_find_replace
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var replace : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_string_from_string_find_replace(text, find, replace)
      return output
    }

    fun vx_core.Type_string vx_string_from_string_find_replace(vx_core.Type_string text, vx_core.Type_string find, vx_core.Type_string replace) {
      return vx_core.f_string_from_string_find_replace(text, find, replace)
    }

  }

  val e_string_from_string_find_replace : vx_core.Func_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()
  val t_string_from_string_find_replace : vx_core.Func_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()

  fun f_string_from_string_find_replace(text : vx_core.Type_string, find : vx_core.Type_string, replace : vx_core.Type_string) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_stringlist_from_map : vx_core.Func_any_from_any {
    fun vx_stringlist_from_map(map : vx_core.Type_map) : vx_core.Type_stringlist
  }

  class Class_stringlist_from_map : vx_core.Class_base, Func_stringlist_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_stringlist_from_map {
      val output : vx_core.Class_stringlist_from_map = vx_core.Class_stringlist_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_stringlist_from_map = vx_core.Class_stringlist_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "stringlist<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringlist_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringlist_from_map
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_stringlist_from_map(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_stringlist_from_map(map)
      return output
    }

    fun vx_core.Type_stringlist vx_stringlist_from_map(vx_core.Type_map map) {
      return vx_core.f_stringlist_from_map(map)
    }

  }

  val e_stringlist_from_map : vx_core.Func_stringlist_from_map = vx_core.Class_stringlist_from_map()
  val t_stringlist_from_map : vx_core.Func_stringlist_from_map = vx_core.Class_stringlist_from_map()

  fun f_stringlist_from_map(map : vx_core.Type_map) : vx_core.Type_stringlist {
    var output : vx_core.Type_stringlist = vx_core.e_stringlist
    output = vx_core.f_list_from_map_1(
      vx_core.t_stringlist,
      map,
      vx_core.t_any_from_key_value.vx_fn_new((key_any, value_any)  {
        vx_core.Type_string key = vx_core.f_any_from_any(vx_core.t_string, key_any)
        vx_core.Type_any value = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = key
        return output_1
      })
    )
    return output
  }


  interface Func_switch : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_switch(generic_any_1 : T, val : U, thenelselist : vx_core.Type_thenelselist) : T
  }

  class Class_switch : vx_core.Class_base, Func_switch {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_switch {
      val output : vx_core.Class_switch = vx_core.Class_switch()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_switch = vx_core.Class_switch()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "switch", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_switch
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_switch
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var thenelselist : vx_core.Type_thenelselist = vx_core.f_any_from_any(vx_core.t_thenelselist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_switch(generic_any_1, val, thenelselist)
      return output
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> T vx_switch(T generic_any_1, U val, vx_core.Type_thenelselist thenelselist) {
      return vx_core.f_switch(generic_any_1, val, thenelselist)
    }

  }

  val e_switch : vx_core.Func_switch = vx_core.Class_switch()
  val t_switch : vx_core.Func_switch = vx_core.Class_switch()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_switch(generic_any_1 : T, val : U, thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_then : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_then(fn_cond : vx_core.Func_boolean_from_func, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_then : vx_core.Class_base, Func_then {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_then {
      val output : vx_core.Class_then = vx_core.Class_then()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_then = vx_core.Class_then()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "then", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_then
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_then
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var fn_cond : vx_core.Func_boolean_from_func = vx_core.f_any_from_any(vx_core.t_boolean_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_then(fn_cond, fn_any)
      return output
    }

    fun vx_core.Type_thenelse vx_then(vx_core.Func_boolean_from_func fn_cond, vx_core.Func_any_from_func fn_any) {
      return vx_core.f_then(fn_cond, fn_any)
    }

  }

  val e_then : vx_core.Func_then = vx_core.Class_then()
  val t_then : vx_core.Func_then = vx_core.Class_then()

  fun f_then(fn_cond : vx_core.Func_boolean_from_func, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":then"),
        vx_core.vx_new_string(":fn-cond"),
        fn_cond,
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_traits_from_typedef : vx_core.Func_any_from_any {
    fun vx_traits_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist
  }

  class Class_traits_from_typedef : vx_core.Class_base, Func_traits_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_traits_from_typedef {
      val output : vx_core.Class_traits_from_typedef = vx_core.Class_traits_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_traits_from_typedef = vx_core.Class_traits_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "traits<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_traits_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_traits_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_traits_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_traits_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_typelist vx_traits_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_traits_from_typedef(vtypedef)
    }

  }

  val e_traits_from_typedef : vx_core.Func_traits_from_typedef = vx_core.Class_traits_from_typedef()
  val t_traits_from_typedef : vx_core.Func_traits_from_typedef = vx_core.Class_traits_from_typedef()

  fun f_traits_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist {
    var output : vx_core.Type_typelist = vx_core.e_typelist
    return output
  }


  interface Func_type_from_any : vx_core.Func_any_from_any {
    fun vx_type_from_any(value : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_type_from_any : vx_core.Class_base, Func_type_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_type_from_any {
      val output : vx_core.Class_type_from_any = vx_core.Class_type_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_type_from_any = vx_core.Class_type_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "type<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_type_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_type_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_type_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_type_from_any(value)
      return output
    }

    fun vx_core.Type_any vx_type_from_any(vx_core.Type_any value) {
      return vx_core.f_type_from_any(value)
    }

  }

  val e_type_from_any : vx_core.Func_type_from_any = vx_core.Class_type_from_any()
  val t_type_from_any : vx_core.Func_type_from_any = vx_core.Class_type_from_any()

  fun f_type_from_any(value : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_typedef_from_any : vx_core.Func_any_from_any {
    fun vx_typedef_from_any(val : vx_core.Type_any) : vx_core.Type_typedef
  }

  class Class_typedef_from_any : vx_core.Class_base, Func_typedef_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_typedef_from_any {
      val output : vx_core.Class_typedef_from_any = vx_core.Class_typedef_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typedef_from_any = vx_core.Class_typedef_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typedef_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typedef_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typedef_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typedef_from_any(val)
      return output
    }

    fun vx_core.Type_typedef vx_typedef_from_any(vx_core.Type_any val) {
      return vx_core.f_typedef_from_any(val)
    }

  }

  val e_typedef_from_any : vx_core.Func_typedef_from_any = vx_core.Class_typedef_from_any()
  val t_typedef_from_any : vx_core.Func_typedef_from_any = vx_core.Class_typedef_from_any()

  fun f_typedef_from_any(val : vx_core.Type_any) : vx_core.Type_typedef {
    var output : vx_core.Type_typedef = vx_core.e_typedef
    output = vx_core.f_typedef_from_type(
      vx_core.f_type_from_any(val)
    )
    return output
  }


  interface Func_typedef_from_type : vx_core.Func_any_from_any {
    fun vx_typedef_from_type(val : vx_core.Type_any) : vx_core.Type_typedef
  }

  class Class_typedef_from_type : vx_core.Class_base, Func_typedef_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_typedef_from_type {
      val output : vx_core.Class_typedef_from_type = vx_core.Class_typedef_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typedef_from_type = vx_core.Class_typedef_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typedef_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typedef_from_type
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typedef_from_type(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typedef_from_type(val)
      return output
    }

    fun vx_core.Type_typedef vx_typedef_from_type(vx_core.Type_any val) {
      return vx_core.f_typedef_from_type(val)
    }

  }

  val e_typedef_from_type : vx_core.Func_typedef_from_type = vx_core.Class_typedef_from_type()
  val t_typedef_from_type : vx_core.Func_typedef_from_type = vx_core.Class_typedef_from_type()

  fun f_typedef_from_type(val : vx_core.Type_any) : vx_core.Type_typedef {
    var output : vx_core.Type_typedef = vx_core.e_typedef
    return output
  }


  interface Func_typename_from_any : vx_core.Func_any_from_any {
    fun vx_typename_from_any(value : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_typename_from_any : vx_core.Class_base, Func_typename_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_typename_from_any {
      val output : vx_core.Class_typename_from_any = vx_core.Class_typename_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_any = vx_core.Class_typename_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typename<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typename_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typename_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typename_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typename_from_any(value)
      return output
    }

    fun vx_core.Type_string vx_typename_from_any(vx_core.Type_any value) {
      return vx_core.f_typename_from_any(value)
    }

  }

  val e_typename_from_any : vx_core.Func_typename_from_any = vx_core.Class_typename_from_any()
  val t_typename_from_any : vx_core.Func_typename_from_any = vx_core.Class_typename_from_any()

  fun f_typename_from_any(value : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_typename_from_type(
      vx_core.f_type_from_any(value)
    )
    return output
  }


  interface Func_typename_from_type : vx_core.Func_any_from_any {
    fun vx_typename_from_type(type : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_typename_from_type : vx_core.Class_base, Func_typename_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_typename_from_type {
      val output : vx_core.Class_typename_from_type = vx_core.Class_typename_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_type = vx_core.Class_typename_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typename<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typename_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typename_from_type
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typename_from_type(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typename_from_type(type)
      return output
    }

    fun vx_core.Type_string vx_typename_from_type(vx_core.Type_any type) {
      return vx_core.f_typename_from_type(type)
    }

  }

  val e_typename_from_type : vx_core.Func_typename_from_type = vx_core.Class_typename_from_type()
  val t_typename_from_type : vx_core.Func_typename_from_type = vx_core.Class_typename_from_type()

  fun f_typename_from_type(type : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_typename_from_typedef(
      vx_core.f_typedef_from_type(type)
    )
    return output
  }


  interface Func_typename_from_typedef : vx_core.Func_any_from_any {
    fun vx_typename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_typename_from_typedef : vx_core.Class_base, Func_typename_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_typename_from_typedef {
      val output : vx_core.Class_typename_from_typedef = vx_core.Class_typename_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_typedef = vx_core.Class_typename_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typename<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typename_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typename_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_typename_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typename_from_typedef(vtypedef)
      return output
    }

    fun vx_core.Type_string vx_typename_from_typedef(vx_core.Type_typedef vtypedef) {
      return vx_core.f_typename_from_typedef(vtypedef)
    }

  }

  val e_typename_from_typedef : vx_core.Func_typename_from_typedef = vx_core.Class_typename_from_typedef()
  val t_typename_from_typedef : vx_core.Func_typename_from_typedef = vx_core.Class_typename_from_typedef()

  fun f_typename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_new(
      vx_core.t_string,
      vx_core.vx_new(
        vx_core.t_anylist,
        vtypedef.pkgname(),
        vx_core.vx_new_string("/"),
        vtypedef.name()
      )
    )
    return output
  }


  interface Func_typenames_from_typelist : vx_core.Func_any_from_any {
    fun vx_typenames_from_typelist(typelist : vx_core.Type_typelist) : vx_core.Type_stringlist
  }

  class Class_typenames_from_typelist : vx_core.Class_base, Func_typenames_from_typelist {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_typenames_from_typelist {
      val output : vx_core.Class_typenames_from_typelist = vx_core.Class_typenames_from_typelist()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typenames_from_typelist = vx_core.Class_typenames_from_typelist()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typenames<-typelist", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typenames_from_typelist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typenames_from_typelist
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typelist = value as vx_core.Type_typelist
      var outputval : vx_core.Type_any = vx_core.f_typenames_from_typelist(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var typelist : vx_core.Type_typelist = vx_core.f_any_from_any(vx_core.t_typelist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typenames_from_typelist(typelist)
      return output
    }

    fun vx_core.Type_stringlist vx_typenames_from_typelist(vx_core.Type_typelist typelist) {
      return vx_core.f_typenames_from_typelist(typelist)
    }

  }

  val e_typenames_from_typelist : vx_core.Func_typenames_from_typelist = vx_core.Class_typenames_from_typelist()
  val t_typenames_from_typelist : vx_core.Func_typenames_from_typelist = vx_core.Class_typenames_from_typelist()

  fun f_typenames_from_typelist(typelist : vx_core.Type_typelist) : vx_core.Type_stringlist {
    var output : vx_core.Type_stringlist = vx_core.e_stringlist
    output = vx_core.f_list_from_list_1(
      vx_core.t_stringlist,
      typelist,
      vx_core.t_any_from_any.vx_fn_new((type_any)  {
        vx_core.Type_any type = vx_core.f_any_from_any(vx_core.t_any, type_any)
        var output_1 : vx_core.Type_any = 
          vx_core.f_typename_from_type(type)
        return output_1
      })
    )
    return output
  }


  interface Func_user_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_user_from_context(context : vx_core.Type_context) : vx_core.Type_user
  }

  class Class_user_from_context : vx_core.Class_base, Func_user_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Func_user_from_context {
      val output : vx_core.Class_user_from_context = vx_core.Class_user_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_user_from_context = vx_core.Class_user_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "user<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "user", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_user_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_user_from_context
      return output
    }

    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_user_from_context(context)
      return output
    }

    fun vx_core.Type_user vx_user_from_context(vx_core.Type_context context) {
      return vx_core.f_user_from_context(context)
    }

  }

  val e_user_from_context : vx_core.Func_user_from_context = vx_core.Class_user_from_context()
  val t_user_from_context : vx_core.Func_user_from_context = vx_core.Class_user_from_context()

  fun f_user_from_context(context : vx_core.Type_context) : vx_core.Type_user {
    var output : vx_core.Type_user = vx_core.e_user
    output = vx_core.f_session_from_context(context).user()
    return output
  }


  init {
    Const_false.const_new(c_false)
    Const_global.const_new(c_global)
    Const_infinity.const_new(c_infinity)
    Const_mempool_active.const_new(c_mempool_active)
    Const_msg_error.const_new(c_msg_error)
    Const_msg_info.const_new(c_msg_info)
    Const_msg_severe.const_new(c_msg_severe)
    Const_msg_warning.const_new(c_msg_warning)
    Const_neginfinity.const_new(c_neginfinity)
    Const_newline.const_new(c_newline)
    Const_notanumber.const_new(c_notanumber)
    Const_nothing.const_new(c_nothing)
    Const_path_test_resources.const_new(c_path_test_resources)
    Const_quote.const_new(c_quote)
    Const_true.const_new(c_true)
    var maptype : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
    var mapconst : Map<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
    var mapfunc : Map<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>()
    maptype.put("any", vx_core.t_any)
    maptype.put("any-async<-func", vx_core.t_any_async_from_func)
    maptype.put("any<-anylist", vx_core.t_any_from_anylist)
    maptype.put("anylist", vx_core.t_anylist)
    maptype.put("anymap", vx_core.t_anymap)
    maptype.put("anytype", vx_core.t_anytype)
    maptype.put("arg", vx_core.t_arg)
    maptype.put("arglist", vx_core.t_arglist)
    maptype.put("argmap", vx_core.t_argmap)
    maptype.put("boolean", vx_core.t_boolean)
    maptype.put("booleanlist", vx_core.t_booleanlist)
    maptype.put("collection", vx_core.t_collection)
    maptype.put("compilelanguages", vx_core.t_compilelanguages)
    maptype.put("connect", vx_core.t_connect)
    maptype.put("connectlist", vx_core.t_connectlist)
    maptype.put("connectmap", vx_core.t_connectmap)
    maptype.put("const", vx_core.t_const)
    maptype.put("constdef", vx_core.t_constdef)
    maptype.put("constlist", vx_core.t_constlist)
    maptype.put("constmap", vx_core.t_constmap)
    maptype.put("context", vx_core.t_context)
    maptype.put("date", vx_core.t_date)
    maptype.put("decimal", vx_core.t_decimal)
    maptype.put("error", vx_core.t_error)
    maptype.put("float", vx_core.t_float)
    maptype.put("func", vx_core.t_func)
    maptype.put("funcdef", vx_core.t_funcdef)
    maptype.put("funclist", vx_core.t_funclist)
    maptype.put("funcmap", vx_core.t_funcmap)
    maptype.put("int", vx_core.t_int)
    maptype.put("intlist", vx_core.t_intlist)
    maptype.put("intmap", vx_core.t_intmap)
    maptype.put("list", vx_core.t_list)
    maptype.put("listtype", vx_core.t_listtype)
    maptype.put("locale", vx_core.t_locale)
    maptype.put("map", vx_core.t_map)
    maptype.put("maptype", vx_core.t_maptype)
    maptype.put("mempool", vx_core.t_mempool)
    maptype.put("msg", vx_core.t_msg)
    maptype.put("msgblock", vx_core.t_msgblock)
    maptype.put("msgblocklist", vx_core.t_msgblocklist)
    maptype.put("msglist", vx_core.t_msglist)
    maptype.put("none", vx_core.t_none)
    maptype.put("notype", vx_core.t_notype)
    maptype.put("number", vx_core.t_number)
    maptype.put("numberlist", vx_core.t_numberlist)
    maptype.put("numbermap", vx_core.t_numbermap)
    maptype.put("package", vx_core.t_package)
    maptype.put("packagemap", vx_core.t_packagemap)
    maptype.put("permission", vx_core.t_permission)
    maptype.put("permissionlist", vx_core.t_permissionlist)
    maptype.put("permissionmap", vx_core.t_permissionmap)
    maptype.put("project", vx_core.t_project)
    maptype.put("security", vx_core.t_security)
    maptype.put("session", vx_core.t_session)
    maptype.put("setting", vx_core.t_setting)
    maptype.put("state", vx_core.t_state)
    maptype.put("statelistener", vx_core.t_statelistener)
    maptype.put("statelistenermap", vx_core.t_statelistenermap)
    maptype.put("string", vx_core.t_string)
    maptype.put("stringlist", vx_core.t_stringlist)
    maptype.put("stringlistlist", vx_core.t_stringlistlist)
    maptype.put("stringmap", vx_core.t_stringmap)
    maptype.put("stringmutablemap", vx_core.t_stringmutablemap)
    maptype.put("struct", vx_core.t_struct)
    maptype.put("thenelse", vx_core.t_thenelse)
    maptype.put("thenelselist", vx_core.t_thenelselist)
    maptype.put("translation", vx_core.t_translation)
    maptype.put("translationlist", vx_core.t_translationlist)
    maptype.put("translationmap", vx_core.t_translationmap)
    maptype.put("type", vx_core.t_type)
    maptype.put("typedef", vx_core.t_typedef)
    maptype.put("typelist", vx_core.t_typelist)
    maptype.put("typemap", vx_core.t_typemap)
    maptype.put("user", vx_core.t_user)
    maptype.put("value", vx_core.t_value)
    mapconst.put("false", vx_core.c_false)
    mapconst.put("global", vx_core.c_global)
    mapconst.put("infinity", vx_core.c_infinity)
    mapconst.put("mempool-active", vx_core.c_mempool_active)
    mapconst.put("msg-error", vx_core.c_msg_error)
    mapconst.put("msg-info", vx_core.c_msg_info)
    mapconst.put("msg-severe", vx_core.c_msg_severe)
    mapconst.put("msg-warning", vx_core.c_msg_warning)
    mapconst.put("neginfinity", vx_core.c_neginfinity)
    mapconst.put("newline", vx_core.c_newline)
    mapconst.put("notanumber", vx_core.c_notanumber)
    mapconst.put("nothing", vx_core.c_nothing)
    mapconst.put("path-test-resources", vx_core.c_path_test_resources)
    mapconst.put("quote", vx_core.c_quote)
    mapconst.put("true", vx_core.c_true)
    mapfunc.put("!", vx_core.t_not)
    mapfunc.put("!-empty", vx_core.t_notempty)
    mapfunc.put("!-empty_1", vx_core.t_notempty_1)
    mapfunc.put("!=", vx_core.t_ne)
    mapfunc.put("!==", vx_core.t_neqeq)
    mapfunc.put("*", vx_core.t_multiply)
    mapfunc.put("*_1", vx_core.t_multiply_1)
    mapfunc.put("*_2", vx_core.t_multiply_2)
    mapfunc.put("*_3", vx_core.t_multiply_3)
    mapfunc.put("+", vx_core.t_plus)
    mapfunc.put("+_1", vx_core.t_plus_1)
    mapfunc.put("+_2", vx_core.t_plus_2)
    mapfunc.put("+_3", vx_core.t_plus_3)
    mapfunc.put("+1", vx_core.t_plus1)
    mapfunc.put("-", vx_core.t_minus)
    mapfunc.put("-_1", vx_core.t_minus_1)
    mapfunc.put("-_2", vx_core.t_minus_2)
    mapfunc.put("-_3", vx_core.t_minus_3)
    mapfunc.put("-1", vx_core.t_minus1)
    mapfunc.put(".", vx_core.t_dotmethod)
    mapfunc.put("/", vx_core.t_divide)
    mapfunc.put("<", vx_core.t_lt)
    mapfunc.put("<_1", vx_core.t_lt_1)
    mapfunc.put("<-", vx_core.t_chainfirst)
    mapfunc.put("<<-", vx_core.t_chainlast)
    mapfunc.put("<=", vx_core.t_le)
    mapfunc.put("<=_1", vx_core.t_le_1)
    mapfunc.put("=", vx_core.t_eq)
    mapfunc.put("=_1", vx_core.t_eq_1)
    mapfunc.put("==", vx_core.t_eqeq)
    mapfunc.put(">", vx_core.t_gt)
    mapfunc.put(">_1", vx_core.t_gt_1)
    mapfunc.put(">=", vx_core.t_ge)
    mapfunc.put(">=_1", vx_core.t_ge_1)
    mapfunc.put("allowfuncs<-security", vx_core.t_allowfuncs_from_security)
    mapfunc.put("allowtypenames<-typedef", vx_core.t_allowtypenames_from_typedef)
    mapfunc.put("allowtypes<-typedef", vx_core.t_allowtypes_from_typedef)
    mapfunc.put("and", vx_core.t_and)
    mapfunc.put("and_1", vx_core.t_and_1)
    mapfunc.put("any<-any", vx_core.t_any_from_any)
    mapfunc.put("any<-any-async", vx_core.t_any_from_any_async)
    mapfunc.put("any<-any-context", vx_core.t_any_from_any_context)
    mapfunc.put("any<-any-context-async", vx_core.t_any_from_any_context_async)
    mapfunc.put("any<-any-key-value", vx_core.t_any_from_any_key_value)
    mapfunc.put("any<-func", vx_core.t_any_from_func)
    mapfunc.put("any<-func-async", vx_core.t_any_from_func_async)
    mapfunc.put("any<-int", vx_core.t_any_from_int)
    mapfunc.put("any<-int-any", vx_core.t_any_from_int_any)
    mapfunc.put("any<-key-value", vx_core.t_any_from_key_value)
    mapfunc.put("any<-key-value-async", vx_core.t_any_from_key_value_async)
    mapfunc.put("any<-list", vx_core.t_any_from_list)
    mapfunc.put("any<-list-start-reduce", vx_core.t_any_from_list_start_reduce)
    mapfunc.put("any<-list-start-reduce-next", vx_core.t_any_from_list_start_reduce_next)
    mapfunc.put("any<-map", vx_core.t_any_from_map)
    mapfunc.put("any<-map-start-reduce", vx_core.t_any_from_map_start_reduce)
    mapfunc.put("any<-none", vx_core.t_any_from_none)
    mapfunc.put("any<-none-async", vx_core.t_any_from_none_async)
    mapfunc.put("any<-reduce", vx_core.t_any_from_reduce)
    mapfunc.put("any<-reduce-async", vx_core.t_any_from_reduce_async)
    mapfunc.put("any<-reduce-next", vx_core.t_any_from_reduce_next)
    mapfunc.put("any<-reduce-next-async", vx_core.t_any_from_reduce_next_async)
    mapfunc.put("any<-struct", vx_core.t_any_from_struct)
    mapfunc.put("async", vx_core.t_async)
    mapfunc.put("boolean-permission<-func", vx_core.t_boolean_permission_from_func)
    mapfunc.put("boolean-write<-map-name-value", vx_core.t_boolean_write_from_map_name_value)
    mapfunc.put("boolean<-any", vx_core.t_boolean_from_any)
    mapfunc.put("boolean<-func", vx_core.t_boolean_from_func)
    mapfunc.put("boolean<-none", vx_core.t_boolean_from_none)
    mapfunc.put("case", vx_core.t_case)
    mapfunc.put("case_1", vx_core.t_case_1)
    mapfunc.put("compare", vx_core.t_compare)
    mapfunc.put("contains", vx_core.t_contains)
    mapfunc.put("contains_1", vx_core.t_contains_1)
    mapfunc.put("context-main", vx_core.t_context_main)
    mapfunc.put("copy", vx_core.t_copy)
    mapfunc.put("else", vx_core.t_else)
    mapfunc.put("empty", vx_core.t_empty)
    mapfunc.put("extends<-any", vx_core.t_extends_from_any)
    mapfunc.put("extends<-typedef", vx_core.t_extends_from_typedef)
    mapfunc.put("first<-list", vx_core.t_first_from_list)
    mapfunc.put("first<-list-any<-any", vx_core.t_first_from_list_any_from_any)
    mapfunc.put("float<-string", vx_core.t_float_from_string)
    mapfunc.put("fn", vx_core.t_fn)
    mapfunc.put("funcdef<-func", vx_core.t_funcdef_from_func)
    mapfunc.put("funcname<-funcdef", vx_core.t_funcname_from_funcdef)
    mapfunc.put("if", vx_core.t_if)
    mapfunc.put("if_1", vx_core.t_if_1)
    mapfunc.put("if_2", vx_core.t_if_2)
    mapfunc.put("int<-func", vx_core.t_int_from_func)
    mapfunc.put("int<-string", vx_core.t_int_from_string)
    mapfunc.put("is-empty", vx_core.t_is_empty)
    mapfunc.put("is-empty_1", vx_core.t_is_empty_1)
    mapfunc.put("is-endswith", vx_core.t_is_endswith)
    mapfunc.put("is-float", vx_core.t_is_float)
    mapfunc.put("is-func", vx_core.t_is_func)
    mapfunc.put("is-int", vx_core.t_is_int)
    mapfunc.put("is-number", vx_core.t_is_number)
    mapfunc.put("is-pass<-permission", vx_core.t_is_pass_from_permission)
    mapfunc.put("last<-list", vx_core.t_last_from_list)
    mapfunc.put("length", vx_core.t_length)
    mapfunc.put("length_1", vx_core.t_length_1)
    mapfunc.put("length_2", vx_core.t_length_2)
    mapfunc.put("let", vx_core.t_let)
    mapfunc.put("let-async", vx_core.t_let_async)
    mapfunc.put("list-join<-list", vx_core.t_list_join_from_list)
    mapfunc.put("list-join<-list_1", vx_core.t_list_join_from_list_1)
    mapfunc.put("list<-list", vx_core.t_list_from_list)
    mapfunc.put("list<-list_1", vx_core.t_list_from_list_1)
    mapfunc.put("list<-list-async", vx_core.t_list_from_list_async)
    mapfunc.put("list<-list-intany", vx_core.t_list_from_list_intany)
    mapfunc.put("list<-map", vx_core.t_list_from_map)
    mapfunc.put("list<-map_1", vx_core.t_list_from_map_1)
    mapfunc.put("list<-map-async", vx_core.t_list_from_map_async)
    mapfunc.put("list<-type", vx_core.t_list_from_type)
    mapfunc.put("log", vx_core.t_log)
    mapfunc.put("log_1", vx_core.t_log_1)
    mapfunc.put("main", vx_core.t_main)
    mapfunc.put("map<-list", vx_core.t_map_from_list)
    mapfunc.put("map<-map", vx_core.t_map_from_map)
    mapfunc.put("map<-map_1", vx_core.t_map_from_map_1)
    mapfunc.put("msg<-error", vx_core.t_msg_from_error)
    mapfunc.put("msg<-error_1", vx_core.t_msg_from_error_1)
    mapfunc.put("msg<-error_2", vx_core.t_msg_from_error_2)
    mapfunc.put("msg<-warning", vx_core.t_msg_from_warning)
    mapfunc.put("msgblock<-msgblock-msg", vx_core.t_msgblock_from_msgblock_msg)
    mapfunc.put("msgblock<-msgblock-msgblock", vx_core.t_msgblock_from_msgblock_msgblock)
    mapfunc.put("name<-typedef", vx_core.t_name_from_typedef)
    mapfunc.put("native", vx_core.t_native)
    mapfunc.put("native<-any", vx_core.t_native_from_any)
    mapfunc.put("new", vx_core.t_new)
    mapfunc.put("number<-func", vx_core.t_number_from_func)
    mapfunc.put("or", vx_core.t_or)
    mapfunc.put("or_1", vx_core.t_or_1)
    mapfunc.put("package-global<-name", vx_core.t_package_global_from_name)
    mapfunc.put("packagename<-typedef", vx_core.t_packagename_from_typedef)
    mapfunc.put("path<-context-path", vx_core.t_path_from_context_path)
    mapfunc.put("path<-setting-path", vx_core.t_path_from_setting_path)
    mapfunc.put("permission<-id-context", vx_core.t_permission_from_id_context)
    mapfunc.put("properties<-typedef", vx_core.t_properties_from_typedef)
    mapfunc.put("proplast<-typedef", vx_core.t_proplast_from_typedef)
    mapfunc.put("resolve", vx_core.t_resolve)
    mapfunc.put("resolve_1", vx_core.t_resolve_1)
    mapfunc.put("resolve-async", vx_core.t_resolve_async)
    mapfunc.put("resolve-first", vx_core.t_resolve_first)
    mapfunc.put("resolve-list", vx_core.t_resolve_list)
    mapfunc.put("security<-context", vx_core.t_security_from_context)
    mapfunc.put("security<-user", vx_core.t_security_from_user)
    mapfunc.put("session<-context", vx_core.t_session_from_context)
    mapfunc.put("setting<-context", vx_core.t_setting_from_context)
    mapfunc.put("string-repeat", vx_core.t_string_repeat)
    mapfunc.put("string<-any", vx_core.t_string_from_any)
    mapfunc.put("string<-any-indent", vx_core.t_string_from_any_indent)
    mapfunc.put("string<-func", vx_core.t_string_from_func)
    mapfunc.put("string<-string-find-replace", vx_core.t_string_from_string_find_replace)
    mapfunc.put("stringlist<-map", vx_core.t_stringlist_from_map)
    mapfunc.put("switch", vx_core.t_switch)
    mapfunc.put("then", vx_core.t_then)
    mapfunc.put("traits<-typedef", vx_core.t_traits_from_typedef)
    mapfunc.put("type<-any", vx_core.t_type_from_any)
    mapfunc.put("typedef<-any", vx_core.t_typedef_from_any)
    mapfunc.put("typedef<-type", vx_core.t_typedef_from_type)
    mapfunc.put("typename<-any", vx_core.t_typename_from_any)
    mapfunc.put("typename<-type", vx_core.t_typename_from_type)
    mapfunc.put("typename<-typedef", vx_core.t_typename_from_typedef)
    mapfunc.put("typenames<-typelist", vx_core.t_typenames_from_typelist)
    mapfunc.put("user<-context", vx_core.t_user_from_context)
    vx_core.vx_global_package_set("vx/core", maptype, mapconst, mapfunc)
  }

}
