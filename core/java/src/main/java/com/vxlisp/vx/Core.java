package com.vxlisp.vx;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.*;
import java.util.stream.Collectors;

public final class Core {

  public interface Type_replfunc {
    public Core.Type_any vx_repl(Core.Type_anylist arglist);
  }

  public interface Type_replfunc_async {
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist);
  }

  public static List<Core.Type_any> emptylistany = Core.immutablelist(new ArrayList<Core.Type_any>());

  public static Map<String, Core.Type_any> emptymapany = Core.immutablemap(new LinkedHashMap<String, Core.Type_any>());

  public static <T> List<T> immutablelist(List<T> listany) {
    return Collections.unmodifiableList(listany);
  }

  public static <T> Map<String, T> immutablemap(Map<String, T> mapany) {
    return Collections.unmodifiableMap(mapany);
  }

  public static class Class_base {
    protected int vx_iref = 0;
    protected Core.Type_msgblock vxmsgblock = null;
    public Core.Type_constdef vx_p_constdef = null;
    public Core.Type_constdef vx_constdef() {
      if (this.vx_p_constdef == null) {
        return Core.e_constdef;
      } else {
        return this.vx_p_constdef;
      }
    }
    public List<Type_any> vx_dispose() {
      this.vx_iref = 0;
      this.vxmsgblock = null;
      this.vx_p_constdef = null;
      return Core.emptylistany;
    }
    public Core.Type_msgblock vx_msgblock() {
      if (this.vxmsgblock == null) {
        return Core.e_msgblock;
      } else {
        return this.vxmsgblock;
      }
    }
    public boolean vx_release() {
      boolean output = false;
      if (this.vx_iref < 0) {
      } else if (vx_iref == 0) {
        vx_iref = -1;
        output = true;
      } else {
        vx_iref -= 1;
      }
      return output;
    }
    public void vx_reserve() {this.vx_iref += 1;}
  }

  public static class KeyValue<T> {
    public String key = "";
    public T value = null;
  }

  public static Core.Type_constdef constdef_new(
    String pkgname,
    String name,
    Core.Type_any typ
  ) {
    Core.Class_constdef output = new Core.Class_constdef();
    output.vx_p_pkgname = Core.vx_new_string(pkgname);
    output.vx_p_name = Core.vx_new_string(name);
    output.vx_p_type = typ;
    return output;
  }

  public static Core.Type_funcdef funcdef_new(
    String pkgname,
    String name,
    int idx,
    boolean async,
    Core.Type_any typ
  ) {
    Core.Class_funcdef output = new Core.Class_funcdef();
    output.vx_p_pkgname = Core.vx_new_string(pkgname);
    output.vx_p_name = Core.vx_new_string(name);
    output.vx_p_idx = Core.vx_new_int(idx);
    output.vx_p_async = Core.vx_new_boolean(async);
    output.vx_p_type = typ;
    return output;
  }

  public static Core.Type_any[] arrayany_from_anylist(
    final Core.Type_anylist list
  ) {
    List<Core.Type_any> listany = list.vx_list();
    Core.Type_msgblock msgblock = list.vx_msgblock();
    if (msgblock == null) {
    } else if (msgblock == Core.e_msgblock) {
    } else {
     listany = new ArrayList<>(listany);
     listany.add(msgblock);
    }
    Core.Type_any[] output = listany.toArray(new Core.Type_any[0]);
    return output;
  }

  @SafeVarargs
  public static <T> List<T> arraylist_from_array(final T... items) {
    List<T> output = new ArrayList<T>(Arrays.asList(items));
    output = Core.immutablelist(output);
    return output;
  }

  public static <T extends Core.Type_any, U extends Core.Type_any> List<T> arraylist_from_arraylist(final T generic_any_1, final List<U> listval) {
    List<T> output = new ArrayList<>();
    for (Core.Type_any value : listval) {
      T t_val = Core.f_any_from_any(generic_any_1, value);
      output.add(t_val);
    }
    output = Core.immutablelist(output);
    return output;
  }

  public static <T, U> List<T> arraylist_from_arraylist_fn(final List<U> listval, final Function<U, T> fn_any_from_any) {
    List<T> output = new ArrayList<>();
    for (U value_u : listval) {
      T t_val = fn_any_from_any.apply(value_u);
      output.add(t_val);
    }
    output = Core.immutablelist(output);
    return output;
  }

  public static <T extends Core.Type_any, U extends Core.Type_any> List<T> arraylist_from_linkedhashmap(final T generic_any_1, final Map<String, U> mapval) {
    List<T> output = new ArrayList<T>();
    Set<String> keys = mapval.keySet();
    for (String key : keys) {
      U u_val = mapval.get(key);
      T t_val = Core.f_any_from_any(generic_any_1, u_val);
      output.add(t_val);
    }
    output = Core.immutablelist(output);
    return output;
  }

  public static <T, U> List<T> arraylist_from_linkedhashmap_fn(final Map<String, U> mapval, final BiFunction<String, U, T> fn_any_from_key_value) {
    List<T> output = new ArrayList<T>();
    Set<String> keys = mapval.keySet();
    for (String key : keys) {
      U u_val = mapval.get(key);
      T t_val = fn_any_from_key_value.apply(key, u_val);
      output.add(t_val);
    }
    return output;
  }

  @SafeVarargs
  public static <T> LinkedHashMap<String, T> hashmap_from_keyvalues(final KeyValue<T>... keyvalues) {
    LinkedHashMap<String, T> output = new LinkedHashMap<String, T>();
    for (KeyValue<T> keyvalue : keyvalues) {
      String key = keyvalue.key;
      T value = keyvalue.value;
      output.put(key, value);
    }
    return output;
  }

  public static <T> KeyValue<T> keyvalue_from_key_value(final String key, final T value) {
    KeyValue<T> output = new KeyValue<T>();
    output.key = key;
    output.value = value;
    return output;
  }

  public static <T extends Core.Type_any> LinkedHashMap<String, T> map_from_map(final LinkedHashMap<String, Core.Type_any> mapval) {
    LinkedHashMap<String, T> output = new LinkedHashMap<String, T>();
    Set<String> keys = mapval.keySet();
    for (String key : keys) {
      Core.Type_any value = mapval.get(key);
      try {
        @SuppressWarnings("unchecked")
        T castval = (T)value;
        output.put(key, castval);
      } catch (Exception ex) {
        Core.vx_log("map<-map", ex);
      }
    }
    return output;
  }

  // vx_new(generic_any_1, args...)
  public static <T extends Core.Type_any> T vx_new(final T generic_any_1, final Object... vals) {
    Core.Type_any val = generic_any_1.vx_new(vals);
    T output = Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  // vx_copy(generic_any_1, args...)
  public static <T extends Core.Type_any> T vx_copy(final T copyval, final Object... vals) {
    Core.Type_any val = copyval.vx_copy(vals);
    T output = Core.f_any_from_any(copyval, val);
    return output;
  }

  // vx_empty(generic_any_1)
  @SuppressWarnings("unchecked")
  public static <T extends Core.Type_any> T vx_empty(final T type) {
    T output = (T)(type.vx_empty());
    return output;
  }

  // vx_type(generic_any_1)
  @SuppressWarnings("unchecked")
  public static <T extends Core.Type_any> T vx_type(final T type) {
    T output = (T)(type.vx_type());
    return output;
  }

  public static <T> CompletableFuture<T> vx_async_new_from_value(final T val) {
    CompletableFuture<T> output = CompletableFuture.completedFuture(val);
    return output;
  }

  public static <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_async_from_async(
    final T generic_any_1,
    final CompletableFuture<U> future) {
    CompletableFuture<T> output = future.thenApply(val -> {
      return Core.f_any_from_any(generic_any_1, val);
    });
    return output;
  }

  public static <T, U> CompletableFuture<T> vx_async_from_async_fn(
    final CompletableFuture<U> future,
    final Function<? super U,
    ? extends T> fn) {
    CompletableFuture<T> output = future.thenApply(fn);
    return output;
  }

  public static <T> CompletableFuture<List<T>> vx_async_arraylist_from_arraylist_async(
    final List<CompletableFuture<T>> list_future) {
    CompletableFuture<Void> allFutures = CompletableFuture.allOf(
      list_future.toArray(new CompletableFuture[list_future.size()])
    );
    CompletableFuture<List<T>> output = allFutures.thenApply(v -> {
      List<T> list = list_future.stream()
        .map(future -> future.join())
        .collect(Collectors.toList());
      return Core.immutablelist(list);
    });
    return output;
  }

  // vx_any_first_from_list_fn(generic_any_1, list, fn_any)
  public static <T extends Core.Type_any> T vx_any_first_from_list_fn(
    final T generic_any_1,
    final Core.Type_list list,
    final Function<Core.Type_any, T> fn_any
  ) {
    T empty = Core.f_empty(generic_any_1);
    T output = empty;
    List<Core.Type_any> listany = list.vx_list();
    for (Core.Type_any any : listany) {
      T tany = Core.f_any_from_any(generic_any_1, any);
      T value = fn_any.apply(tany);
      if (value == null) {
      } else if (value == empty) {
      } else {
        output = value;
        break;
      }
    }
    return output;
  }

  // vx_any_from_func(generic_any_1, func, args...)
  public static <T extends Core.Type_any> T vx_any_from_func(final T generic_any_1, final Core.Type_replfunc func, final Core.Type_any... args) {
    Core.Type_anylist anylist = Core.vx_new_anylist(args);
    Core.Type_any val = func.vx_repl(anylist);
    T output = Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  // vx_any_from_list_start_reduce(any-1, list-2, any-1, any<-reduce)
  public static <T extends Core.Type_any, N extends Core.Type_list> T vx_any_from_list_start_reduce(T generic_any_1, N list, T valstart, Core.Func_any_from_reduce fn_reduce) {
    T output = valstart;
    List<Core.Type_any> listval = list.vx_list();
    for (Core.Type_any item : listval) {
      output = fn_reduce.vx_any_from_reduce(generic_any_1, output, item);
    }
    return output;
  }

  // vx_any_from_map(generic_any_1, map, string)
  public static <T extends Core.Type_any> T vx_any_from_map(T generic_any_1, Core.Type_map valuemap, Core.Type_string key) {
    T output = Core.f_empty(generic_any_1);
    String skey = key.vx_string();
    if (skey.startsWith(":")) {
      skey = skey.substring(1);
    }
    Core.Type_any val = valuemap.vx_map().getOrDefault(skey, output);
    output = Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  // vx_any_from_map_start_reduce(any-1, map-2, any-1, any<-any-key-value)
  public static <T extends Core.Type_any, N extends Core.Type_map> T vx_any_from_map_start_reduce(T generic_any_1, N map, T start, Core.Func_any_from_any_key_value fn_reduce) {
    T output = start;
    Map<String, Core.Type_any> mapval = map.vx_map();
    Set<String> keys = mapval.keySet();
    for (String skey : keys) {
      Core.Type_string key = Core.vx_new_string(skey);
      Core.Type_any value = mapval.get(skey);
      output = fn_reduce.vx_any_from_any_key_value(generic_any_1, output, key, value);
    }
    return output;
  }

  // vx_boolean_from_string_ends(string, string)
  public static boolean vx_boolean_from_string_ends(String text, String ends) {
    return text.endsWith(ends);
  }

  // vx_boolean_from_string_find(string, string)
  public static boolean vx_boolean_from_string_find(String text, String find) {
    return text.contains(find);
  }

  // vx_boolean_from_string_starts(string, string)
  public static boolean vx_boolean_from_string_starts(String text, String starts) {
    return text.startsWith(starts);
  }

  // vx_boolean_write_from_map_name_value(map, string, any)
  public static Core.Type_boolean vx_boolean_write_from_map_name_value(final Core.Type_map valuemap, final Core.Type_string name, final Core.Type_any value) {
    return valuemap.vx_set(name, value);
  }

  // vx_eqeq(any, any)
  public static boolean vx_eqeq(Core.Type_any val1, Core.Type_any val2) {
    boolean output = false;
    if (val1 == val2) {
      output = true;
    } else if (val1.vx_msgblock() != Core.e_msgblock) {
    } else if (val2.vx_msgblock() != Core.e_msgblock) {
    } else {
      Core.Type_any type1 = val1.vx_type();
      Core.Type_any type2 = val2.vx_type();
      if (type1 != type2) {
      } else if (type1 == Core.t_int) {
        Core.Type_int valint1 = (Core.Type_int)val1;
        Core.Type_int valint2 = (Core.Type_int)val2;
        if (valint1.vx_int() == valint2.vx_int()) {
          output = true;
        }
      } else if (type1 == Core.t_float) {
        Core.Type_float valfloat1 = (Core.Type_float)val1;
        Core.Type_float valfloat2 = (Core.Type_float)val2;
        if (valfloat1.vx_float() == valfloat2.vx_float()) {
          output = true;
        }
      } else if (type1 == Core.t_decimal) {
        Core.Type_decimal valdecimal1 = (Core.Type_decimal)val1;
        Core.Type_decimal valdecimal2 = (Core.Type_decimal)val2;
        if (valdecimal1.vx_string() == valdecimal2.vx_string()) {
          output = true;
        }
      } else if (type1 == Core.t_string) {
        Core.Type_string valstring1 = (Core.Type_string)val1;
        Core.Type_string valstring2 = (Core.Type_string)val2;
        if (valstring1.vx_string() == valstring2.vx_string()) {
          output = true;
        }
      }
    }
    return output;
  }

  // vx_float_from_number(number)
  public static float vx_float_from_number(Core.Type_number num) {
    float output = 0;
    Core.Type_any type = num.vx_type();
    if (type == Core.t_float) {
      Core.Type_float floatval = Core.f_any_from_any(Core.t_float, num);
      output = floatval.vx_float();
    } else if (type == Core.t_int) {
      Core.Type_int intval = Core.f_any_from_any(Core.t_int, num);
      output = intval.vx_int();
    } else if (type == Core.t_decimal) {
      Core.Type_decimal decval = Core.f_any_from_any(Core.t_decimal, num);
      output = decval.vx_float();
    }
    return output;
  }

  // vx_float_from_string(string)
  public static float vx_float_from_string(String text) {
    float output = 0;
    try {
      output = Float.parseFloat(text);
    } catch (Exception e) {
    }    
    return output;
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  public static void vx_global_package_set(String pkgname, Map<String, Core.Type_any> maptype, Map<String, Core.Type_any> mapconst, Map<String, Core.Type_func> mapfunc) {
    Core.Class_typemap typemap = new Core.Class_typemap();
		  typemap.vx_p_map = Core.immutablemap(maptype);
	   Core.Class_constmap constmap = new Core.Class_constmap();
		  constmap.vx_p_map = Core.immutablemap(mapconst);
		  Core.Class_funcmap funcmap = new Core.Class_funcmap();
		  funcmap.vx_p_map = Core.immutablemap(mapfunc);
    Core.Class_project global = (Core.Class_project)Core.c_global;
    Core.Class_packagemap packagemap = (Core.Class_packagemap)global.vx_p_packagemap;
    if (packagemap == null) {
      packagemap = new Core.Class_packagemap();
      global.vx_p_packagemap = packagemap;
    }
    Map<String, Core.Type_package> mappackage = new LinkedHashMap<>(packagemap.vx_p_map);
		  Core.Class_package pkg = new Core.Class_package();
		  pkg.vx_p_constmap = constmap;
		  pkg.vx_p_typemap = typemap;
		  pkg.vx_p_funcmap = funcmap;
    mappackage.put(pkgname, pkg);
    packagemap.vx_p_map = Core.immutablemap(mappackage);
  }

  public static <T extends Core.Type_any> T vx_if_2(final T generic_any_1, final Core.Type_thenelselist thenelselist) {
    T output = Core.f_empty(generic_any_1);
    Core.Func_any_from_func fn_any = Core.vx_any_first_from_list_fn(Core.t_any_from_func, thenelselist, (any) -> {
      Core.Func_any_from_func fnany = null;
      if (any instanceof Core.Type_thenelse) {
        Core.Type_thenelse thenelse = (Core.Type_thenelse)any;
        Core.Type_string code = thenelse.code();
        switch (code.vx_string()) {
        case ":then":
          Core.Func_boolean_from_func fn_cond = thenelse.fn_cond();
          Core.Type_boolean cond = fn_cond.vx_boolean_from_func();
          if (cond.vx_boolean() == true) {
            fnany = thenelse.fn_any();
          }
          break;
        case ":else":
          fnany = thenelse.fn_any();
          break;
        }
      }
      return fnany;
    });
    if (fn_any != null) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }
    return output;
  }

  // vx_int_from_string(string)
  public static int vx_int_from_string(String text) {
    int output = 0;
    try {
      output = Integer.parseInt(text);
    } catch (Exception e) {
    }    
    return output;
  }

  // vx_is_float(string)
  public static boolean vx_is_float(String text) {
    boolean output = false;
    try {
      Float.parseFloat(text);
      output = true;
    } catch (Exception e) {
    }    
    return output;
  }

  // vx_is_float(any)
  public static boolean vx_is_float(Core.Type_any value) {
    boolean output = false;
    if (value instanceof Core.Type_number) {
      output = true;
    } else if (value instanceof Core.Type_string) {
      Core.Type_string valuestring = (Core.Type_string)value;
      output = Core.vx_is_float(valuestring.vx_string());
    }
    return output;
  }

  // vx_is_int(string)
  public static boolean vx_is_int(String text) {
    boolean output = false;
    switch (text) {
    case "notanumber":
    case "infinity":
    case "neginfinity":
      output = true;
      break;
    default:
      try {
        Integer.parseInt(text);
        output = true;
      } catch (Exception e) {
      }
      break;
    }
    return output;
  }

  // vx_is_int(any)
  public static boolean vx_is_int(Core.Type_any value) {
    boolean result = false;
    if (value == Core.c_infinity) {
      result = true;
    } else if (value == Core.c_neginfinity) {
      result = true;
    } else if (value == Core.c_notanumber) {
      result = true;
    } else if (value instanceof Core.Type_int) {
      result = true;
    } else if (value instanceof Core.Type_float) {
      Core.Type_float valfloat = (Core.Type_float)value;
      float floatval = valfloat.vx_float();
      if ((int)floatval == floatval) {
        result = true;
      }
    } else if (value instanceof Core.Type_decimal) {
      Core.Type_decimal valdec = (Core.Type_decimal)value;
      String strval = valdec.vx_string();
      try {
        if (Integer.parseInt(strval) == Float.parseFloat(strval)) {
          result = true;
        }
      } catch (Exception ex) {
      }
    } else if (value instanceof Core.Type_string) {
      Core.Type_string valstr = (Core.Type_string)value;
      String strval = valstr.vx_string();
      result = vx_is_int(strval);
    }
    return result;
  }

public static <X extends Core.Type_list, Y extends Core.Type_list> CompletableFuture<X> vx_list_from_list_async(
    final X generic_list_1,
    final Y values,
    final Core.Func_any_from_any_async fn_any_from_any_async) {
    List<Core.Type_any> list_value = values.vx_list();
    List<CompletableFuture<Core.Type_any>> list_async_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any_async.vx_any_from_any_async(generic_list_1, val);
    });
    CompletableFuture<List<Core.Type_any>> async_list_result = Core.vx_async_arraylist_from_arraylist_async(list_async_result);
    CompletableFuture<X> output = Core.vx_async_from_async_fn(async_list_result, (list_result) -> {
      X work = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
      return work;
    });
    return output;
  }

  // vx_list_from_list_intany(generic_list_1, list-2, any<-int-any)
  public static <T extends Core.Type_list, U extends Core.Type_list> T vx_list_from_list_intany(T generic_list_1, U valuelist, Core.Func_any_from_int_any fn_any_from_int_any) {
    T output = Core.f_empty(generic_list_1);
    List<Core.Type_any> listany = valuelist.vx_list();
    if (listany.size() > 0) {
      List<Core.Type_any> listout = new ArrayList<Core.Type_any>();
      for (int i = 0; i < listany.size(); i++) {
        Core.Type_int vali = Core.vx_new_int(i+1);
        Core.Type_any value = listany.get(i);
        Core.Type_any outval = fn_any_from_int_any.vx_any_from_int_any(Core.t_any, vali, value);
        listout.add(outval);
      }
      output = Core.vx_new_list(generic_list_1, listout);
    }
    return output;
  }

  // vx_log(object...)
  public static void vx_log(Object... values) {
    for (Object value : values) {
      String text = "";
      if (value == null) {
        text = "null";
      } else if (value instanceof Core.Type_string) {
        Core.Type_string valstring = (Core.Type_string)value;
        text = valstring.vx_string();
      } else if (value instanceof Core.Type_any) {
        Core.Type_any valany = (Core.Type_any)value;
        Core.Type_string valstring = Core.f_string_from_any(valany);
        text = valstring.vx_string();
      } else {
        text = value.toString();
      }
      System.out.println(text);
    }
  }

  // vx_map_from_list_fn(generic_map, list, fn_any_from_key_value)
  public static <T> Map<String, T> vx_map_from_list_fn(final List<T> listval, final Function<T, Core.Type_string> fn_any_from_any) {
    Map<String, T> output = new LinkedHashMap<>();
    for (T val : listval) {
      Core.Type_string valkey = fn_any_from_any.apply(val);
      String key = valkey.vx_string();
      output.put(key, val);
    }
    return output;
  }

  // vx_map_from_map_fn(generic_map, map, fn_any_from_key_value)
  public static <T extends Core.Type_map> T vx_map_from_map_fn(T generic_map_1, Core.Type_map valuemap, Core.Func_any_from_key_value fn_any_from_key_value) {
    T output = Core.f_empty(generic_map_1);
    Map<String, Core.Type_any> mapvalue = valuemap.vx_map();
    if (mapvalue.size() > 0) {
      Set<String> keys = mapvalue.keySet();
      Map<String, Core.Type_any> mapnew = new LinkedHashMap<>();
      for (String key : keys) {
        Core.Type_any value = mapvalue.get(key);
        Core.Type_string stringkey = Core.vx_new_string(key);
        Core.Type_any chgvalue = fn_any_from_key_value.vx_any_from_key_value(Core.t_any, stringkey, value);
        mapnew.put(key, chgvalue);
      }
      Core.Type_map anymap = generic_map_1.vx_new_from_map(mapnew);
      output = Core.f_any_from_any(generic_map_1, anymap);
    }
    return output;
  }

  // vx_msg_from_error
  public static Type_msg vx_msg_from_error(
    final String text) {
    Class_msg output = new Class_msg();
    output.vx_p_text = Core.vx_new_string(text);
    output.vx_p_severity = Core.c_msg_severe;
    return output;
  }

  // vx_msg_from_error
  public static Type_msg vx_msg_from_error(
    final String path,
    final String code,
    final Core.Type_any detail) {
    Class_msg output = new Class_msg();
    output.vx_p_path = Core.vx_new_string(path);
    output.vx_p_code = Core.vx_new_string(code);
    output.vx_p_detail = detail;
    output.vx_p_severity = Core.c_msg_severe;
    return output;
  }

  // vx_msg_from_exception
  public static Type_msg vx_msg_from_exception(
    final String path,
    final Exception err) {
    Class_msg output = new Class_msg();
    output.vx_p_path = Core.vx_new_string(path);
    output.vx_p_code = Core.vx_new_string("exception");
    output.vx_p_severity = Core.c_msg_severe;
    output.err = err;
    Core.vx_log(output);
    return output;
  }

  // vx_msgblock_from_copy_arrayval(msgblock, any...)
  public static Core.Type_msgblock vx_msgblock_from_copy_arrayval(
    final Core.Type_any copy,
    final Object... vals) {
    Core.Type_msgblock output = Core.e_msgblock;
    Core.Type_msgblock copymsgblock = copy.vx_msgblock();
    if (copymsgblock != Core.e_msgblock) {
      output = copymsgblock;
    }
    return output;
  }

  // vx_msgblock_from_copy_listval(msgblock, List<any>)
  public static Core.Type_msgblock vx_msgblock_from_copy_listval(final Core.Type_msgblock msgblock, Core.Type_any... vals) {
    Core.Type_msgblock output = Core.e_msgblock;
    List<Core.Type_msgblock> listmsgblock = new ArrayList<>();
    if (msgblock == null) {
    } else if (msgblock == Core.e_msgblock) {
    } else {
      Core.Type_msgblock origmsgblock = msgblock.vx_msgblock();
      if (origmsgblock != Core.e_msgblock) {
        List<Core.Type_msgblock> origlistmsgblock = origmsgblock.msgblocks().vx_listmsgblock();
        listmsgblock.addAll(origlistmsgblock);
      }
    }
    for (Core.Type_any subval : vals) {
      Core.Type_msgblock submsgblock = subval.vx_msgblock();
      if (submsgblock != Core.e_msgblock) {
        listmsgblock.add(submsgblock);
      }
    }
    if (listmsgblock.size() > 0) {
      Core.Class_msgblocklist msgblocks;
      msgblocks = new Core.Class_msgblocklist();
      msgblocks.vx_p_list = listmsgblock;
      Core.Class_msgblock outputclass = new Core.Class_msgblock();
      outputclass.vx_p_msgblocks = msgblocks;
      output = outputclass;
    } else if (msgblock == null) {
    } else if (msgblock == Core.e_msgblock) {
    } else {
      output = msgblock;
    }
    return output;
  }

  public static Type_anylist vx_new_anylist(
    Core.Type_any... anys) {
    List<Core.Type_any> listany = new ArrayList<>(Arrays.asList(anys));
    return vx_new_anylist(listany);
  }

  public static Type_anylist vx_new_anylist(
    List<Type_any> listany) {
    Class_anylist output = new Class_anylist();
    output.vx_p_list = immutablelist(listany);
    return output;
  }

  public static Type_boolean vx_new_boolean(
    final boolean isval) {
    Type_boolean output = Core.c_false;
    if (isval) {
      output = Core.c_true;
    }
    return output;
  }

  public static Core.Type_decimal vx_new_decimal(
    final String text) {
    Core.Type_decimal output;
    if ((text.equals("0") || text.equals("0.0")) && Core.e_decimal != null) {
      output = Core.e_decimal;
    } else {
      Core.Class_decimal work = new Core.Class_decimal();
      work.vxdecimal = text;
      output = work;
    }
    return output;
  }

  public static Type_float vx_new_float(
    final float fval) {
    Class_float output = new Core.Class_float();
    output.vxfloat = fval;
    return output;
  }

  public static Type_int vx_new_int(
    final int ival) {
    Type_int output;
    if ((ival == 0) && Core.e_int != null) {
      output = Core.e_int;
    } else {
      Class_int work = new Core.Class_int();
      work.vxint = ival;
      output = work;

    }
    return output;
  }

  // vx_new_list(T, List<any>)
  public static <T extends Core.Type_list> T vx_new_list(
    T generic_list_1,
    List<Core.Type_any> listval) {
    Core.Type_any anylist = generic_list_1.vx_new(listval);
    T output = Core.f_any_from_any(generic_list_1, anylist);
    return output;
  }

  // vx_new_map(T, Map<string, any>)
  public static <T extends Core.Type_map> T vx_new_map(
    T generic_map_1,
    Map<String, Core.Type_any> mapval) {
    Core.Type_any anymap = generic_map_1.vx_new(mapval);
    T output = Core.f_any_from_any(generic_map_1, anymap);
    return output;
  }

  public static Type_string vx_new_string(
    final String text) {
    Type_string output;
    if (text.equals("") && Core.e_string != null) {
      output = Core.e_string;
    } else {
      Class_string work = new Core.Class_string();
      work.vxstring = text;
      output = work;
    }
    return output;
  }

  public static String vx_string_from_any(
    Core.Type_any value) {
    return vx_string_from_any_indent(value, 0, false);
  }

  public static String vx_string_from_any_indent(
    Core.Type_any value,
    int indent,
    boolean linefeed) {
    String indenttext = " ".repeat(indent);
    String output = "";
    if (indent > 50) {
      output = "Error: Max Depth Exceeded";
    } else if (value == null) {
      output = "null";
    } else if (value == value.vx_type()) {
      if (value instanceof Core.Type_func) {
        Core.Type_func valuefunc = (Core.Type_func)value;
        Core.Type_funcdef funcdef = valuefunc.vx_funcdef();
        output = funcdef.pkgname().vx_string() + "/" + funcdef.name().vx_string();
      } else {
        Core.Type_typedef typedef = value.vx_typedef();
        output = typedef.pkgname().vx_string() + "/" + typedef.name().vx_string();
      }
    } else if (value instanceof Core.Type_boolean) {
      Core.Type_boolean valbool = Core.f_any_from_any(Core.t_boolean, value);
      if (valbool.vx_boolean() == true) {
        output = "true";
      } else {
        output = "false";
      }
    } else if (value instanceof Core.Type_decimal) {
      Core.Type_decimal valdec = Core.f_any_from_any(Core.t_decimal, value);
      output = valdec.vx_string();
    } else if (value instanceof Core.Type_float) {
      Core.Type_float valfloat = Core.f_any_from_any(Core.t_float, value);
      output = Float.toString(valfloat.vx_float());
      if (output.endsWith(".0")) {
        output = output.substring(0, output.length() - 2);
      }
    } else if (value instanceof Core.Type_int) {
      if (value == Core.c_notanumber) {
        output = "notanumber";
      } else if (value == Core.c_infinity) {
        output = "infinity";
      } else if (value == Core.c_neginfinity) {
        output = "neginfinity";
      } else {
        Core.Type_int valint = Core.f_any_from_any(Core.t_int, value);
        output = Integer.toString(valint.vx_int());
      }
    } else if (value instanceof Core.Type_string) {
      Core.Type_string valstring = Core.f_any_from_any(Core.t_string, value);
      String sval = valstring.vx_string();
      if (sval.indexOf("\"") < 0) {
        sval = "\"" + sval + "\"";
      } else {
        sval = "`" + sval + "`";
      }
      if (valstring.vx_msgblock() != Core.e_msgblock) {
        String msgtext = Core.vx_string_from_any_indent(valstring.vx_msgblock(), indent, linefeed);
        output  = "\n" + indenttext + "(string";
        output += "\n" + indenttext + " " + sval;
        output += "\n" + indenttext + " " + msgtext + ")";
      } else {
        output = sval;
      }
    } else if (value.vx_constdef() != Core.e_constdef) {
      Core.Type_constdef constdef = value.vx_constdef();
      String constpkg = constdef.pkgname().vx_string();
      String constname = constdef.name().vx_string();
      if (constpkg.equals("vx/core")) {
        output = constname;
      } else {
        output = constpkg + "/" + constname;
      }
    } else if (value instanceof Core.Type_list) {
      Core.Type_list vallist = Core.f_any_from_any(Core.t_list, value);
      Core.Type_typedef typedef = vallist.vx_typedef();
      Core.Type_string typedefname = typedef.name();
      String stypedefname = typedefname.vx_string();
      int indentint = indent + 1;
      List<Core.Type_any> listval = vallist.vx_list();
      for (Core.Type_any valsub : listval) {
        String valtext = Core.vx_string_from_any_indent(valsub, indentint, linefeed);
        output += "\n " + indenttext + valtext;
      }
      if (vallist.vx_msgblock() != Core.e_msgblock) {
        String msgtext = Core.vx_string_from_any_indent(vallist.vx_msgblock(), indent, linefeed);
        output += "\n" + indenttext + msgtext;
      }
      output = "(" + stypedefname + output + ")";
    } else if (value instanceof Core.Type_map) {
      Core.Type_map valmap = Core.f_any_from_any(Core.t_map, value);
      Core.Type_typedef typedef = valmap.vx_typedef();
      Core.Type_string typedefname = typedef.name();
      String stypedefname = typedefname.vx_string();
      int indentint = indent + 2;
      Map<String, Core.Type_any> mapval = valmap.vx_map();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any valsub = mapval.get(key);
        if (key.indexOf(" ") >= 0) {
          key = "\"" + key + "\"";
        } else if (!key.startsWith(":")) {
          key = ":" + key;
        }
        String strval = Core.vx_string_from_any_indent(valsub, indentint, linefeed);
        if (strval.contains("\n")) {
          strval = "\n  " + indenttext + strval;
        } else {
          strval = " " + strval;
        }
        output += "\n" + indenttext + " " + key + strval;
      }
      if (valmap.vx_msgblock() != Core.e_msgblock) {
        String msgtext = Core.vx_string_from_any_indent(valmap.vx_msgblock(), indent+1, linefeed);
        output += "\n " + indenttext + msgtext;
      }
      output = "(" + stypedefname + output + ")";
    } else if (value instanceof Core.Type_struct) {
      Core.Type_struct valstruct = Core.f_any_from_any(Core.t_struct, value);
      Core.Type_typedef typedef = valstruct.vx_typedef();
      Core.Type_string typedefname = typedef.name();
      String stypedefname = typedefname.vx_string();
      int indentint2 = indent;
      indentint2 += 2;
      Map<String, Core.Type_any> mapval2 = valstruct.vx_map();
      Set<String> keys2 = mapval2.keySet();
      for (String key : keys2) {
        Core.Type_any valsub2 = mapval2.get(key);
        if (!Core.f_is_empty_1(valsub2).vx_boolean()) {
          if (!key.startsWith(":")) {
            key = ":" + key;
          }
          String strval2 = Core.vx_string_from_any_indent(valsub2, indentint2, linefeed);
          if (strval2.contains("\n")) {
            strval2 = "\n  " + indenttext + strval2;
          } else {
            strval2 = " " + strval2;
          }
          output += "\n" + indenttext + " " + key + strval2;
        }
      }
      if (stypedefname == "msg") {
      } else if (stypedefname == "msgblock") {
      } else if (valstruct.vx_msgblock() != Core.e_msgblock) {
        String msgtext2 = Core.vx_string_from_any_indent(valstruct.vx_msgblock(), indent+1, linefeed);
        output += "\n " + indenttext + msgtext2;
      }
      output = "(" + stypedefname + output + ")";
    } else if (value instanceof Core.Type_func) {
      Core.Type_func valfunc = Core.f_any_from_any(Core.t_func, value);
      Core.Type_funcdef funcdef = valfunc.vx_funcdef();
      Core.Type_string funcdefname = Core.f_funcname_from_funcdef(funcdef);
      output = funcdefname.vx_string();
      if (valfunc.vx_msgblock() != Core.e_msgblock) {
        String msgtext = Core.vx_string_from_any_indent(valfunc.vx_msgblock(), indent, linefeed);
        output += "\n" + indenttext + msgtext;
      }
      output = "(" + output + ")";
    }
    return output;
  }

  public static Core.Type_string vx_string_from_any_indent(Core.Type_any value, Core.Type_int indent, Core.Type_boolean linefeed) {
    String soutput = Core.vx_string_from_any_indent(value, indent.vx_int(), linefeed.vx_boolean());
    Core.Type_string output = Core.vx_new_string(soutput);
    return output;
  }

  // vx_string_from_string_find_replace(string, string, string)
  public static String vx_string_from_string_find_replace(
    String text,
    String find,
    String replace
  ) {
    String output = text.replaceAll(find, replace);
    return output;
  }

  // vx_string_from_string_find_replace(string, string, string)
  public static Core.Type_string vx_string_from_string_find_replace(
    Core.Type_string text,
    Core.Type_string find,
    Core.Type_string replace
  ) {
    String stext = Core.vx_string_from_string_find_replace(text.vx_string(), find.vx_string(), replace.vx_string());
    Core.Type_string output = Core.vx_new_string(stext);
    return output;
  }

  public static String vx_string_from_string_start_end(
    String text,
    int start,
    int end
  ) {
    String output = "";
    int maxlen = text.length();
    if (end < 0) {
     end += maxlen;
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end > maxlen) {
        end = maxlen;
      }
      output = text.substring(start - 1, end);
    }
    return output;
  }

  public static Core.Type_typedef typedef_new(
    String pkgname,
    String name,
    String extend,
    Core.Type_typelist traits,
    Core.Type_typelist allowtypes,
    Core.Type_typelist disallowtypes,
    Core.Type_funclist allowfuncs,
    Core.Type_funclist disallowfuncs,
    Core.Type_anylist allowvalues,
    Core.Type_anylist disallowvalues,
    Core.Type_argmap properties
  ) {
    Core.Class_typedef output = new Core.Class_typedef();
    output.vx_p_pkgname = Core.vx_new_string(pkgname);
    output.vx_p_name = Core.vx_new_string(name);
    output.vx_p_extend = Core.vx_new_string(extend);
    output.vx_p_traits = traits;
    output.vx_p_allowtypes = allowtypes;
    output.vx_p_disallowtypes = disallowtypes;
    output.vx_p_allowfuncs = disallowfuncs;
    output.vx_p_disallowfuncs = disallowfuncs;
    output.vx_p_allowvalues = disallowvalues;
    output.vx_p_disallowvalues = disallowvalues;
    output.vx_p_properties = properties;
    return output;
  }

  public static Core.Type_anylist vx_anylist_from_arraystring(
    String... arraystring
  ) {
    List<Object> listany = new ArrayList<>();
    for (String svalue : arraystring) {
      Core.Type_string value = Core.vx_new_string(svalue);
      listany.add(value);
    }
    Object[] arrayany = listany.toArray();
    Core.Type_anylist output = Core.vx_new(Core.t_anylist, arrayany);
    return output;
  }

  // Warning!: Blocking
  public static <T extends Core.Type_any> T vx_sync_from_async(
    final T generic_any_1,
    final CompletableFuture<T> future
  ) {
    T output = Core.f_empty(generic_any_1);
    try {
      output = future.get();
    } catch (Exception e) {
      Core.Type_msg msg = Core.vx_msg_from_exception("sync<-async", e);
      Core.Type_any val = generic_any_1.vx_new(msg);
      output = Core.f_any_from_any(generic_any_1, val);
    }
    return output;
  }

  /**
   * type: any
   * Any Value for Variant Type
   * (type any)
   */
  public interface Type_any {
    public Core.Type_any vx_new(final Object... vals);
    public Core.Type_any vx_copy(final Object... vals);
    public Core.Type_any vx_empty();
    public Core.Type_any vx_type();
    public Core.Type_typedef vx_typedef();
    public Core.Type_constdef vx_constdef();
    public List<Core.Type_any> vx_dispose();
    public Core.Type_msgblock vx_msgblock();
    public boolean vx_release();
    public void vx_reserve();
  }

  public static class Class_any extends Core.Class_base implements Type_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_any output = Core.vx_copy(Core.e_any, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_any output = this;
      boolean ischanged = false;
      Core.Class_any value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_any work = new Core.Class_any();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "any", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_any e_any = new Core.Class_any();
  public static final Core.Type_any t_any = new Core.Class_any();

  /**
   * type: any-async<-func
   * A sync or async function that returns one value.
   * (type any-async<-func)
   */
  public interface Type_any_async_from_func extends Core.Type_any {
  }

  public static class Class_any_async_from_func extends Core.Class_base implements Type_any_async_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_any_async_from_func output = Core.vx_copy(Core.e_any_async_from_func, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_any_async_from_func output = this;
      boolean ischanged = false;
      Core.Class_any_async_from_func value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_any_async_from_func work = new Core.Class_any_async_from_func();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_async_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_async_from_func;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "any-async<-func", // name
        ":func", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_any_async_from_func e_any_async_from_func = new Core.Class_any_async_from_func();
  public static final Core.Type_any_async_from_func t_any_async_from_func = new Core.Class_any_async_from_func();

  /**
   * type: any<-anylist
   * List of any<-any
   * (type any<-anylist)
   */
  public interface Type_any_from_anylist extends Core.Type_list {
    public List<Core.Func_any_from_any> vx_listany_from_any();
    public Core.Func_any_from_any vx_any_from_any(final Core.Type_int index);
  }

  public static class Class_any_from_anylist extends Core.Class_base implements Type_any_from_anylist {

    public List<Core.Func_any_from_any> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Func_any_from_any>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_any_from_any(final Core.Type_int index) {
      Core.Func_any_from_any output = Core.e_any_from_any;
      Core.Class_any_from_anylist list = this;
      int iindex = index.vx_int();
      List<Core.Func_any_from_any> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Func_any_from_any> vx_listany_from_any() {
      List<Core.Func_any_from_any> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Func_any_from_any output = this.vx_any_from_any(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_any_from_anylist output = Core.vx_copy(Core.e_any_from_anylist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_any_from_anylist output = this;
      boolean ischanged = false;
      Core.Class_any_from_anylist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Func_any_from_any> listval = new ArrayList<Core.Func_any_from_any>(value.vx_listany_from_any());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_any_from_anylist) {
          Core.Type_any_from_anylist multi = (Core.Type_any_from_anylist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listany_from_any());
        } else if (valsub instanceof Core.Func_any_from_any) {
          Core.Func_any_from_any allowsub = (Core.Func_any_from_any)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Func_any_from_any) {
              Core.Func_any_from_any valitem = (Core.Func_any_from_any)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_any_from_anylist work = new Core.Class_any_from_anylist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_anylist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_anylist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "any<-anylist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_any_from_anylist e_any_from_anylist = new Core.Class_any_from_anylist();
  public static final Core.Type_any_from_anylist t_any_from_anylist = new Core.Class_any_from_anylist();

  /**
   * type: anylist
   * A list of any
   * (type anylist)
   */
  public interface Type_anylist extends Core.Type_list {
  }

  public static class Class_anylist extends Core.Class_base implements Type_anylist {

    public List<Core.Type_any> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_any>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_any output = Core.e_any;
      Core.Class_anylist list = this;
      int iindex = index.vx_int();
      List<Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_anylist output = Core.vx_copy(Core.e_anylist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_anylist output = this;
      boolean ischanged = false;
      Core.Class_anylist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_any> listval = new ArrayList<Core.Type_any>(value.vx_list());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_anylist) {
          Core.Type_anylist multi = (Core.Type_anylist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_list());
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any allowsub = (Core.Type_any)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_any) {
              Core.Type_any valitem = (Core.Type_any)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/anylist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/anylist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_anylist work = new Core.Class_anylist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_anylist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_anylist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "anylist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_anylist e_anylist = new Core.Class_anylist();
  public static final Core.Type_anylist t_anylist = new Core.Class_anylist();

  /**
   * type: anymap
   * A map of any
   * (type anymap)
   */
  public interface Type_anymap extends Core.Type_map {
  }

  public static class Class_anymap extends Core.Class_base implements Type_anymap {

    public Map<String, Core.Type_any> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_any>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_any) {
        Core.Type_any castval = (Core.Type_any)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
        if (castval == Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      Core.Class_anymap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_any);
      return output;
    }

    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_anymap output = new Core.Class_anymap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_any) {
          Core.Type_any castval = (Core.Type_any)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/anymap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_anymap output = Core.vx_copy(Core.e_anymap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_anymap output = this;
      boolean ischanged = false;
      Core.Class_anymap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_any> mapval = new LinkedHashMap<String, Core.Type_any>(value.vx_map());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/anymap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_any valany = Core.e_any;
          if (false) {
          } else if (valsub instanceof Core.Type_any) {
            Core.Type_any valallowed = (Core.Type_any)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_any) {
            valany = (Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/anymap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_anymap work = new Core.Class_anymap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_anymap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_anymap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "anymap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_anymap e_anymap = new Core.Class_anymap();
  public static final Core.Type_anymap t_anymap = new Core.Class_anymap();

  /**
   * type: anytype
   * Any Type that allows any Type as a Value
   * (type anytype)
   */
  public interface Type_anytype extends Core.Type_any {
  }

  public static class Class_anytype extends Core.Class_base implements Type_anytype {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_anytype output = Core.vx_copy(Core.e_anytype, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_anytype output = this;
      boolean ischanged = false;
      Core.Class_anytype value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_anytype work = new Core.Class_anytype();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_anytype;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_anytype;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "anytype", // name
        ":type", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_anytype e_anytype = new Core.Class_anytype();
  public static final Core.Type_anytype t_anytype = new Core.Class_anytype();

  /**
   * type: arg
   * A function argument
   * (type arg)
   */
  public interface Type_arg extends Core.Type_struct {
    public Core.Type_string name();
    public Core.Type_any argtype();
    public Core.Func_any_from_func fn_any();
    public Core.Type_string doc();
  }

  public static class Class_arg extends Core.Class_base implements Type_arg {

    public Core.Type_string vx_p_name = null;

    @Override
    public Core.Type_string name() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_any vx_p_argtype = null;

    @Override
    public Core.Type_any argtype() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_argtype;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Func_any_from_func vx_p_fn_any = null;

    @Override
    public Core.Func_any_from_func fn_any() {
      Core.Func_any_from_func output = Core.e_any_from_func;
      Core.Func_any_from_func testnull = vx_p_fn_any;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_doc = null;

    @Override
    public Core.Type_string doc() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_doc;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":name"))) {
        output = this.name();
      } else if ((skey.equals(":argtype"))) {
        output = this.argtype();
      } else if ((skey.equals(":fn-any"))) {
        output = this.fn_any();
      } else if ((skey.equals(":doc"))) {
        output = this.doc();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":name", this.name());
      map.put(":argtype", this.argtype());
      map.put(":fn-any", this.fn_any());
      map.put(":doc", this.doc());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_arg output = Core.vx_copy(Core.e_arg, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_arg output = this;
      boolean ischanged = false;
      Core.Class_arg value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_name = value.name();
      Core.Type_any vx_p_argtype = value.argtype();
      Core.Func_any_from_func vx_p_fn_any = value.fn_any();
      Core.Type_string vx_p_doc = value.doc();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":name");
      validkeys.add(":argtype");
      validkeys.add(":fn-any");
      validkeys.add(":doc");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/arg", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":name"))) {
            if (valsub == vx_p_name) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_name = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":argtype"))) {
            if (valsub == vx_p_argtype) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valargtype = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_argtype = valargtype;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("argtype"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":fn-any"))) {
            if (valsub == vx_p_fn_any) {
            } else if (valsub instanceof Core.Func_any_from_func) {
              Core.Func_any_from_func valfn_any = (Core.Func_any_from_func)valsub;
              ischanged = true;
              vx_p_fn_any = valfn_any;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("fn-any"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":doc"))) {
            if (valsub == vx_p_doc) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valdoc = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_doc = valdoc;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_doc = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("doc"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_arg work = new Core.Class_arg();
        work.vx_p_name = vx_p_name;
        work.vx_p_argtype = vx_p_argtype;
        work.vx_p_fn_any = vx_p_fn_any;
        work.vx_p_doc = vx_p_doc;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_arg;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_arg;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "arg", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_arg e_arg = new Core.Class_arg();
  public static final Core.Type_arg t_arg = new Core.Class_arg();

  /**
   * type: arglist
   * A list of arg
   * (type arglist)
   */
  public interface Type_arglist extends Core.Type_list {
    public List<Core.Type_arg> vx_listarg();
    public Core.Type_arg vx_arg(final Core.Type_int index);
  }

  public static class Class_arglist extends Core.Class_base implements Type_arglist {

    public List<Core.Type_arg> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_arg>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_arg vx_arg(final Core.Type_int index) {
      Core.Type_arg output = Core.e_arg;
      Core.Class_arglist list = this;
      int iindex = index.vx_int();
      List<Core.Type_arg> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_arg> vx_listarg() {
      List<Core.Type_arg> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_arg output = this.vx_arg(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_arglist output = Core.vx_copy(Core.e_arglist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_arglist output = this;
      boolean ischanged = false;
      Core.Class_arglist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_arg> listval = new ArrayList<Core.Type_arg>(value.vx_listarg());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_arglist) {
          Core.Type_arglist multi = (Core.Type_arglist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listarg());
        } else if (valsub instanceof Core.Type_arg) {
          Core.Type_arg allowsub = (Core.Type_arg)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_arg) {
          ischanged = true;
          listval.add((Core.Type_arg)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_arg) {
              Core.Type_arg valitem = (Core.Type_arg)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/arglist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/arglist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_arglist work = new Core.Class_arglist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_arglist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_arglist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "arglist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_arg), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_arglist e_arglist = new Core.Class_arglist();
  public static final Core.Type_arglist t_arglist = new Core.Class_arglist();

  /**
   * type: argmap
   * A map of arg
   * (type argmap)
   */
  public interface Type_argmap extends Core.Type_map {
    public Map<String, Core.Type_arg> vx_maparg();
    public Core.Type_arg vx_arg(final Core.Type_string key);
  }

  public static class Class_argmap extends Core.Class_base implements Type_argmap {

    public Map<String, Core.Type_arg> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_arg>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_arg) {
        Core.Type_arg castval = (Core.Type_arg)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_arg> map = new LinkedHashMap<String, Core.Type_arg>(this.vx_p_map);
        if (castval == Core.e_arg) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_arg vx_arg(final Core.Type_string key) {
      Core.Type_arg output = Core.e_arg;
      Core.Class_argmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_arg> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_arg);
      return output;
    }

    @Override
    public Map<String, Core.Type_arg> vx_maparg() {
      Map<String, Core.Type_arg> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_arg(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_argmap output = new Core.Class_argmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_arg> map = new LinkedHashMap<String, Core.Type_arg>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_arg) {
          Core.Type_arg castval = (Core.Type_arg)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/argmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_argmap output = Core.vx_copy(Core.e_argmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_argmap output = this;
      boolean ischanged = false;
      Core.Class_argmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_arg> mapval = new LinkedHashMap<String, Core.Type_arg>(value.vx_maparg());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/argmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_arg valany = Core.e_arg;
          if (false) {
          } else if (valsub instanceof Core.Type_arg) {
            Core.Type_arg valallowed = (Core.Type_arg)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_arg) {
            valany = (Core.Type_arg)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/argmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_argmap work = new Core.Class_argmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_argmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_argmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "argmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_arg), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_argmap e_argmap = new Core.Class_argmap();
  public static final Core.Type_argmap t_argmap = new Core.Class_argmap();

  /**
   * type: boolean
   * Standard Boolean Type
   * (type boolean)
   */
  public interface Type_boolean extends Core.Type_any {
    public boolean vx_boolean();
  }

  public static class Class_boolean extends Core.Class_base implements Type_boolean {

    protected boolean vxboolean = false;
    
    @Override
    public boolean vx_boolean() {
      return vxboolean;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_boolean output = Core.vx_copy(Core.e_boolean, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_boolean output = this;
      boolean ischanged = false;
      Core.Class_boolean value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      boolean booleanval = value.vx_boolean();
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_boolean) {
          Core.Type_boolean valboolean = (Core.Type_boolean)valsub;
          booleanval = booleanval || valboolean.vx_boolean();
        } else if (valsub instanceof Boolean) {
          Boolean issubval = (Boolean)valsub;
          booleanval = booleanval || issubval;
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_boolean work = new Core.Class_boolean();
        work.vxboolean = booleanval;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      } else if (booleanval) {
        output = Core.c_true;
      } else {
        output = Core.c_false;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_boolean;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_boolean;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "boolean", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_boolean t_boolean = new Core.Class_boolean();

  /**
   * type: booleanlist
   * (type booleanlist)
   */
  public interface Type_booleanlist extends Core.Type_list {
    public List<Core.Type_boolean> vx_listboolean();
    public Core.Type_boolean vx_boolean(final Core.Type_int index);
  }

  public static class Class_booleanlist extends Core.Class_base implements Type_booleanlist {

    public List<Core.Type_boolean> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_boolean>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_boolean vx_boolean(final Core.Type_int index) {
      Core.Type_boolean output = Core.e_boolean;
      Core.Class_booleanlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_boolean> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_boolean> vx_listboolean() {
      List<Core.Type_boolean> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_boolean output = this.vx_boolean(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_booleanlist output = Core.vx_copy(Core.e_booleanlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_booleanlist output = this;
      boolean ischanged = false;
      Core.Class_booleanlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_boolean> listval = new ArrayList<Core.Type_boolean>(value.vx_listboolean());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_booleanlist) {
          Core.Type_booleanlist multi = (Core.Type_booleanlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listboolean());
        } else if (valsub instanceof Core.Type_boolean) {
          Core.Type_boolean allowsub = (Core.Type_boolean)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Boolean) {
          ischanged = true;
          listval.add(Core.vx_new(Core.t_boolean, valsub));
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_boolean) {
              Core.Type_boolean valitem = (Core.Type_boolean)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_booleanlist work = new Core.Class_booleanlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_booleanlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_booleanlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "booleanlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_boolean), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_booleanlist e_booleanlist = new Core.Class_booleanlist();
  public static final Core.Type_booleanlist t_booleanlist = new Core.Class_booleanlist();

  /**
   * type: collection
   * (type collection)
   */
  public interface Type_collection extends Core.Type_any {
  }

  public static class Class_collection extends Core.Class_base implements Type_collection {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_collection output = Core.vx_copy(Core.e_collection, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_collection output = this;
      boolean ischanged = false;
      Core.Class_collection value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_collection work = new Core.Class_collection();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_collection;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_collection;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "collection", // name
        "", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_list, Core.t_map), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_collection e_collection = new Core.Class_collection();
  public static final Core.Type_collection t_collection = new Core.Class_collection();

  /**
   * type: compilelanguages
   * (type compilelanguages)
   */
  public interface Type_compilelanguages extends Core.Type_any {
  }

  public static class Class_compilelanguages extends Core.Class_base implements Type_compilelanguages {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_compilelanguages output = Core.vx_copy(Core.e_compilelanguages, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_compilelanguages output = this;
      boolean ischanged = false;
      Core.Class_compilelanguages value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_compilelanguages work = new Core.Class_compilelanguages();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_compilelanguages;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_compilelanguages;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "compilelanguages", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_compilelanguages e_compilelanguages = new Core.Class_compilelanguages();
  public static final Core.Type_compilelanguages t_compilelanguages = new Core.Class_compilelanguages();

  /**
   * type: connect
   * General connect trait
   * (type connect)
   */
  public interface Type_connect extends Core.Type_any {
  }

  public static class Class_connect extends Core.Class_base implements Type_connect {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_connect output = Core.vx_copy(Core.e_connect, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_connect output = this;
      boolean ischanged = false;
      Core.Class_connect value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_connect work = new Core.Class_connect();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_connect;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_connect;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "connect", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_connect e_connect = new Core.Class_connect();
  public static final Core.Type_connect t_connect = new Core.Class_connect();

  /**
   * type: connectlist
   * List of connect
   * (type connectlist)
   */
  public interface Type_connectlist extends Core.Type_list {
    public List<Core.Type_connect> vx_listconnect();
    public Core.Type_connect vx_connect(final Core.Type_int index);
  }

  public static class Class_connectlist extends Core.Class_base implements Type_connectlist {

    public List<Core.Type_connect> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_connect>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_connect vx_connect(final Core.Type_int index) {
      Core.Type_connect output = Core.e_connect;
      Core.Class_connectlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_connect> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_connect> vx_listconnect() {
      List<Core.Type_connect> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_connect output = this.vx_connect(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_connectlist output = Core.vx_copy(Core.e_connectlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_connectlist output = this;
      boolean ischanged = false;
      Core.Class_connectlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_connect> listval = new ArrayList<Core.Type_connect>(value.vx_listconnect());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_connectlist) {
          Core.Type_connectlist multi = (Core.Type_connectlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listconnect());
        } else if (valsub instanceof Core.Type_connect) {
          Core.Type_connect allowsub = (Core.Type_connect)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_connect) {
          ischanged = true;
          listval.add((Core.Type_connect)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_connect) {
              Core.Type_connect valitem = (Core.Type_connect)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_connectlist work = new Core.Class_connectlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_connectlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_connectlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "connectlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_connect), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_connectlist e_connectlist = new Core.Class_connectlist();
  public static final Core.Type_connectlist t_connectlist = new Core.Class_connectlist();

  /**
   * type: connectmap
   * Map of connect
   * (type connectmap)
   */
  public interface Type_connectmap extends Core.Type_map {
    public Map<String, Core.Type_connect> vx_mapconnect();
    public Core.Type_connect vx_connect(final Core.Type_string key);
  }

  public static class Class_connectmap extends Core.Class_base implements Type_connectmap {

    public Map<String, Core.Type_connect> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_connect>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_connect) {
        Core.Type_connect castval = (Core.Type_connect)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_connect> map = new LinkedHashMap<String, Core.Type_connect>(this.vx_p_map);
        if (castval == Core.e_connect) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_connect vx_connect(final Core.Type_string key) {
      Core.Type_connect output = Core.e_connect;
      Core.Class_connectmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_connect> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_connect);
      return output;
    }

    @Override
    public Map<String, Core.Type_connect> vx_mapconnect() {
      Map<String, Core.Type_connect> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_connect(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_connectmap output = new Core.Class_connectmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_connect> map = new LinkedHashMap<String, Core.Type_connect>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_connect) {
          Core.Type_connect castval = (Core.Type_connect)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/connectmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_connectmap output = Core.vx_copy(Core.e_connectmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_connectmap output = this;
      boolean ischanged = false;
      Core.Class_connectmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_connect> mapval = new LinkedHashMap<String, Core.Type_connect>(value.vx_mapconnect());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/connectmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_connect valany = Core.e_connect;
          if (false) {
          } else if (valsub instanceof Core.Type_connect) {
            Core.Type_connect valallowed = (Core.Type_connect)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_connect) {
            valany = (Core.Type_connect)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/connectmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_connectmap work = new Core.Class_connectmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_connectmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_connectmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "connectmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_connect), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_connectmap e_connectmap = new Core.Class_connectmap();
  public static final Core.Type_connectmap t_connectmap = new Core.Class_connectmap();

  /**
   * type: const
   * Original Constant Class.
   * (type const)
   */
  public interface Type_const extends Core.Type_any {
  }

  public static class Class_const extends Core.Class_base implements Type_const {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_const output = Core.vx_copy(Core.e_const, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_const output = this;
      boolean ischanged = false;
      Core.Class_const value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_const work = new Core.Class_const();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_const;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_const;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "const", // name
        ":const", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_const e_const = new Core.Class_const();
  public static final Core.Type_const t_const = new Core.Class_const();

  /**
   * type: constdef
   * Const Definition Class for inspecting properties.
   * (type constdef)
   */
  public interface Type_constdef extends Core.Type_struct {
    public Core.Type_string pkgname();
    public Core.Type_string name();
    public Core.Type_any type();
  }

  public static class Class_constdef extends Core.Class_base implements Type_constdef {

    public Core.Type_string vx_p_pkgname = null;

    @Override
    public Core.Type_string pkgname() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_name = null;

    @Override
    public Core.Type_string name() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_any vx_p_type = null;

    @Override
    public Core.Type_any type() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_type;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":pkgname"))) {
        output = this.pkgname();
      } else if ((skey.equals(":name"))) {
        output = this.name();
      } else if ((skey.equals(":type"))) {
        output = this.type();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":name", this.name());
      map.put(":type", this.type());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_constdef output = Core.vx_copy(Core.e_constdef, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_constdef output = this;
      boolean ischanged = false;
      Core.Class_constdef value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_pkgname = value.pkgname();
      Core.Type_string vx_p_name = value.name();
      Core.Type_any vx_p_type = value.type();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":pkgname");
      validkeys.add(":name");
      validkeys.add(":type");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/constdef", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":pkgname"))) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valpkgname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_pkgname = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":name"))) {
            if (valsub == vx_p_name) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_name = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":type"))) {
            if (valsub == vx_p_type) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valtype = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_type = valtype;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("type"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_constdef work = new Core.Class_constdef();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_name = vx_p_name;
        work.vx_p_type = vx_p_type;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_constdef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_constdef;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "constdef", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_constdef e_constdef = new Core.Class_constdef();
  public static final Core.Type_constdef t_constdef = new Core.Class_constdef();

  /**
   * type: constlist
   * List of Const.
   * (type constlist)
   */
  public interface Type_constlist extends Core.Type_list {
  }

  public static class Class_constlist extends Core.Class_base implements Type_constlist {

    public List<Core.Type_any> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_any>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_any output = Core.e_any;
      Core.Class_constlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_constlist output = Core.vx_copy(Core.e_constlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_constlist output = this;
      boolean ischanged = false;
      Core.Class_constlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_any> listval = new ArrayList<Core.Type_any>(value.vx_list());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_constlist) {
          Core.Type_constlist multi = (Core.Type_constlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_list());
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any allowsub = (Core.Type_any)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_any) {
              Core.Type_any valitem = (Core.Type_any)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/constlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/constlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_constlist work = new Core.Class_constlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_constlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_constlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "constlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_constlist e_constlist = new Core.Class_constlist();
  public static final Core.Type_constlist t_constlist = new Core.Class_constlist();

  /**
   * type: constmap
   * Map of Const.
   * (type constmap)
   */
  public interface Type_constmap extends Core.Type_map {
  }

  public static class Class_constmap extends Core.Class_base implements Type_constmap {

    public Map<String, Core.Type_any> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_any>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_any) {
        Core.Type_any castval = (Core.Type_any)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
        if (castval == Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      Core.Class_constmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_any);
      return output;
    }

    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_constmap output = new Core.Class_constmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_any) {
          Core.Type_any castval = (Core.Type_any)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/constmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_constmap output = Core.vx_copy(Core.e_constmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_constmap output = this;
      boolean ischanged = false;
      Core.Class_constmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_any> mapval = new LinkedHashMap<String, Core.Type_any>(value.vx_map());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/constmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_any valany = Core.e_any;
          if (false) {
          } else if (valsub instanceof Core.Type_any) {
            Core.Type_any valallowed = (Core.Type_any)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_any) {
            valany = (Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/constmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_constmap work = new Core.Class_constmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_constmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_constmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "constmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_constmap e_constmap = new Core.Class_constmap();
  public static final Core.Type_constmap t_constmap = new Core.Class_constmap();

  /**
   * type: context
   * Context
   * (type context)
   */
  public interface Type_context extends Core.Type_struct {
    public Core.Type_string code();
    public Core.Type_session session();
    public Core.Type_setting setting();
    public Core.Type_state state();
  }

  public static class Class_context extends Core.Class_base implements Type_context {

    public Core.Type_string vx_p_code = null;

    @Override
    public Core.Type_string code() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_code;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_session vx_p_session = null;

    @Override
    public Core.Type_session session() {
      Core.Type_session output = Core.e_session;
      Core.Type_session testnull = vx_p_session;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_setting vx_p_setting = null;

    @Override
    public Core.Type_setting setting() {
      Core.Type_setting output = Core.e_setting;
      Core.Type_setting testnull = vx_p_setting;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_state vx_p_state = null;

    @Override
    public Core.Type_state state() {
      Core.Type_state output = Core.e_state;
      Core.Type_state testnull = vx_p_state;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":code"))) {
        output = this.code();
      } else if ((skey.equals(":session"))) {
        output = this.session();
      } else if ((skey.equals(":setting"))) {
        output = this.setting();
      } else if ((skey.equals(":state"))) {
        output = this.state();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":code", this.code());
      map.put(":session", this.session());
      map.put(":setting", this.setting());
      map.put(":state", this.state());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_context output = Core.vx_copy(Core.e_context, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_context output = this;
      boolean ischanged = false;
      Core.Class_context value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_code = value.code();
      Core.Type_session vx_p_session = value.session();
      Core.Type_setting vx_p_setting = value.setting();
      Core.Type_state vx_p_state = value.state();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":code");
      validkeys.add(":session");
      validkeys.add(":setting");
      validkeys.add(":state");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/context", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":code"))) {
            if (valsub == vx_p_code) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valcode = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_code = valcode;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_code = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("code"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":session"))) {
            if (valsub == vx_p_session) {
            } else if (valsub instanceof Core.Type_session) {
              Core.Type_session valsession = (Core.Type_session)valsub;
              ischanged = true;
              vx_p_session = valsession;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("session"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":setting"))) {
            if (valsub == vx_p_setting) {
            } else if (valsub instanceof Core.Type_setting) {
              Core.Type_setting valsetting = (Core.Type_setting)valsub;
              ischanged = true;
              vx_p_setting = valsetting;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("setting"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":state"))) {
            if (valsub == vx_p_state) {
            } else if (valsub instanceof Core.Type_state) {
              Core.Type_state valstate = (Core.Type_state)valsub;
              ischanged = true;
              vx_p_state = valstate;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("state"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_context work = new Core.Class_context();
        work.vx_p_code = vx_p_code;
        work.vx_p_session = vx_p_session;
        work.vx_p_setting = vx_p_setting;
        work.vx_p_state = vx_p_state;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_context;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "context", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_context e_context = new Core.Class_context();
  public static final Core.Type_context t_context = new Core.Class_context();

  /**
   * type: date
   * A simple UTC date.
   * (type date)
   */
  public interface Type_date extends Core.Type_any {
  }

  public static class Class_date extends Core.Class_base implements Type_date {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_date output = Core.vx_copy(Core.e_date, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_date output = this;
      boolean ischanged = false;
      Core.Class_date value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_date work = new Core.Class_date();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_date;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_date;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "date", // name
        ":string", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_date e_date = new Core.Class_date();
  public static final Core.Type_date t_date = new Core.Class_date();

  /**
   * type: decimal
   * A clean version of float like Java BigDecimal.
   * (type decimal)
   */
  public interface Type_decimal extends Core.Type_number {
    public float vx_float();
    public String vx_string();
  }

  public static class Class_decimal extends Core.Class_base implements Type_decimal {

    protected String vxdecimal = "0.0";
    
    @Override
    public float vx_float() {
      return Float.parseFloat(vxdecimal);
    }
    
    @Override
    public String vx_string() {
      return vxdecimal;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_decimal output = Core.vx_copy(Core.e_decimal, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_decimal output = this;
      boolean ischanged = false;
      Core.Class_decimal value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      String sval = value.vx_string();
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_string) {
          Core.Type_string valstring = (Core.Type_string)valsub;
          ischanged = true;
          sval = valstring.vx_string();
        } else if (valsub instanceof String) {
          String svalsub = (String)valsub;
          ischanged = true;
          sval = svalsub;
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_decimal work = new Core.Class_decimal();
        work.vxdecimal = sval;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_decimal;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_decimal;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "decimal", // name
        "", // extends
        Core.vx_new(Core.t_typelist, Core.t_number), // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_decimal e_decimal = new Core.Class_decimal();
  public static final Core.Type_decimal t_decimal = new Core.Class_decimal();

  /**
   * type: error
   * Error Type
   * (type error)
   */
  public interface Type_error extends Core.Type_any {
  }

  public static class Class_error extends Core.Class_base implements Type_error {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_error output = Core.vx_copy(Core.e_error, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_error output = this;
      boolean ischanged = false;
      Core.Class_error value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_error work = new Core.Class_error();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_error;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_error;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "error", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_error e_error = new Core.Class_error();
  public static final Core.Type_error t_error = new Core.Class_error();

  /**
   * type: float
   * Standard Floating Point Number
   * (type float)
   */
  public interface Type_float extends Core.Type_number {
    public float vx_float();
  }

  public static class Class_float extends Core.Class_base implements Type_float {

    protected float vxfloat = 0;
    
    @Override
    public float vx_float() {
      return vxfloat;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_float output = Core.vx_copy(Core.e_float, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_float output = this;
      boolean ischanged = false;
      Core.Class_float value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Float floatval = value.vx_float();
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_decimal) {
          Core.Type_decimal valdecimal = (Core.Type_decimal)valsub;
          ischanged = true;
          floatval += valdecimal.vx_float();
        } else if (valsub instanceof Core.Type_float) {
          Core.Type_float valfloat = (Core.Type_float)valsub;
          ischanged = true;
          floatval += valfloat.vx_float();
        } else if (valsub instanceof Core.Type_int) {
          Core.Type_int valint = (Core.Type_int)valsub;
          ischanged = true;
          floatval += valint.vx_int();
        } else if (valsub instanceof Core.Type_string) {
          Core.Type_string valstring = (Core.Type_string)valsub;
          ischanged = true;
          floatval += Float.parseFloat(valstring.vx_string());
        } else if (valsub instanceof Float) {
          Float fval = (Float)valsub;
          ischanged = true;
          floatval += fval;
        } else if (valsub instanceof Integer) {
          Integer ival = (Integer)valsub;
          ischanged = true;
          floatval += ival;
        } else if (valsub instanceof String) {
          String sval = (String)valsub;
          ischanged = true;
          floatval += Float.parseFloat(sval);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_float work = new Core.Class_float();
        work.vxfloat = floatval;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_float;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_float;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "float", // name
        "", // extends
        Core.vx_new(Core.t_typelist, Core.t_number), // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_float e_float = new Core.Class_float();
  public static final Core.Type_float t_float = new Core.Class_float();

  /**
   * type: func
   * Original Function Class.
   * (type func)
   */
  public interface Type_func extends Core.Type_any {
    public Core.Type_funcdef vx_funcdef();
  }

  public static class Class_func extends Core.Class_base implements Type_func {

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.e_funcdef;
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_func output = Core.vx_copy(Core.e_func, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_func output = this;
      boolean ischanged = false;
      Core.Class_func value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_func work = new Core.Class_func();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_func;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "func", // name
        ":func", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_func e_func = new Core.Class_func();
  public static final Core.Type_func t_func = new Core.Class_func();

  /**
   * type: funcdef
   * Func Definition Class for inspecting properties.
   * (type funcdef)
   */
  public interface Type_funcdef extends Core.Type_struct {
    public Core.Type_string pkgname();
    public Core.Type_string name();
    public Core.Type_int idx();
    public Core.Type_any type();
    public Core.Type_boolean async();
  }

  public static class Class_funcdef extends Core.Class_base implements Type_funcdef {

    public Core.Type_string vx_p_pkgname = null;

    @Override
    public Core.Type_string pkgname() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_name = null;

    @Override
    public Core.Type_string name() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_int vx_p_idx = null;

    @Override
    public Core.Type_int idx() {
      Core.Type_int output = Core.e_int;
      Core.Type_int testnull = vx_p_idx;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_any vx_p_type = null;

    @Override
    public Core.Type_any type() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_type;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_boolean vx_p_async = null;

    @Override
    public Core.Type_boolean async() {
      Core.Type_boolean output = Core.e_boolean;
      Core.Type_boolean testnull = vx_p_async;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":pkgname"))) {
        output = this.pkgname();
      } else if ((skey.equals(":name"))) {
        output = this.name();
      } else if ((skey.equals(":idx"))) {
        output = this.idx();
      } else if ((skey.equals(":type"))) {
        output = this.type();
      } else if ((skey.equals(":async"))) {
        output = this.async();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":name", this.name());
      map.put(":idx", this.idx());
      map.put(":type", this.type());
      map.put(":async", this.async());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_funcdef output = Core.vx_copy(Core.e_funcdef, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_funcdef output = this;
      boolean ischanged = false;
      Core.Class_funcdef value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_pkgname = value.pkgname();
      Core.Type_string vx_p_name = value.name();
      Core.Type_int vx_p_idx = value.idx();
      Core.Type_any vx_p_type = value.type();
      Core.Type_boolean vx_p_async = value.async();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":pkgname");
      validkeys.add(":name");
      validkeys.add(":idx");
      validkeys.add(":type");
      validkeys.add(":async");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":pkgname"))) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valpkgname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_pkgname = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":name"))) {
            if (valsub == vx_p_name) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_name = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":idx"))) {
            if (valsub == vx_p_idx) {
            } else if (valsub instanceof Core.Type_int) {
              Core.Type_int validx = (Core.Type_int)valsub;
              ischanged = true;
              vx_p_idx = validx;
            } else if (valsub instanceof Integer) {
              ischanged = true;
              vx_p_idx = Core.vx_new(Core.t_int, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("idx"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":type"))) {
            if (valsub == vx_p_type) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valtype = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_type = valtype;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("type"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":async"))) {
            if (valsub == vx_p_async) {
            } else if (valsub instanceof Core.Type_boolean) {
              Core.Type_boolean valasync = (Core.Type_boolean)valsub;
              ischanged = true;
              vx_p_async = valasync;
            } else if (valsub instanceof Boolean) {
              ischanged = true;
              vx_p_async = Core.vx_new(Core.t_boolean, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("async"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_funcdef work = new Core.Class_funcdef();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_name = vx_p_name;
        work.vx_p_idx = vx_p_idx;
        work.vx_p_type = vx_p_type;
        work.vx_p_async = vx_p_async;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_funcdef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_funcdef;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "funcdef", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_funcdef e_funcdef = new Core.Class_funcdef();
  public static final Core.Type_funcdef t_funcdef = new Core.Class_funcdef();

  /**
   * type: funclist
   * List of Func.
   * (type funclist)
   */
  public interface Type_funclist extends Core.Type_list {
    public List<Core.Type_func> vx_listfunc();
    public Core.Type_func vx_func(final Core.Type_int index);
  }

  public static class Class_funclist extends Core.Class_base implements Type_funclist {

    public List<Core.Type_func> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_func>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_func vx_func(final Core.Type_int index) {
      Core.Type_func output = Core.e_func;
      Core.Class_funclist list = this;
      int iindex = index.vx_int();
      List<Core.Type_func> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_func> vx_listfunc() {
      List<Core.Type_func> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_func output = this.vx_func(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_funclist output = Core.vx_copy(Core.e_funclist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_funclist output = this;
      boolean ischanged = false;
      Core.Class_funclist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_func> listval = new ArrayList<Core.Type_func>(value.vx_listfunc());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_funclist) {
          Core.Type_funclist multi = (Core.Type_funclist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listfunc());
        } else if (valsub instanceof Core.Type_func) {
          Core.Type_func allowsub = (Core.Type_func)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_func) {
          ischanged = true;
          listval.add((Core.Type_func)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_func) {
              Core.Type_func valitem = (Core.Type_func)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/funclist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/funclist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_funclist work = new Core.Class_funclist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_funclist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_funclist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "funclist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_func), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_funclist e_funclist = new Core.Class_funclist();
  public static final Core.Type_funclist t_funclist = new Core.Class_funclist();

  /**
   * type: funcmap
   * Map of Func.
   * (type funcmap)
   */
  public interface Type_funcmap extends Core.Type_map {
    public Map<String, Core.Type_func> vx_mapfunc();
    public Core.Type_func vx_func(final Core.Type_string key);
  }

  public static class Class_funcmap extends Core.Class_base implements Type_funcmap {

    public Map<String, Core.Type_func> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_func>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_func) {
        Core.Type_func castval = (Core.Type_func)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_func> map = new LinkedHashMap<String, Core.Type_func>(this.vx_p_map);
        if (castval == Core.e_func) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_func vx_func(final Core.Type_string key) {
      Core.Type_func output = Core.e_func;
      Core.Class_funcmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_func> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_func);
      return output;
    }

    @Override
    public Map<String, Core.Type_func> vx_mapfunc() {
      Map<String, Core.Type_func> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_func(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_funcmap output = new Core.Class_funcmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_func> map = new LinkedHashMap<String, Core.Type_func>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_func) {
          Core.Type_func castval = (Core.Type_func)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/funcmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_funcmap output = Core.vx_copy(Core.e_funcmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_funcmap output = this;
      boolean ischanged = false;
      Core.Class_funcmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_func> mapval = new LinkedHashMap<String, Core.Type_func>(value.vx_mapfunc());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/funcmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_func valany = Core.e_func;
          if (false) {
          } else if (valsub instanceof Core.Type_func) {
            Core.Type_func valallowed = (Core.Type_func)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_func) {
            valany = (Core.Type_func)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/funcmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_funcmap work = new Core.Class_funcmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_funcmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_funcmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "funcmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_func), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_funcmap e_funcmap = new Core.Class_funcmap();
  public static final Core.Type_funcmap t_funcmap = new Core.Class_funcmap();

  /**
   * type: int
   * A simple integer.
   * (type int)
   */
  public interface Type_int extends Core.Type_number {
    public int vx_int();
  }

  public static class Class_int extends Core.Class_base implements Type_int {

    protected int vxint = 0;
    
    @Override
    public int vx_int() {
      return vxint;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_int output = Core.vx_copy(Core.e_int, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_int output = this;
      boolean ischanged = false;
      Core.Class_int value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      int intval = value.vx_int();
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_int) {
          Core.Type_int valint = (Core.Type_int)valsub;
          ischanged = true;
          intval += valint.vx_int();
        } else if (valsub instanceof Integer) {
          Integer ival = (Integer)valsub;
          ischanged = true;
          intval += ival;
        } else if (valsub instanceof String) {
          String sval = (String)valsub;
          ischanged = true;
          intval += Integer.parseInt(sval);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_int work = new Core.Class_int();
        work.vxint = intval;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_int;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_int;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "int", // name
        "", // extends
        Core.vx_new(Core.t_typelist, Core.t_number), // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_int e_int = new Core.Class_int();
  public static final Core.Type_int t_int = new Core.Class_int();

  /**
   * type: intlist
   * A list of int.
   * (type intlist)
   */
  public interface Type_intlist extends Core.Type_list {
    public List<Core.Type_int> vx_listint();
    public Core.Type_int vx_int(final Core.Type_int index);
  }

  public static class Class_intlist extends Core.Class_base implements Type_intlist {

    public List<Core.Type_int> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_int>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_int vx_int(final Core.Type_int index) {
      Core.Type_int output = Core.e_int;
      Core.Class_intlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_int> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_int> vx_listint() {
      List<Core.Type_int> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_int output = this.vx_int(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_intlist output = Core.vx_copy(Core.e_intlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_intlist output = this;
      boolean ischanged = false;
      Core.Class_intlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_int> listval = new ArrayList<Core.Type_int>(value.vx_listint());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_intlist) {
          Core.Type_intlist multi = (Core.Type_intlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listint());
        } else if (valsub instanceof Core.Type_int) {
          Core.Type_int allowsub = (Core.Type_int)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Integer) {
          ischanged = true;
          listval.add(Core.vx_new(Core.t_int, valsub));
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_int) {
              Core.Type_int valitem = (Core.Type_int)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/intlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/intlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_intlist work = new Core.Class_intlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_intlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_intlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "intlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_int), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_intlist e_intlist = new Core.Class_intlist();
  public static final Core.Type_intlist t_intlist = new Core.Class_intlist();

  /**
   * type: intmap
   * A map of int.
   * (type intmap)
   */
  public interface Type_intmap extends Core.Type_map {
    public Map<String, Core.Type_int> vx_mapint();
    public Core.Type_int vx_int(final Core.Type_string key);
  }

  public static class Class_intmap extends Core.Class_base implements Type_intmap {

    public Map<String, Core.Type_int> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_int>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_int) {
        Core.Type_int castval = (Core.Type_int)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_int> map = new LinkedHashMap<String, Core.Type_int>(this.vx_p_map);
        if (castval == Core.e_int) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_int vx_int(final Core.Type_string key) {
      Core.Type_int output = Core.e_int;
      Core.Class_intmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_int> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_int);
      return output;
    }

    @Override
    public Map<String, Core.Type_int> vx_mapint() {
      Map<String, Core.Type_int> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_int(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_intmap output = new Core.Class_intmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_int> map = new LinkedHashMap<String, Core.Type_int>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_int) {
          Core.Type_int castval = (Core.Type_int)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/intmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_intmap output = Core.vx_copy(Core.e_intmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_intmap output = this;
      boolean ischanged = false;
      Core.Class_intmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_int> mapval = new LinkedHashMap<String, Core.Type_int>(value.vx_mapint());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/intmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_int valany = Core.e_int;
          if (false) {
          } else if (valsub instanceof Core.Type_int) {
            Core.Type_int valallowed = (Core.Type_int)valsub;
            valany = valallowed;
          } else if (valsub instanceof Integer) {
            valany = Core.vx_new(Core.t_int, valsub);
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/intmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_intmap work = new Core.Class_intmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_intmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_intmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "intmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_int), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_intmap e_intmap = new Core.Class_intmap();
  public static final Core.Type_intmap t_intmap = new Core.Class_intmap();

  /**
   * type: list
   * A simple untyped list.
   * (type list)
   */
  public interface Type_list extends Core.Type_any {
    public List<Core.Type_any> vx_list();
    public Core.Type_any vx_any(final Core.Type_int index);
  }

  public static class Class_list extends Core.Class_base implements Type_list {

    public List<Core.Type_any> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_any>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_any output = Core.e_any;
      Core.Class_list list = this;
      int iindex = index.vx_int();
      List<Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_list output = Core.vx_copy(Core.e_list, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_list output = this;
      boolean ischanged = false;
      Core.Class_list value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_any> listval = new ArrayList<Core.Type_any>(value.vx_list());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_list) {
          Core.Type_list multi = (Core.Type_list)valsub;
          ischanged = true;
          listval.addAll(multi.vx_list());
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any allowsub = (Core.Type_any)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_any) {
              Core.Type_any valitem = (Core.Type_any)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/list", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/list", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_list work = new Core.Class_list();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "list", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_list e_list = new Core.Class_list();
  public static final Core.Type_list t_list = new Core.Class_list();

  /**
   * type: listtype
   * A generic type that extends :list.
   * (type listtype)
   */
  public interface Type_listtype extends Core.Type_any {
  }

  public static class Class_listtype extends Core.Class_base implements Type_listtype {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_listtype output = Core.vx_copy(Core.e_listtype, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_listtype output = this;
      boolean ischanged = false;
      Core.Class_listtype value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_listtype work = new Core.Class_listtype();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_listtype;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_listtype;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "listtype", // name
        ":type", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_listtype e_listtype = new Core.Class_listtype();
  public static final Core.Type_listtype t_listtype = new Core.Class_listtype();

  /**
   * type: locale
   * Localization data.
   * (type locale)
   */
  public interface Type_locale extends Core.Type_struct {
  }

  public static class Class_locale extends Core.Class_base implements Type_locale {

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_locale output = Core.vx_copy(Core.e_locale, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_locale output = this;
      boolean ischanged = false;
      Core.Class_locale value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_locale work = new Core.Class_locale();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_locale;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_locale;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "locale", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_locale e_locale = new Core.Class_locale();
  public static final Core.Type_locale t_locale = new Core.Class_locale();

  /**
   * type: map
   * A simple untyped map.
   * (type map)
   */
  public interface Type_map extends Core.Type_any {
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval);
    public Core.Type_any vx_any(final Core.Type_string key);
    public Map<String, Core.Type_any> vx_map();
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value);
  }

  public static class Class_map extends Core.Class_base implements Type_map {

    public Map<String, Core.Type_any> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_any>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_any) {
        Core.Type_any castval = (Core.Type_any)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
        if (castval == Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      Core.Class_map map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_any);
      return output;
    }

    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_map output = new Core.Class_map();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_any) {
          Core.Type_any castval = (Core.Type_any)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/map", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_map output = Core.vx_copy(Core.e_map, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_map output = this;
      boolean ischanged = false;
      Core.Class_map value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_any> mapval = new LinkedHashMap<String, Core.Type_any>(value.vx_map());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/map", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_any valany = Core.e_any;
          if (false) {
          } else if (valsub instanceof Core.Type_any) {
            Core.Type_any valallowed = (Core.Type_any)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_any) {
            valany = (Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/map", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_map work = new Core.Class_map();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_map;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_map;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "map", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_map e_map = new Core.Class_map();
  public static final Core.Type_map t_map = new Core.Class_map();

  /**
   * type: maptype
   * A generic type that extends :map.
   * (type maptype)
   */
  public interface Type_maptype extends Core.Type_any {
  }

  public static class Class_maptype extends Core.Class_base implements Type_maptype {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_maptype output = Core.vx_copy(Core.e_maptype, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_maptype output = this;
      boolean ischanged = false;
      Core.Class_maptype value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_maptype work = new Core.Class_maptype();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_maptype;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_maptype;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "maptype", // name
        ":type", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_maptype e_maptype = new Core.Class_maptype();
  public static final Core.Type_maptype t_maptype = new Core.Class_maptype();

  /**
   * type: mempool
   * Memory Pool
   * (type mempool)
   */
  public interface Type_mempool extends Core.Type_struct {
    public <T extends Core.Type_any> T vx_restore(final T generic_any_1);
    public void vx_recycle(final Core.Type_any addany);
    public void vx_recyclelist(final List<Core.Type_any> addlistany);
    public Core.Type_value valuepool();
  }

  public static class Class_mempool extends Core.Class_base implements Type_mempool {

    private int vx_max = 20;
    
    private Map<String, Deque<Core.Type_any>> vx_maplistany = new ConcurrentHashMap<>();
    
    @Override
    public <T extends Core.Type_any> T vx_restore(final T generic_any_1) {
      T output = null;
      String typename = Core.f_typename_from_any(generic_any_1).vx_string();
      Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
      if (listany == null) {
      } else if (!listany.isEmpty()) {
        Core.Type_any any = listany.remove();
        if (any != null) {
          output = Core.f_any_from_any(generic_any_1, any);
        }
      }
      return output;
    }
    
    @Override
    public void vx_recycle(final Core.Type_any addany) {
      String typename = Core.f_typename_from_any(addany).vx_string();
      Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
      boolean isdestroy = true;
      int imax = this.vx_max;
      if (imax == 0) {
      } else if (listany == null) {
       isdestroy = false;
       listany = new ConcurrentLinkedDeque<Core.Type_any>();
       listany.add(addany);
       this.vx_maplistany.put(typename, listany);
      } else {
       int ilen = listany.size();
       if (ilen < imax) {
         listany.add(addany);
       }
      }
      if (isdestroy) {
        // destroy
      }
    }
    
    @Override
    public void vx_recyclelist(final List<Core.Type_any> addlistany) {
      for (Core.Type_any addany : addlistany) {
        this.vx_recycle(addany);
      }
    }

    public Core.Type_value vx_p_valuepool = null;

    @Override
    public Core.Type_value valuepool() {
      Core.Type_value output = Core.e_value;
      Core.Type_value testnull = vx_p_valuepool;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":valuepool"))) {
        output = this.valuepool();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":valuepool", this.valuepool());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_mempool output = Core.vx_copy(Core.e_mempool, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_mempool output = this;
      boolean ischanged = false;
      Core.Class_mempool value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_value vx_p_valuepool = value.valuepool();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":valuepool");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/mempool", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":valuepool"))) {
            if (valsub == vx_p_valuepool) {
            } else if (valsub instanceof Core.Type_value) {
              Core.Type_value valvaluepool = (Core.Type_value)valsub;
              ischanged = true;
              vx_p_valuepool = valvaluepool;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("valuepool"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/mempool", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_mempool work = new Core.Class_mempool();
        work.vx_p_valuepool = vx_p_valuepool;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_mempool;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_mempool;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "mempool", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_mempool e_mempool = new Core.Class_mempool();
  public static final Core.Type_mempool t_mempool = new Core.Class_mempool();

  /**
   * type: msg
   * Message Type for error handling
   * (type msg)
   */
  public interface Type_msg extends Core.Type_struct {
    public Core.Type_string code();
    public Core.Type_any detail();
    public Core.Type_string path();
    public Core.Type_int severity();
    public Core.Type_string text();
  }

  public static class Class_msg extends Core.Class_base implements Type_msg {

    public Exception err = null;

    public Core.Type_string vx_p_code = null;

    @Override
    public Core.Type_string code() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_code;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_any vx_p_detail = null;

    @Override
    public Core.Type_any detail() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_detail;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_path = null;

    @Override
    public Core.Type_string path() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_path;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_int vx_p_severity = null;

    @Override
    public Core.Type_int severity() {
      Core.Type_int output = Core.e_int;
      Core.Type_int testnull = vx_p_severity;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_text = null;

    @Override
    public Core.Type_string text() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_text;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":code"))) {
        output = this.code();
      } else if ((skey.equals(":detail"))) {
        output = this.detail();
      } else if ((skey.equals(":path"))) {
        output = this.path();
      } else if ((skey.equals(":severity"))) {
        output = this.severity();
      } else if ((skey.equals(":text"))) {
        output = this.text();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":code", this.code());
      map.put(":detail", this.detail());
      map.put(":path", this.path());
      map.put(":severity", this.severity());
      map.put(":text", this.text());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_msg output = Core.vx_copy(Core.e_msg, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_msg output = this;
      boolean ischanged = false;
      Core.Class_msg value = this;
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_code = value.code();
      Core.Type_any vx_p_detail = value.detail();
      Core.Type_string vx_p_path = value.path();
      Core.Type_int vx_p_severity = value.severity();
      Core.Type_string vx_p_text = value.text();
      String key = "";
      for (Object valsub : vals) {
        if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            key = valstr.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          }
        } else {
          if (false) {
          } else if ((key.equals(":code"))) {
            if (valsub == vx_p_code) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valcode = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_code = valcode;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_code = Core.vx_new(Core.t_string, valsub);
            }
          } else if ((key.equals(":detail"))) {
            if (valsub == vx_p_detail) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valdetail = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_detail = valdetail;
            }
          } else if ((key.equals(":path"))) {
            if (valsub == vx_p_path) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valpath = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_path = valpath;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_path = Core.vx_new(Core.t_string, valsub);
            }
          } else if ((key.equals(":severity"))) {
            if (valsub == vx_p_severity) {
            } else if (valsub instanceof Core.Type_int) {
              Core.Type_int valseverity = (Core.Type_int)valsub;
              ischanged = true;
              vx_p_severity = valseverity;
            } else if (valsub instanceof Integer) {
              ischanged = true;
              vx_p_severity = Core.vx_new(Core.t_int, valsub);
            }
          } else if ((key.equals(":text"))) {
            if (valsub == vx_p_text) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valtext = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_text = valtext;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_text = Core.vx_new(Core.t_string, valsub);
            }
          }
          key = "";
        }
      }
      if (ischanged) {
        Core.Class_msg work = new Core.Class_msg();
        work.vx_p_code = vx_p_code;
        work.vx_p_detail = vx_p_detail;
        work.vx_p_path = vx_p_path;
        work.vx_p_severity = vx_p_severity;
        work.vx_p_text = vx_p_text;
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msg;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msg;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "msg", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_msg e_msg = new Core.Class_msg();
  public static final Core.Type_msg t_msg = new Core.Class_msg();

  /**
   * type: msgblock
   * Block of Messages
   * (type msgblock)
   */
  public interface Type_msgblock extends Core.Type_struct {
    public Core.Type_msglist msgs();
    public Core.Type_msgblocklist msgblocks();
  }

  public static class Class_msgblock extends Core.Class_base implements Type_msgblock {

    public Core.Type_msglist vx_p_msgs = null;

    @Override
    public Core.Type_msglist msgs() {
      Core.Type_msglist output = Core.e_msglist;
      Core.Type_msglist testnull = vx_p_msgs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_msgblocklist vx_p_msgblocks = null;

    @Override
    public Core.Type_msgblocklist msgblocks() {
      Core.Type_msgblocklist output = Core.e_msgblocklist;
      Core.Type_msgblocklist testnull = vx_p_msgblocks;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":msgs"))) {
        output = this.msgs();
      } else if ((skey.equals(":msgblocks"))) {
        output = this.msgblocks();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":msgs", this.msgs());
      map.put(":msgblocks", this.msgblocks());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_msgblock output = Core.vx_copy(Core.e_msgblock, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_msgblock output = this;
      boolean ischanged = false;
      Core.Class_msgblock value = this;
      Core.Type_msgblock msgblock = this;
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_msglist vx_p_msgs = value.msgs();
      Core.Type_msgblocklist vx_p_msgblocks = value.msgblocks();
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          if (valsub != Core.e_msgblock) {
            vx_p_msgblocks = Core.vx_copy(vx_p_msgblocks, valsub);
            ischanged = true;
          }
        } else if (valsub instanceof Core.Type_msgblocklist) {
          if (valsub != Core.e_msgblocklist) {
            vx_p_msgblocks = Core.vx_copy(vx_p_msgblocks, valsub);
            ischanged = true;
          }
        } else if (valsub instanceof Core.Type_msg) {
          if (valsub != Core.e_msg) {
            vx_p_msgs = Core.vx_copy(vx_p_msgs, valsub);
            ischanged = true;
          }
        } else if (valsub instanceof Core.Type_msglist) {
          if (valsub != Core.e_msglist) {
            vx_p_msgs = Core.vx_copy(vx_p_msgs, valsub);
            ischanged = true;
          }
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            key = valstr.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          }
        } else {
          if (false) {
          } else if ((key.equals(":msgs"))) {
            if (valsub == vx_p_msgs) {
            } else if (valsub instanceof Core.Type_msglist) {
              Core.Type_msglist valmsgs = (Core.Type_msglist)valsub;
              ischanged = true;
              vx_p_msgs = valmsgs;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("msgs"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":msgblocks"))) {
            if (valsub == vx_p_msgblocks) {
            } else if (valsub instanceof Core.Type_msgblocklist) {
              Core.Type_msgblocklist valmsgblocks = (Core.Type_msgblocklist)valsub;
              ischanged = true;
              vx_p_msgblocks = valmsgblocks;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("msgblocks"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
          key = "";
        }
      }
      if (ischanged) {
        if ((vx_p_msgs.vx_list().size() == 0) && (vx_p_msgblocks.vx_list().size() == 1)) {
          output = vx_p_msgblocks.vx_listmsgblock().get(0);
        } else {
          Core.Class_msgblock work = new Core.Class_msgblock();
          work.vx_p_msgs = vx_p_msgs;
          work.vx_p_msgblocks = vx_p_msgblocks;
          output = work;
        }
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msgblock;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msgblock;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "msgblock", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_msgblock e_msgblock = new Core.Class_msgblock();
  public static final Core.Type_msgblock t_msgblock = new Core.Class_msgblock();

  /**
   * type: msgblocklist
   * List of Message Blocks
   * (type msgblocklist)
   */
  public interface Type_msgblocklist extends Core.Type_list {
    public List<Core.Type_msgblock> vx_listmsgblock();
    public Core.Type_msgblock vx_msgblock(final Core.Type_int index);
  }

  public static class Class_msgblocklist extends Core.Class_base implements Type_msgblocklist {

    public List<Core.Type_msgblock> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_msgblock>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_msgblock vx_msgblock(final Core.Type_int index) {
      Core.Type_msgblock output = Core.e_msgblock;
      Core.Class_msgblocklist list = this;
      int iindex = index.vx_int();
      List<Core.Type_msgblock> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_msgblock> vx_listmsgblock() {
      List<Core.Type_msgblock> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_msgblock output = this.vx_msgblock(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_msgblocklist output = Core.vx_copy(Core.e_msgblocklist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_msgblocklist output = this;
      boolean ischanged = false;
      Core.Class_msgblocklist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_msgblock> listval = new ArrayList<Core.Type_msgblock>(value.vx_listmsgblock());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msgblocklist) {
          Core.Type_msgblocklist multi = (Core.Type_msgblocklist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listmsgblock());
        } else if (valsub instanceof Core.Type_msgblock) {
          ischanged = true;
          listval.add((Core.Type_msgblock)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_msgblock) {
              Core.Type_msgblock valitem = (Core.Type_msgblock)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_msgblocklist work = new Core.Class_msgblocklist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msgblocklist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msgblocklist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "msgblocklist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_msgblock), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_msgblocklist e_msgblocklist = new Core.Class_msgblocklist();
  public static final Core.Type_msgblocklist t_msgblocklist = new Core.Class_msgblocklist();

  /**
   * type: msglist
   * List of Messages
   * (type msglist)
   */
  public interface Type_msglist extends Core.Type_list {
    public List<Core.Type_msg> vx_listmsg();
    public Core.Type_msg vx_msg(final Core.Type_int index);
  }

  public static class Class_msglist extends Core.Class_base implements Type_msglist {

    public List<Core.Type_msg> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_msg>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_msg vx_msg(final Core.Type_int index) {
      Core.Type_msg output = Core.e_msg;
      Core.Class_msglist list = this;
      int iindex = index.vx_int();
      List<Core.Type_msg> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_msg> vx_listmsg() {
      List<Core.Type_msg> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_msg output = this.vx_msg(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_msglist output = Core.vx_copy(Core.e_msglist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_msglist output = this;
      boolean ischanged = false;
      Core.Class_msglist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_msg> listval = new ArrayList<Core.Type_msg>(value.vx_listmsg());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msglist) {
          Core.Type_msglist multi = (Core.Type_msglist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listmsg());
        } else if (valsub instanceof Core.Type_msg) {
          ischanged = true;
          listval.add((Core.Type_msg)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_msg) {
              Core.Type_msg valitem = (Core.Type_msg)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/msglist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/msglist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_msglist work = new Core.Class_msglist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msglist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msglist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "msglist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_msg), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_msglist e_msglist = new Core.Class_msglist();
  public static final Core.Type_msglist t_msglist = new Core.Class_msglist();

  /**
   * type: none
   * No Type. No type is returned at all. e.g. Void
   * (type none)
   */
  public interface Type_none extends Core.Type_any {
  }

  public static class Class_none extends Core.Class_base implements Type_none {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_none output = Core.vx_copy(Core.e_none, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_none output = this;
      boolean ischanged = false;
      Core.Class_none value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_none work = new Core.Class_none();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_none;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_none;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "none", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_none e_none = new Core.Class_none();
  public static final Core.Type_none t_none = new Core.Class_none();

  /**
   * type: notype
   * No Type that allows no Types as a Value
   * (type notype)
   */
  public interface Type_notype extends Core.Type_any {
  }

  public static class Class_notype extends Core.Class_base implements Type_notype {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_notype output = Core.vx_copy(Core.e_notype, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_notype output = this;
      boolean ischanged = false;
      Core.Class_notype value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_notype work = new Core.Class_notype();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_notype;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_notype;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "notype", // name
        "", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_notype e_notype = new Core.Class_notype();
  public static final Core.Type_notype t_notype = new Core.Class_notype();

  /**
   * type: number
   * A generic number that could be int, float, or decimal.
   * (type number)
   */
  public interface Type_number extends Core.Type_any {
  }

  public static class Class_number extends Core.Class_base implements Type_number {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_number output = Core.vx_copy(Core.e_number, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_number output = this;
      boolean ischanged = false;
      Core.Class_number value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_number work = new Core.Class_number();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_number;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_number;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "number", // name
        "", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_number e_number = new Core.Class_number();
  public static final Core.Type_number t_number = new Core.Class_number();

  /**
   * type: numberlist
   * A list of number.
   * (type numberlist)
   */
  public interface Type_numberlist extends Core.Type_list {
    public List<Core.Type_number> vx_listnumber();
    public Core.Type_number vx_number(final Core.Type_int index);
  }

  public static class Class_numberlist extends Core.Class_base implements Type_numberlist {

    public List<Core.Type_number> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_number>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_number vx_number(final Core.Type_int index) {
      Core.Type_number output = Core.e_number;
      Core.Class_numberlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_number> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_number> vx_listnumber() {
      List<Core.Type_number> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_number output = this.vx_number(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_numberlist output = Core.vx_copy(Core.e_numberlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_numberlist output = this;
      boolean ischanged = false;
      Core.Class_numberlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_number> listval = new ArrayList<Core.Type_number>(value.vx_listnumber());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_numberlist) {
          Core.Type_numberlist multi = (Core.Type_numberlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listnumber());
        } else if (valsub instanceof Core.Type_number) {
          Core.Type_number allowsub = (Core.Type_number)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_number) {
          ischanged = true;
          listval.add((Core.Type_number)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_number) {
              Core.Type_number valitem = (Core.Type_number)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_numberlist work = new Core.Class_numberlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_numberlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_numberlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "numberlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_number), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_numberlist e_numberlist = new Core.Class_numberlist();
  public static final Core.Type_numberlist t_numberlist = new Core.Class_numberlist();

  /**
   * type: numbermap
   * A map of number.
   * (type numbermap)
   */
  public interface Type_numbermap extends Core.Type_map {
    public Map<String, Core.Type_number> vx_mapnumber();
    public Core.Type_number vx_number(final Core.Type_string key);
  }

  public static class Class_numbermap extends Core.Class_base implements Type_numbermap {

    public Map<String, Core.Type_number> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_number>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_number) {
        Core.Type_number castval = (Core.Type_number)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_number> map = new LinkedHashMap<String, Core.Type_number>(this.vx_p_map);
        if (castval == Core.e_number) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_number vx_number(final Core.Type_string key) {
      Core.Type_number output = Core.e_number;
      Core.Class_numbermap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_number> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_number);
      return output;
    }

    @Override
    public Map<String, Core.Type_number> vx_mapnumber() {
      Map<String, Core.Type_number> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_number(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_numbermap output = new Core.Class_numbermap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_number> map = new LinkedHashMap<String, Core.Type_number>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_number) {
          Core.Type_number castval = (Core.Type_number)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/numbermap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_numbermap output = Core.vx_copy(Core.e_numbermap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_numbermap output = this;
      boolean ischanged = false;
      Core.Class_numbermap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_number> mapval = new LinkedHashMap<String, Core.Type_number>(value.vx_mapnumber());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/numbermap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_number valany = Core.e_number;
          if (false) {
          } else if (valsub instanceof Core.Type_number) {
            Core.Type_number valallowed = (Core.Type_number)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_number) {
            valany = (Core.Type_number)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/numbermap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_numbermap work = new Core.Class_numbermap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_numbermap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_numbermap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "numbermap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_number), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_numbermap e_numbermap = new Core.Class_numbermap();
  public static final Core.Type_numbermap t_numbermap = new Core.Class_numbermap();

  /**
   * type: package
   * A package that store types, consts and funcs.
   * (type package)
   */
  public interface Type_package extends Core.Type_struct {
    public Core.Type_string pkgname();
    public Core.Type_constmap constmap();
    public Core.Type_funcmap funcmap();
    public Core.Type_typemap typemap();
    public Core.Type_map emptymap();
  }

  public static class Class_package extends Core.Class_base implements Type_package {

    public Core.Type_string vx_p_pkgname = null;

    @Override
    public Core.Type_string pkgname() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_constmap vx_p_constmap = null;

    @Override
    public Core.Type_constmap constmap() {
      Core.Type_constmap output = Core.e_constmap;
      Core.Type_constmap testnull = vx_p_constmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_funcmap vx_p_funcmap = null;

    @Override
    public Core.Type_funcmap funcmap() {
      Core.Type_funcmap output = Core.e_funcmap;
      Core.Type_funcmap testnull = vx_p_funcmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_typemap vx_p_typemap = null;

    @Override
    public Core.Type_typemap typemap() {
      Core.Type_typemap output = Core.e_typemap;
      Core.Type_typemap testnull = vx_p_typemap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_map vx_p_emptymap = null;

    @Override
    public Core.Type_map emptymap() {
      Core.Type_map output = Core.e_map;
      Core.Type_map testnull = vx_p_emptymap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":pkgname"))) {
        output = this.pkgname();
      } else if ((skey.equals(":constmap"))) {
        output = this.constmap();
      } else if ((skey.equals(":funcmap"))) {
        output = this.funcmap();
      } else if ((skey.equals(":typemap"))) {
        output = this.typemap();
      } else if ((skey.equals(":emptymap"))) {
        output = this.emptymap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":constmap", this.constmap());
      map.put(":funcmap", this.funcmap());
      map.put(":typemap", this.typemap());
      map.put(":emptymap", this.emptymap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_package output = Core.vx_copy(Core.e_package, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_package output = this;
      boolean ischanged = false;
      Core.Class_package value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_pkgname = value.pkgname();
      Core.Type_constmap vx_p_constmap = value.constmap();
      Core.Type_funcmap vx_p_funcmap = value.funcmap();
      Core.Type_typemap vx_p_typemap = value.typemap();
      Core.Type_map vx_p_emptymap = value.emptymap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":pkgname");
      validkeys.add(":constmap");
      validkeys.add(":funcmap");
      validkeys.add(":typemap");
      validkeys.add(":emptymap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/package", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":pkgname"))) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valpkgname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_pkgname = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":constmap"))) {
            if (valsub == vx_p_constmap) {
            } else if (valsub instanceof Core.Type_constmap) {
              Core.Type_constmap valconstmap = (Core.Type_constmap)valsub;
              ischanged = true;
              vx_p_constmap = valconstmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("constmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":funcmap"))) {
            if (valsub == vx_p_funcmap) {
            } else if (valsub instanceof Core.Type_funcmap) {
              Core.Type_funcmap valfuncmap = (Core.Type_funcmap)valsub;
              ischanged = true;
              vx_p_funcmap = valfuncmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("funcmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":typemap"))) {
            if (valsub == vx_p_typemap) {
            } else if (valsub instanceof Core.Type_typemap) {
              Core.Type_typemap valtypemap = (Core.Type_typemap)valsub;
              ischanged = true;
              vx_p_typemap = valtypemap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("typemap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":emptymap"))) {
            if (valsub == vx_p_emptymap) {
            } else if (valsub instanceof Core.Type_map) {
              Core.Type_map valemptymap = (Core.Type_map)valsub;
              ischanged = true;
              vx_p_emptymap = valemptymap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("emptymap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_package work = new Core.Class_package();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_constmap = vx_p_constmap;
        work.vx_p_funcmap = vx_p_funcmap;
        work.vx_p_typemap = vx_p_typemap;
        work.vx_p_emptymap = vx_p_emptymap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_package;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_package;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "package", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_package e_package = new Core.Class_package();
  public static final Core.Type_package t_package = new Core.Class_package();

  /**
   * type: packagemap
   * (type packagemap)
   */
  public interface Type_packagemap extends Core.Type_map {
    public Map<String, Core.Type_package> vx_mappackage();
    public Core.Type_package vx_package(final Core.Type_string key);
  }

  public static class Class_packagemap extends Core.Class_base implements Type_packagemap {

    public Map<String, Core.Type_package> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_package>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_package) {
        Core.Type_package castval = (Core.Type_package)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_package> map = new LinkedHashMap<String, Core.Type_package>(this.vx_p_map);
        if (castval == Core.e_package) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_package vx_package(final Core.Type_string key) {
      Core.Type_package output = Core.e_package;
      Core.Class_packagemap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_package> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_package);
      return output;
    }

    @Override
    public Map<String, Core.Type_package> vx_mappackage() {
      Map<String, Core.Type_package> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_package(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_packagemap output = new Core.Class_packagemap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_package> map = new LinkedHashMap<String, Core.Type_package>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_package) {
          Core.Type_package castval = (Core.Type_package)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/packagemap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_packagemap output = Core.vx_copy(Core.e_packagemap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_packagemap output = this;
      boolean ischanged = false;
      Core.Class_packagemap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_package> mapval = new LinkedHashMap<String, Core.Type_package>(value.vx_mappackage());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/packagemap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_package valany = Core.e_package;
          if (false) {
          } else if (valsub instanceof Core.Type_package) {
            Core.Type_package valallowed = (Core.Type_package)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_package) {
            valany = (Core.Type_package)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/packagemap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_packagemap work = new Core.Class_packagemap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_packagemap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_packagemap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "packagemap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_package), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_packagemap e_packagemap = new Core.Class_packagemap();
  public static final Core.Type_packagemap t_packagemap = new Core.Class_packagemap();

  /**
   * type: permission
   * Permission
   * (type permission)
   */
  public interface Type_permission extends Core.Type_struct {
    public Core.Type_string id();
  }

  public static class Class_permission extends Core.Class_base implements Type_permission {

    public Core.Type_string vx_p_id = null;

    @Override
    public Core.Type_string id() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_id;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":id"))) {
        output = this.id();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":id", this.id());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_permission output = Core.vx_copy(Core.e_permission, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_permission output = this;
      boolean ischanged = false;
      Core.Class_permission value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_id = value.id();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":id");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/permission", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":id"))) {
            if (valsub == vx_p_id) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valid = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_id = valid;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_id = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("id"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/permission", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_permission work = new Core.Class_permission();
        work.vx_p_id = vx_p_id;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_permission;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_permission;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "permission", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_permission e_permission = new Core.Class_permission();
  public static final Core.Type_permission t_permission = new Core.Class_permission();

  /**
   * type: permissionlist
   * List of Permission
   * (type permissionlist)
   */
  public interface Type_permissionlist extends Core.Type_list {
    public List<Core.Type_permission> vx_listpermission();
    public Core.Type_permission vx_permission(final Core.Type_int index);
  }

  public static class Class_permissionlist extends Core.Class_base implements Type_permissionlist {

    public List<Core.Type_permission> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_permission>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_permission vx_permission(final Core.Type_int index) {
      Core.Type_permission output = Core.e_permission;
      Core.Class_permissionlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_permission> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_permission> vx_listpermission() {
      List<Core.Type_permission> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_permission output = this.vx_permission(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_permissionlist output = Core.vx_copy(Core.e_permissionlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_permissionlist output = this;
      boolean ischanged = false;
      Core.Class_permissionlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_permission> listval = new ArrayList<Core.Type_permission>(value.vx_listpermission());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_permissionlist) {
          Core.Type_permissionlist multi = (Core.Type_permissionlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listpermission());
        } else if (valsub instanceof Core.Type_permission) {
          Core.Type_permission allowsub = (Core.Type_permission)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_permission) {
          ischanged = true;
          listval.add((Core.Type_permission)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_permission) {
              Core.Type_permission valitem = (Core.Type_permission)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_permissionlist work = new Core.Class_permissionlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_permissionlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_permissionlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "permissionlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_permission), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_permissionlist e_permissionlist = new Core.Class_permissionlist();
  public static final Core.Type_permissionlist t_permissionlist = new Core.Class_permissionlist();

  /**
   * type: permissionmap
   * Map of Permission
   * (type permissionmap)
   */
  public interface Type_permissionmap extends Core.Type_map {
    public Map<String, Core.Type_permission> vx_mappermission();
    public Core.Type_permission vx_permission(final Core.Type_string key);
  }

  public static class Class_permissionmap extends Core.Class_base implements Type_permissionmap {

    public Map<String, Core.Type_permission> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_permission>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_permission) {
        Core.Type_permission castval = (Core.Type_permission)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_permission> map = new LinkedHashMap<String, Core.Type_permission>(this.vx_p_map);
        if (castval == Core.e_permission) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_permission vx_permission(final Core.Type_string key) {
      Core.Type_permission output = Core.e_permission;
      Core.Class_permissionmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_permission> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_permission);
      return output;
    }

    @Override
    public Map<String, Core.Type_permission> vx_mappermission() {
      Map<String, Core.Type_permission> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_permission(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_permissionmap output = new Core.Class_permissionmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_permission> map = new LinkedHashMap<String, Core.Type_permission>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_permission) {
          Core.Type_permission castval = (Core.Type_permission)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/permissionmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_permissionmap output = Core.vx_copy(Core.e_permissionmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_permissionmap output = this;
      boolean ischanged = false;
      Core.Class_permissionmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_permission> mapval = new LinkedHashMap<String, Core.Type_permission>(value.vx_mappermission());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/permissionmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_permission valany = Core.e_permission;
          if (false) {
          } else if (valsub instanceof Core.Type_permission) {
            Core.Type_permission valallowed = (Core.Type_permission)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_permission) {
            valany = (Core.Type_permission)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/permissionmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_permissionmap work = new Core.Class_permissionmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_permissionmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_permissionmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "permissionmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_permission), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_permissionmap e_permissionmap = new Core.Class_permissionmap();
  public static final Core.Type_permissionmap t_permissionmap = new Core.Class_permissionmap();

  /**
   * type: project
   * A project.
   * (type project)
   */
  public interface Type_project extends Core.Type_struct {
    public Core.Type_packagemap packagemap();
  }

  public static class Class_project extends Core.Class_base implements Type_project {

    public Core.Type_packagemap vx_p_packagemap = null;

    @Override
    public Core.Type_packagemap packagemap() {
      Core.Type_packagemap output = Core.e_packagemap;
      Core.Type_packagemap testnull = vx_p_packagemap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":packagemap"))) {
        output = this.packagemap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":packagemap", this.packagemap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_project output = Core.vx_copy(Core.e_project, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_project output = this;
      boolean ischanged = false;
      Core.Class_project value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_packagemap vx_p_packagemap = value.packagemap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":packagemap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/project", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":packagemap"))) {
            if (valsub == vx_p_packagemap) {
            } else if (valsub instanceof Core.Type_packagemap) {
              Core.Type_packagemap valpackagemap = (Core.Type_packagemap)valsub;
              ischanged = true;
              vx_p_packagemap = valpackagemap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("packagemap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/project", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_project work = new Core.Class_project();
        work.vx_p_packagemap = vx_p_packagemap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_project;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_project;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "project", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_project e_project = new Core.Class_project();
  public static final Core.Type_project t_project = new Core.Class_project();

  /**
   * type: security
   * Security rules
   * (type security)
   */
  public interface Type_security extends Core.Type_struct {
    public Core.Type_funclist allowfuncs();
    public Core.Type_permissionlist permissions();
    public Core.Type_permissionmap permissionmap();
  }

  public static class Class_security extends Core.Class_base implements Type_security {

    public Core.Type_funclist vx_p_allowfuncs = null;

    @Override
    public Core.Type_funclist allowfuncs() {
      Core.Type_funclist output = Core.e_funclist;
      Core.Type_funclist testnull = vx_p_allowfuncs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_permissionlist vx_p_permissions = null;

    @Override
    public Core.Type_permissionlist permissions() {
      Core.Type_permissionlist output = Core.e_permissionlist;
      Core.Type_permissionlist testnull = vx_p_permissions;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_permissionmap vx_p_permissionmap = null;

    @Override
    public Core.Type_permissionmap permissionmap() {
      Core.Type_permissionmap output = Core.e_permissionmap;
      Core.Type_permissionmap testnull = vx_p_permissionmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":allowfuncs"))) {
        output = this.allowfuncs();
      } else if ((skey.equals(":permissions"))) {
        output = this.permissions();
      } else if ((skey.equals(":permissionmap"))) {
        output = this.permissionmap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":allowfuncs", this.allowfuncs());
      map.put(":permissions", this.permissions());
      map.put(":permissionmap", this.permissionmap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_security output = Core.vx_copy(Core.e_security, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_security output = this;
      boolean ischanged = false;
      Core.Class_security value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_funclist vx_p_allowfuncs = value.allowfuncs();
      Core.Type_permissionlist vx_p_permissions = value.permissions();
      Core.Type_permissionmap vx_p_permissionmap = value.permissionmap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":allowfuncs");
      validkeys.add(":permissions");
      validkeys.add(":permissionmap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/security", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":allowfuncs"))) {
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub instanceof Core.Type_funclist) {
              Core.Type_funclist valallowfuncs = (Core.Type_funclist)valsub;
              ischanged = true;
              vx_p_allowfuncs = valallowfuncs;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("allowfuncs"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":permissions"))) {
            if (valsub == vx_p_permissions) {
            } else if (valsub instanceof Core.Type_permissionlist) {
              Core.Type_permissionlist valpermissions = (Core.Type_permissionlist)valsub;
              ischanged = true;
              vx_p_permissions = valpermissions;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("permissions"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":permissionmap"))) {
            if (valsub == vx_p_permissionmap) {
            } else if (valsub instanceof Core.Type_permissionmap) {
              Core.Type_permissionmap valpermissionmap = (Core.Type_permissionmap)valsub;
              ischanged = true;
              vx_p_permissionmap = valpermissionmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("permissionmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_security work = new Core.Class_security();
        work.vx_p_allowfuncs = vx_p_allowfuncs;
        work.vx_p_permissions = vx_p_permissions;
        work.vx_p_permissionmap = vx_p_permissionmap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_security;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_security;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "security", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_security e_security = new Core.Class_security();
  public static final Core.Type_security t_security = new Core.Class_security();

  /**
   * type: session
   * Session
   * (type session)
   */
  public interface Type_session extends Core.Type_struct {
    public Core.Type_user user();
    public Core.Type_connectlist connectlist();
    public Core.Type_connectmap connectmap();
    public Core.Type_locale locale();
    public Core.Type_translation translation();
    public Core.Type_translationmap translationmap();
  }

  public static class Class_session extends Core.Class_base implements Type_session {

    public Core.Type_user vx_p_user = null;

    @Override
    public Core.Type_user user() {
      Core.Type_user output = Core.e_user;
      Core.Type_user testnull = vx_p_user;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_connectlist vx_p_connectlist = null;

    @Override
    public Core.Type_connectlist connectlist() {
      Core.Type_connectlist output = Core.e_connectlist;
      Core.Type_connectlist testnull = vx_p_connectlist;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_connectmap vx_p_connectmap = null;

    @Override
    public Core.Type_connectmap connectmap() {
      Core.Type_connectmap output = Core.e_connectmap;
      Core.Type_connectmap testnull = vx_p_connectmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_locale vx_p_locale = null;

    @Override
    public Core.Type_locale locale() {
      Core.Type_locale output = Core.e_locale;
      Core.Type_locale testnull = vx_p_locale;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_translation vx_p_translation = null;

    @Override
    public Core.Type_translation translation() {
      Core.Type_translation output = Core.e_translation;
      Core.Type_translation testnull = vx_p_translation;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_translationmap vx_p_translationmap = null;

    @Override
    public Core.Type_translationmap translationmap() {
      Core.Type_translationmap output = Core.e_translationmap;
      Core.Type_translationmap testnull = vx_p_translationmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":user"))) {
        output = this.user();
      } else if ((skey.equals(":connectlist"))) {
        output = this.connectlist();
      } else if ((skey.equals(":connectmap"))) {
        output = this.connectmap();
      } else if ((skey.equals(":locale"))) {
        output = this.locale();
      } else if ((skey.equals(":translation"))) {
        output = this.translation();
      } else if ((skey.equals(":translationmap"))) {
        output = this.translationmap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":user", this.user());
      map.put(":connectlist", this.connectlist());
      map.put(":connectmap", this.connectmap());
      map.put(":locale", this.locale());
      map.put(":translation", this.translation());
      map.put(":translationmap", this.translationmap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_session output = Core.vx_copy(Core.e_session, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_session output = this;
      boolean ischanged = false;
      Core.Class_session value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_user vx_p_user = value.user();
      Core.Type_connectlist vx_p_connectlist = value.connectlist();
      Core.Type_connectmap vx_p_connectmap = value.connectmap();
      Core.Type_locale vx_p_locale = value.locale();
      Core.Type_translation vx_p_translation = value.translation();
      Core.Type_translationmap vx_p_translationmap = value.translationmap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":user");
      validkeys.add(":connectlist");
      validkeys.add(":connectmap");
      validkeys.add(":locale");
      validkeys.add(":translation");
      validkeys.add(":translationmap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/session", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":user"))) {
            if (valsub == vx_p_user) {
            } else if (valsub instanceof Core.Type_user) {
              Core.Type_user valuser = (Core.Type_user)valsub;
              ischanged = true;
              vx_p_user = valuser;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("user"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":connectlist"))) {
            if (valsub == vx_p_connectlist) {
            } else if (valsub instanceof Core.Type_connectlist) {
              Core.Type_connectlist valconnectlist = (Core.Type_connectlist)valsub;
              ischanged = true;
              vx_p_connectlist = valconnectlist;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("connectlist"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":connectmap"))) {
            if (valsub == vx_p_connectmap) {
            } else if (valsub instanceof Core.Type_connectmap) {
              Core.Type_connectmap valconnectmap = (Core.Type_connectmap)valsub;
              ischanged = true;
              vx_p_connectmap = valconnectmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("connectmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":locale"))) {
            if (valsub == vx_p_locale) {
            } else if (valsub instanceof Core.Type_locale) {
              Core.Type_locale vallocale = (Core.Type_locale)valsub;
              ischanged = true;
              vx_p_locale = vallocale;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("locale"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":translation"))) {
            if (valsub == vx_p_translation) {
            } else if (valsub instanceof Core.Type_translation) {
              Core.Type_translation valtranslation = (Core.Type_translation)valsub;
              ischanged = true;
              vx_p_translation = valtranslation;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("translation"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":translationmap"))) {
            if (valsub == vx_p_translationmap) {
            } else if (valsub instanceof Core.Type_translationmap) {
              Core.Type_translationmap valtranslationmap = (Core.Type_translationmap)valsub;
              ischanged = true;
              vx_p_translationmap = valtranslationmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("translationmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_session work = new Core.Class_session();
        work.vx_p_user = vx_p_user;
        work.vx_p_connectlist = vx_p_connectlist;
        work.vx_p_connectmap = vx_p_connectmap;
        work.vx_p_locale = vx_p_locale;
        work.vx_p_translation = vx_p_translation;
        work.vx_p_translationmap = vx_p_translationmap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_session;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_session;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "session", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_session e_session = new Core.Class_session();
  public static final Core.Type_session t_session = new Core.Class_session();

  /**
   * type: setting
   * Settings
   * (type setting)
   */
  public interface Type_setting extends Core.Type_struct {
    public Core.Type_stringmap pathmap();
  }

  public static class Class_setting extends Core.Class_base implements Type_setting {

    public Core.Type_stringmap vx_p_pathmap = null;

    @Override
    public Core.Type_stringmap pathmap() {
      Core.Type_stringmap output = Core.e_stringmap;
      Core.Type_stringmap testnull = vx_p_pathmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":pathmap"))) {
        output = this.pathmap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":pathmap", this.pathmap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_setting output = Core.vx_copy(Core.e_setting, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_setting output = this;
      boolean ischanged = false;
      Core.Class_setting value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_stringmap vx_p_pathmap = value.pathmap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":pathmap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/setting", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":pathmap"))) {
            if (valsub == vx_p_pathmap) {
            } else if (valsub instanceof Core.Type_stringmap) {
              Core.Type_stringmap valpathmap = (Core.Type_stringmap)valsub;
              ischanged = true;
              vx_p_pathmap = valpathmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("pathmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/setting", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_setting work = new Core.Class_setting();
        work.vx_p_pathmap = vx_p_pathmap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_setting;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_setting;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "setting", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_setting e_setting = new Core.Class_setting();
  public static final Core.Type_setting t_setting = new Core.Class_setting();

  /**
   * type: state
   * State. Note that this type is has mutable values.
   * (type state)
   */
  public interface Type_state extends Core.Type_struct {
    public Core.Type_statelistenermap statelistenermap();
  }

  public static class Class_state extends Core.Class_base implements Type_state {

    public Core.Type_statelistenermap vx_p_statelistenermap = null;

    @Override
    public Core.Type_statelistenermap statelistenermap() {
      Core.Type_statelistenermap output = Core.e_statelistenermap;
      Core.Type_statelistenermap testnull = vx_p_statelistenermap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":statelistenermap"))) {
        output = this.statelistenermap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":statelistenermap", this.statelistenermap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_state output = Core.vx_copy(Core.e_state, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_state output = this;
      boolean ischanged = false;
      Core.Class_state value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_statelistenermap vx_p_statelistenermap = value.statelistenermap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":statelistenermap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/state", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":statelistenermap"))) {
            if (valsub == vx_p_statelistenermap) {
            } else if (valsub instanceof Core.Type_statelistenermap) {
              Core.Type_statelistenermap valstatelistenermap = (Core.Type_statelistenermap)valsub;
              ischanged = true;
              vx_p_statelistenermap = valstatelistenermap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("statelistenermap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/state", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_state work = new Core.Class_state();
        work.vx_p_statelistenermap = vx_p_statelistenermap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_state;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_state;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "state", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_state e_state = new Core.Class_state();
  public static final Core.Type_state t_state = new Core.Class_state();

  /**
   * type: statelistener
   * (type statelistener)
   */
  public interface Type_statelistener extends Core.Type_struct {
    public Core.Type_string name();
    public Core.Type_any value();
    public Core.Func_boolean_from_none fn_boolean();
  }

  public static class Class_statelistener extends Core.Class_base implements Type_statelistener {

    public Core.Type_string vx_p_name = null;

    @Override
    public Core.Type_string name() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_any vx_p_value = null;

    @Override
    public Core.Type_any value() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_value;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Func_boolean_from_none vx_p_fn_boolean = null;

    @Override
    public Core.Func_boolean_from_none fn_boolean() {
      Core.Func_boolean_from_none output = Core.e_boolean_from_none;
      Core.Func_boolean_from_none testnull = vx_p_fn_boolean;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":name"))) {
        output = this.name();
      } else if ((skey.equals(":value"))) {
        output = this.value();
      } else if ((skey.equals(":fn-boolean"))) {
        output = this.fn_boolean();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":name", this.name());
      map.put(":value", this.value());
      map.put(":fn-boolean", this.fn_boolean());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_statelistener output = Core.vx_copy(Core.e_statelistener, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_statelistener output = this;
      boolean ischanged = false;
      Core.Class_statelistener value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_name = value.name();
      Core.Type_any vx_p_value = value.value();
      Core.Func_boolean_from_none vx_p_fn_boolean = value.fn_boolean();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":name");
      validkeys.add(":value");
      validkeys.add(":fn-boolean");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/statelistener", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":name"))) {
            if (valsub == vx_p_name) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_name = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":value"))) {
            if (valsub == vx_p_value) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valvalue = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_value = valvalue;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("value"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":fn-boolean"))) {
            if (valsub == vx_p_fn_boolean) {
            } else if (valsub instanceof Core.Func_boolean_from_none) {
              Core.Func_boolean_from_none valfn_boolean = (Core.Func_boolean_from_none)valsub;
              ischanged = true;
              vx_p_fn_boolean = valfn_boolean;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("fn-boolean"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_statelistener work = new Core.Class_statelistener();
        work.vx_p_name = vx_p_name;
        work.vx_p_value = vx_p_value;
        work.vx_p_fn_boolean = vx_p_fn_boolean;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_statelistener;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_statelistener;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "statelistener", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_statelistener e_statelistener = new Core.Class_statelistener();
  public static final Core.Type_statelistener t_statelistener = new Core.Class_statelistener();

  /**
   * type: statelistenermap
   * Mutable map of statelisteners
   * (type statelistenermap)
   */
  public interface Type_statelistenermap extends Core.Type_map {
    public Map<String, Core.Type_statelistener> vx_mapstatelistener();
    public Core.Type_statelistener vx_statelistener(final Core.Type_string key);
  }

  public static class Class_statelistenermap extends Core.Class_base implements Type_statelistenermap {

    public Map<String, Core.Type_statelistener> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_statelistener>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_statelistener) {
        Core.Type_statelistener castval = (Core.Type_statelistener)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_statelistener> map = new LinkedHashMap<String, Core.Type_statelistener>(this.vx_p_map);
        if (castval == Core.e_statelistener) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_statelistener vx_statelistener(final Core.Type_string key) {
      Core.Type_statelistener output = Core.e_statelistener;
      Core.Class_statelistenermap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_statelistener> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_statelistener);
      return output;
    }

    @Override
    public Map<String, Core.Type_statelistener> vx_mapstatelistener() {
      Map<String, Core.Type_statelistener> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_statelistener(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_statelistenermap output = new Core.Class_statelistenermap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_statelistener> map = new LinkedHashMap<String, Core.Type_statelistener>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_statelistener) {
          Core.Type_statelistener castval = (Core.Type_statelistener)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/statelistenermap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_statelistenermap output = Core.vx_copy(Core.e_statelistenermap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_statelistenermap output = this;
      boolean ischanged = false;
      Core.Class_statelistenermap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_statelistener> mapval = new LinkedHashMap<String, Core.Type_statelistener>(value.vx_mapstatelistener());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/statelistenermap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_statelistener valany = Core.e_statelistener;
          if (false) {
          } else if (valsub instanceof Core.Type_statelistener) {
            Core.Type_statelistener valallowed = (Core.Type_statelistener)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_statelistener) {
            valany = (Core.Type_statelistener)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/statelistenermap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_statelistenermap work = new Core.Class_statelistenermap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_statelistenermap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_statelistenermap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "statelistenermap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_statelistener), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_statelistenermap e_statelistenermap = new Core.Class_statelistenermap();
  public static final Core.Type_statelistenermap t_statelistenermap = new Core.Class_statelistenermap();

  /**
   * type: string
   * A simple string.
   * (type string)
   */
  public interface Type_string extends Core.Type_any {
    public String vx_string();
  }

  public static class Class_string extends Core.Class_base implements Type_string {

    protected String vxstring = "";
    
    @Override
    public String vx_string() {
      return vxstring;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_string output = Core.vx_copy(Core.e_string, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_string output = this;
      boolean ischanged = false;
      Core.Class_string value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      StringBuilder sb = new StringBuilder(value.vx_string());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_string) {
          Core.Type_string valstring = (Core.Type_string)valsub;
          String ssub = valstring.vx_string();
          if (ssub.equals("")) {
          } else {
            ischanged = true;
            sb.append(ssub);
          }
        } else if (valsub instanceof Core.Type_int) {
          Core.Type_int valint = (Core.Type_int)valsub;
          ischanged = true;
          sb.append(valint.vx_int());
        } else if (valsub instanceof Core.Type_float) {
          Core.Type_float valfloat = (Core.Type_float)valsub;
          ischanged = true;
          sb.append(valfloat.vx_float());
        } else if (valsub instanceof Core.Type_decimal) {
          Core.Type_decimal valdecimal = (Core.Type_decimal)valsub;
          ischanged = true;
          sb.append(valdecimal.vx_string());
        } else if (valsub instanceof String) {
          String sval = (String)valsub;
          if (sval.equals("")) {
          } else {
            ischanged = true;
            sb.append(sval);
          }
        } else if (valsub instanceof Integer) {
          Integer ival = (Integer)valsub;
          ischanged = true;
          sb.append(ival);
        } else if (valsub instanceof Float) {
          Float fval = (Float)valsub;
          ischanged = true;
          sb.append(fval);
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anysub = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/string", ":invalidtype", anysub);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/string", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        String vxstring = sb.toString();
        Core.Class_string work = new Core.Class_string();
        work.vxstring = vxstring;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_string;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_string;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "string", // name
        ":string", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_string e_string = new Core.Class_string();
  public static final Core.Type_string t_string = new Core.Class_string();

  /**
   * type: stringlist
   * A list of string.
   * (type stringlist)
   */
  public interface Type_stringlist extends Core.Type_list {
    public List<Core.Type_string> vx_liststring();
    public Core.Type_string vx_string(final Core.Type_int index);
  }

  public static class Class_stringlist extends Core.Class_base implements Type_stringlist {

    public List<Core.Type_string> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_string>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_string vx_string(final Core.Type_int index) {
      Core.Type_string output = Core.e_string;
      Core.Class_stringlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_string> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_string> vx_liststring() {
      List<Core.Type_string> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_string output = this.vx_string(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_stringlist output = Core.vx_copy(Core.e_stringlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_stringlist output = this;
      boolean ischanged = false;
      Core.Class_stringlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_string> listval = new ArrayList<Core.Type_string>(value.vx_liststring());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_stringlist) {
          Core.Type_stringlist multi = (Core.Type_stringlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_liststring());
        } else if (valsub instanceof Core.Type_string) {
          Core.Type_string allowsub = (Core.Type_string)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof String) {
          ischanged = true;
          listval.add(Core.vx_new(Core.t_string, valsub));
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_string) {
              Core.Type_string valitem = (Core.Type_string)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_stringlist work = new Core.Class_stringlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_stringlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_stringlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "stringlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_string), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_stringlist e_stringlist = new Core.Class_stringlist();
  public static final Core.Type_stringlist t_stringlist = new Core.Class_stringlist();

  /**
   * type: stringlistlist
   * A list of stringlist.
   * (type stringlistlist)
   */
  public interface Type_stringlistlist extends Core.Type_list {
    public List<Core.Type_stringlist> vx_liststringlist();
    public Core.Type_stringlist vx_stringlist(final Core.Type_int index);
  }

  public static class Class_stringlistlist extends Core.Class_base implements Type_stringlistlist {

    public List<Core.Type_stringlist> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_stringlist>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_stringlist vx_stringlist(final Core.Type_int index) {
      Core.Type_stringlist output = Core.e_stringlist;
      Core.Class_stringlistlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_stringlist> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_stringlist> vx_liststringlist() {
      List<Core.Type_stringlist> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_stringlist output = this.vx_stringlist(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_stringlistlist output = Core.vx_copy(Core.e_stringlistlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_stringlistlist output = this;
      boolean ischanged = false;
      Core.Class_stringlistlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_stringlist> listval = new ArrayList<Core.Type_stringlist>(value.vx_liststringlist());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_stringlistlist) {
          Core.Type_stringlistlist multi = (Core.Type_stringlistlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_liststringlist());
        } else if (valsub instanceof Core.Type_stringlist) {
          Core.Type_stringlist allowsub = (Core.Type_stringlist)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_stringlist) {
          ischanged = true;
          listval.add((Core.Type_stringlist)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_stringlist) {
              Core.Type_stringlist valitem = (Core.Type_stringlist)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_stringlistlist work = new Core.Class_stringlistlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_stringlistlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_stringlistlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "stringlistlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_stringlist), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_stringlistlist e_stringlistlist = new Core.Class_stringlistlist();
  public static final Core.Type_stringlistlist t_stringlistlist = new Core.Class_stringlistlist();

  /**
   * type: stringmap
   * A map of string.
   * (type stringmap)
   */
  public interface Type_stringmap extends Core.Type_map {
    public Map<String, Core.Type_string> vx_mapstring();
    public Core.Type_string vx_string(final Core.Type_string key);
  }

  public static class Class_stringmap extends Core.Class_base implements Type_stringmap {

    public Map<String, Core.Type_string> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_string>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_string) {
        Core.Type_string castval = (Core.Type_string)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_string> map = new LinkedHashMap<String, Core.Type_string>(this.vx_p_map);
        if (castval == Core.e_string) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_string vx_string(final Core.Type_string key) {
      Core.Type_string output = Core.e_string;
      Core.Class_stringmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_string> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_string);
      return output;
    }

    @Override
    public Map<String, Core.Type_string> vx_mapstring() {
      Map<String, Core.Type_string> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_string(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_stringmap output = new Core.Class_stringmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_string> map = new LinkedHashMap<String, Core.Type_string>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_string) {
          Core.Type_string castval = (Core.Type_string)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/stringmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_stringmap output = Core.vx_copy(Core.e_stringmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_stringmap output = this;
      boolean ischanged = false;
      Core.Class_stringmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_string> mapval = new LinkedHashMap<String, Core.Type_string>(value.vx_mapstring());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/stringmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_string valany = Core.e_string;
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valallowed = (Core.Type_string)valsub;
            valany = valallowed;
          } else if (valsub instanceof String) {
            valany = Core.vx_new(Core.t_string, valsub);
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/stringmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_stringmap work = new Core.Class_stringmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_stringmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_stringmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "stringmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_string), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_stringmap e_stringmap = new Core.Class_stringmap();
  public static final Core.Type_stringmap t_stringmap = new Core.Class_stringmap();

  /**
   * type: stringmutablemap
   * A mutable map of string. Note: Mutables are dangerous.
   * (type stringmutablemap)
   */
  public interface Type_stringmutablemap extends Core.Type_map {
    public Map<String, Core.Type_string> vx_mapstring();
    public Core.Type_string vx_string(final Core.Type_string key);
  }

  public static class Class_stringmutablemap extends Core.Class_base implements Type_stringmutablemap {

    public Map<String, Core.Type_string> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_string>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_string) {
        Core.Type_string castval = (Core.Type_string)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_string> map = new LinkedHashMap<String, Core.Type_string>(this.vx_p_map);
        if (castval == Core.e_string) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_string vx_string(final Core.Type_string key) {
      Core.Type_string output = Core.e_string;
      Core.Class_stringmutablemap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_string> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_string);
      return output;
    }

    @Override
    public Map<String, Core.Type_string> vx_mapstring() {
      Map<String, Core.Type_string> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_string(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_stringmutablemap output = new Core.Class_stringmutablemap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_string> map = new LinkedHashMap<String, Core.Type_string>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_string) {
          Core.Type_string castval = (Core.Type_string)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_stringmutablemap output = Core.vx_copy(Core.e_stringmutablemap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_stringmutablemap output = this;
      boolean ischanged = false;
      Core.Class_stringmutablemap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_string> mapval = new LinkedHashMap<String, Core.Type_string>(value.vx_mapstring());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/stringmutablemap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_string valany = Core.e_string;
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valallowed = (Core.Type_string)valsub;
            valany = valallowed;
          } else if (valsub instanceof String) {
            valany = Core.vx_new(Core.t_string, valsub);
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_stringmutablemap work = new Core.Class_stringmutablemap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_stringmutablemap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_stringmutablemap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "stringmutablemap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_string), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_stringmutablemap e_stringmutablemap = new Core.Class_stringmutablemap();
  public static final Core.Type_stringmutablemap t_stringmutablemap = new Core.Class_stringmutablemap();

  /**
   * type: struct
   * Struct is the type of all structures/objects with properties.
   * (type struct)
   */
  public interface Type_struct extends Core.Type_any {
    public Core.Type_any vx_any(final Core.Type_string key);
    public Map<String, Core.Type_any> vx_map();
  }

  public static class Class_struct extends Core.Class_base implements Type_struct {

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_struct output = Core.vx_copy(Core.e_struct, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_struct output = this;
      boolean ischanged = false;
      Core.Class_struct value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_struct work = new Core.Class_struct();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_struct;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_struct;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "struct", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_struct e_struct = new Core.Class_struct();
  public static final Core.Type_struct t_struct = new Core.Class_struct();

  /**
   * type: thenelse
   * (type thenelse)
   */
  public interface Type_thenelse extends Core.Type_struct {
    public Core.Type_string code();
    public Core.Type_any value();
    public Core.Type_list values();
    public Core.Func_boolean_from_func fn_cond();
    public Core.Func_any_from_func fn_any();
  }

  public static class Class_thenelse extends Core.Class_base implements Type_thenelse {

    public Core.Type_string vx_p_code = null;

    @Override
    public Core.Type_string code() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_code;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_any vx_p_value = null;

    @Override
    public Core.Type_any value() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_value;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_list vx_p_values = null;

    @Override
    public Core.Type_list values() {
      Core.Type_list output = Core.e_list;
      Core.Type_list testnull = vx_p_values;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Func_boolean_from_func vx_p_fn_cond = null;

    @Override
    public Core.Func_boolean_from_func fn_cond() {
      Core.Func_boolean_from_func output = Core.e_boolean_from_func;
      Core.Func_boolean_from_func testnull = vx_p_fn_cond;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Func_any_from_func vx_p_fn_any = null;

    @Override
    public Core.Func_any_from_func fn_any() {
      Core.Func_any_from_func output = Core.e_any_from_func;
      Core.Func_any_from_func testnull = vx_p_fn_any;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":code"))) {
        output = this.code();
      } else if ((skey.equals(":value"))) {
        output = this.value();
      } else if ((skey.equals(":values"))) {
        output = this.values();
      } else if ((skey.equals(":fn-cond"))) {
        output = this.fn_cond();
      } else if ((skey.equals(":fn-any"))) {
        output = this.fn_any();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":code", this.code());
      map.put(":value", this.value());
      map.put(":values", this.values());
      map.put(":fn-cond", this.fn_cond());
      map.put(":fn-any", this.fn_any());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_thenelse output = Core.vx_copy(Core.e_thenelse, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_thenelse output = this;
      boolean ischanged = false;
      Core.Class_thenelse value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_code = value.code();
      Core.Type_any vx_p_value = value.value();
      Core.Type_list vx_p_values = value.values();
      Core.Func_boolean_from_func vx_p_fn_cond = value.fn_cond();
      Core.Func_any_from_func vx_p_fn_any = value.fn_any();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":code");
      validkeys.add(":value");
      validkeys.add(":values");
      validkeys.add(":fn-cond");
      validkeys.add(":fn-any");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":code"))) {
            if (valsub == vx_p_code) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valcode = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_code = valcode;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_code = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("code"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":value"))) {
            if (valsub == vx_p_value) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valvalue = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_value = valvalue;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("value"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":values"))) {
            if (valsub == vx_p_values) {
            } else if (valsub instanceof Core.Type_list) {
              Core.Type_list valvalues = (Core.Type_list)valsub;
              ischanged = true;
              vx_p_values = valvalues;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("values"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":fn-cond"))) {
            if (valsub == vx_p_fn_cond) {
            } else if (valsub instanceof Core.Func_boolean_from_func) {
              Core.Func_boolean_from_func valfn_cond = (Core.Func_boolean_from_func)valsub;
              ischanged = true;
              vx_p_fn_cond = valfn_cond;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("fn-cond"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":fn-any"))) {
            if (valsub == vx_p_fn_any) {
            } else if (valsub instanceof Core.Func_any_from_func) {
              Core.Func_any_from_func valfn_any = (Core.Func_any_from_func)valsub;
              ischanged = true;
              vx_p_fn_any = valfn_any;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("fn-any"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_thenelse work = new Core.Class_thenelse();
        work.vx_p_code = vx_p_code;
        work.vx_p_value = vx_p_value;
        work.vx_p_values = vx_p_values;
        work.vx_p_fn_cond = vx_p_fn_cond;
        work.vx_p_fn_any = vx_p_fn_any;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_thenelse;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_thenelse;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "thenelse", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_thenelse e_thenelse = new Core.Class_thenelse();
  public static final Core.Type_thenelse t_thenelse = new Core.Class_thenelse();

  /**
   * type: thenelselist
   * (type thenelselist)
   */
  public interface Type_thenelselist extends Core.Type_list {
    public List<Core.Type_thenelse> vx_listthenelse();
    public Core.Type_thenelse vx_thenelse(final Core.Type_int index);
  }

  public static class Class_thenelselist extends Core.Class_base implements Type_thenelselist {

    public List<Core.Type_thenelse> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_thenelse>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_thenelse vx_thenelse(final Core.Type_int index) {
      Core.Type_thenelse output = Core.e_thenelse;
      Core.Class_thenelselist list = this;
      int iindex = index.vx_int();
      List<Core.Type_thenelse> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_thenelse> vx_listthenelse() {
      List<Core.Type_thenelse> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_thenelse output = this.vx_thenelse(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_thenelselist output = Core.vx_copy(Core.e_thenelselist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_thenelselist output = this;
      boolean ischanged = false;
      Core.Class_thenelselist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_thenelse> listval = new ArrayList<Core.Type_thenelse>(value.vx_listthenelse());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_thenelselist) {
          Core.Type_thenelselist multi = (Core.Type_thenelselist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listthenelse());
        } else if (valsub instanceof Core.Type_thenelse) {
          Core.Type_thenelse allowsub = (Core.Type_thenelse)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_thenelse) {
          ischanged = true;
          listval.add((Core.Type_thenelse)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_thenelse) {
              Core.Type_thenelse valitem = (Core.Type_thenelse)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_thenelselist work = new Core.Class_thenelselist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_thenelselist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_thenelselist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "thenelselist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_thenelse), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_thenelselist e_thenelselist = new Core.Class_thenelselist();
  public static final Core.Type_thenelselist t_thenelselist = new Core.Class_thenelselist();

  /**
   * type: translation
   * i18 language translation.
   * (type translation)
   */
  public interface Type_translation extends Core.Type_struct {
    public Core.Type_string name();
    public Core.Type_stringmap wordmap();
  }

  public static class Class_translation extends Core.Class_base implements Type_translation {

    public Core.Type_string vx_p_name = null;

    @Override
    public Core.Type_string name() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_stringmap vx_p_wordmap = null;

    @Override
    public Core.Type_stringmap wordmap() {
      Core.Type_stringmap output = Core.e_stringmap;
      Core.Type_stringmap testnull = vx_p_wordmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":name"))) {
        output = this.name();
      } else if ((skey.equals(":wordmap"))) {
        output = this.wordmap();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":name", this.name());
      map.put(":wordmap", this.wordmap());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_translation output = Core.vx_copy(Core.e_translation, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_translation output = this;
      boolean ischanged = false;
      Core.Class_translation value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_name = value.name();
      Core.Type_stringmap vx_p_wordmap = value.wordmap();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":name");
      validkeys.add(":wordmap");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/translation", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":name"))) {
            if (valsub == vx_p_name) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_name = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":wordmap"))) {
            if (valsub == vx_p_wordmap) {
            } else if (valsub instanceof Core.Type_stringmap) {
              Core.Type_stringmap valwordmap = (Core.Type_stringmap)valsub;
              ischanged = true;
              vx_p_wordmap = valwordmap;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("wordmap"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_translation work = new Core.Class_translation();
        work.vx_p_name = vx_p_name;
        work.vx_p_wordmap = vx_p_wordmap;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_translation;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_translation;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "translation", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_translation e_translation = new Core.Class_translation();
  public static final Core.Type_translation t_translation = new Core.Class_translation();

  /**
   * type: translationlist
   * i18 language translation list.
   * (type translationlist)
   */
  public interface Type_translationlist extends Core.Type_list {
    public List<Core.Type_translation> vx_listtranslation();
    public Core.Type_translation vx_translation(final Core.Type_int index);
  }

  public static class Class_translationlist extends Core.Class_base implements Type_translationlist {

    public List<Core.Type_translation> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_translation>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_translation vx_translation(final Core.Type_int index) {
      Core.Type_translation output = Core.e_translation;
      Core.Class_translationlist list = this;
      int iindex = index.vx_int();
      List<Core.Type_translation> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public List<Core.Type_translation> vx_listtranslation() {
      List<Core.Type_translation> output = this.vx_p_list;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_translation output = this.vx_translation(index);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_translationlist output = Core.vx_copy(Core.e_translationlist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_translationlist output = this;
      boolean ischanged = false;
      Core.Class_translationlist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_translation> listval = new ArrayList<Core.Type_translation>(value.vx_listtranslation());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_translationlist) {
          Core.Type_translationlist multi = (Core.Type_translationlist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_listtranslation());
        } else if (valsub instanceof Core.Type_translation) {
          Core.Type_translation allowsub = (Core.Type_translation)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof Core.Type_translation) {
          ischanged = true;
          listval.add((Core.Type_translation)valsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_translation) {
              Core.Type_translation valitem = (Core.Type_translation)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_translationlist work = new Core.Class_translationlist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_translationlist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_translationlist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "translationlist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_translation), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_translationlist e_translationlist = new Core.Class_translationlist();
  public static final Core.Type_translationlist t_translationlist = new Core.Class_translationlist();

  /**
   * type: translationmap
   * i18 language translation map.
   * (type translationmap)
   */
  public interface Type_translationmap extends Core.Type_map {
    public Map<String, Core.Type_translation> vx_maptranslation();
    public Core.Type_translation vx_translation(final Core.Type_string key);
  }

  public static class Class_translationmap extends Core.Class_base implements Type_translationmap {

    public Map<String, Core.Type_translation> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_translation>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_translation) {
        Core.Type_translation castval = (Core.Type_translation)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_translation> map = new LinkedHashMap<String, Core.Type_translation>(this.vx_p_map);
        if (castval == Core.e_translation) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_translation vx_translation(final Core.Type_string key) {
      Core.Type_translation output = Core.e_translation;
      Core.Class_translationmap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_translation> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_translation);
      return output;
    }

    @Override
    public Map<String, Core.Type_translation> vx_maptranslation() {
      Map<String, Core.Type_translation> output = this.vx_p_map;
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = this.vx_translation(key);
      return output;
    }


    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_translationmap output = new Core.Class_translationmap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_translation> map = new LinkedHashMap<String, Core.Type_translation>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_translation) {
          Core.Type_translation castval = (Core.Type_translation)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/translationmap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_translationmap output = Core.vx_copy(Core.e_translationmap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_translationmap output = this;
      boolean ischanged = false;
      Core.Class_translationmap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_translation> mapval = new LinkedHashMap<String, Core.Type_translation>(value.vx_maptranslation());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/translationmap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_translation valany = Core.e_translation;
          if (false) {
          } else if (valsub instanceof Core.Type_translation) {
            Core.Type_translation valallowed = (Core.Type_translation)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_translation) {
            valany = (Core.Type_translation)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/translationmap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_translationmap work = new Core.Class_translationmap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_translationmap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_translationmap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "translationmap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_translation), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_translationmap e_translationmap = new Core.Class_translationmap();
  public static final Core.Type_translationmap t_translationmap = new Core.Class_translationmap();

  /**
   * type: type
   * Original Type Class
   * (type type)
   */
  public interface Type_type extends Core.Type_any {
  }

  public static class Class_type extends Core.Class_base implements Type_type {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_type output = Core.vx_copy(Core.e_type, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_type output = this;
      boolean ischanged = false;
      Core.Class_type value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_type work = new Core.Class_type();
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_type;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_type;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "type", // name
        ":type", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_type e_type = new Core.Class_type();
  public static final Core.Type_type t_type = new Core.Class_type();

  /**
   * type: typedef
   * Type Definition Class for inspecting Type properties.
   * (type typedef)
   */
  public interface Type_typedef extends Core.Type_struct {
    public Core.Type_string pkgname();
    public Core.Type_string name();
    public Core.Type_string extend();
    public Core.Type_funclist allowfuncs();
    public Core.Type_typelist allowtypes();
    public Core.Type_anylist allowvalues();
    public Core.Type_funclist disallowfuncs();
    public Core.Type_typelist disallowtypes();
    public Core.Type_anylist disallowvalues();
    public Core.Type_argmap properties();
    public Core.Type_arg proplast();
    public Core.Type_typelist traits();
  }

  public static class Class_typedef extends Core.Class_base implements Type_typedef {

    public Core.Type_string vx_p_pkgname = null;

    @Override
    public Core.Type_string pkgname() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_name = null;

    @Override
    public Core.Type_string name() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_extend = null;

    @Override
    public Core.Type_string extend() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_extend;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_funclist vx_p_allowfuncs = null;

    @Override
    public Core.Type_funclist allowfuncs() {
      Core.Type_funclist output = Core.e_funclist;
      Core.Type_funclist testnull = vx_p_allowfuncs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_typelist vx_p_allowtypes = null;

    @Override
    public Core.Type_typelist allowtypes() {
      Core.Type_typelist output = Core.e_typelist;
      Core.Type_typelist testnull = vx_p_allowtypes;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_anylist vx_p_allowvalues = null;

    @Override
    public Core.Type_anylist allowvalues() {
      Core.Type_anylist output = Core.e_anylist;
      Core.Type_anylist testnull = vx_p_allowvalues;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_funclist vx_p_disallowfuncs = null;

    @Override
    public Core.Type_funclist disallowfuncs() {
      Core.Type_funclist output = Core.e_funclist;
      Core.Type_funclist testnull = vx_p_disallowfuncs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_typelist vx_p_disallowtypes = null;

    @Override
    public Core.Type_typelist disallowtypes() {
      Core.Type_typelist output = Core.e_typelist;
      Core.Type_typelist testnull = vx_p_disallowtypes;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_anylist vx_p_disallowvalues = null;

    @Override
    public Core.Type_anylist disallowvalues() {
      Core.Type_anylist output = Core.e_anylist;
      Core.Type_anylist testnull = vx_p_disallowvalues;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_argmap vx_p_properties = null;

    @Override
    public Core.Type_argmap properties() {
      Core.Type_argmap output = Core.e_argmap;
      Core.Type_argmap testnull = vx_p_properties;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_arg vx_p_proplast = null;

    @Override
    public Core.Type_arg proplast() {
      Core.Type_arg output = Core.e_arg;
      Core.Type_arg testnull = vx_p_proplast;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_typelist vx_p_traits = null;

    @Override
    public Core.Type_typelist traits() {
      Core.Type_typelist output = Core.e_typelist;
      Core.Type_typelist testnull = vx_p_traits;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":pkgname"))) {
        output = this.pkgname();
      } else if ((skey.equals(":name"))) {
        output = this.name();
      } else if ((skey.equals(":extends"))) {
        output = this.extend();
      } else if ((skey.equals(":allowfuncs"))) {
        output = this.allowfuncs();
      } else if ((skey.equals(":allowtypes"))) {
        output = this.allowtypes();
      } else if ((skey.equals(":allowvalues"))) {
        output = this.allowvalues();
      } else if ((skey.equals(":disallowfuncs"))) {
        output = this.disallowfuncs();
      } else if ((skey.equals(":disallowtypes"))) {
        output = this.disallowtypes();
      } else if ((skey.equals(":disallowvalues"))) {
        output = this.disallowvalues();
      } else if ((skey.equals(":properties"))) {
        output = this.properties();
      } else if ((skey.equals(":proplast"))) {
        output = this.proplast();
      } else if ((skey.equals(":traits"))) {
        output = this.traits();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":name", this.name());
      map.put(":extends", this.extend());
      map.put(":allowfuncs", this.allowfuncs());
      map.put(":allowtypes", this.allowtypes());
      map.put(":allowvalues", this.allowvalues());
      map.put(":disallowfuncs", this.disallowfuncs());
      map.put(":disallowtypes", this.disallowtypes());
      map.put(":disallowvalues", this.disallowvalues());
      map.put(":properties", this.properties());
      map.put(":proplast", this.proplast());
      map.put(":traits", this.traits());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_typedef output = Core.vx_copy(Core.e_typedef, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_typedef output = this;
      boolean ischanged = false;
      Core.Class_typedef value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_string vx_p_pkgname = value.pkgname();
      Core.Type_string vx_p_name = value.name();
      Core.Type_string vx_p_extend = value.extend();
      Core.Type_funclist vx_p_allowfuncs = value.allowfuncs();
      Core.Type_typelist vx_p_allowtypes = value.allowtypes();
      Core.Type_anylist vx_p_allowvalues = value.allowvalues();
      Core.Type_funclist vx_p_disallowfuncs = value.disallowfuncs();
      Core.Type_typelist vx_p_disallowtypes = value.disallowtypes();
      Core.Type_anylist vx_p_disallowvalues = value.disallowvalues();
      Core.Type_argmap vx_p_properties = value.properties();
      Core.Type_arg vx_p_proplast = value.proplast();
      Core.Type_typelist vx_p_traits = value.traits();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":pkgname");
      validkeys.add(":name");
      validkeys.add(":extends");
      validkeys.add(":allowfuncs");
      validkeys.add(":allowtypes");
      validkeys.add(":allowvalues");
      validkeys.add(":disallowfuncs");
      validkeys.add(":disallowtypes");
      validkeys.add(":disallowvalues");
      validkeys.add(":properties");
      validkeys.add(":proplast");
      validkeys.add(":traits");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":pkgname"))) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valpkgname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_pkgname = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":name"))) {
            if (valsub == vx_p_name) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valname = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_name = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":extends"))) {
            if (valsub == vx_p_extend) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valextend = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_extend = valextend;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_extend = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("extends"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":allowfuncs"))) {
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub instanceof Core.Type_funclist) {
              Core.Type_funclist valallowfuncs = (Core.Type_funclist)valsub;
              ischanged = true;
              vx_p_allowfuncs = valallowfuncs;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("allowfuncs"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":allowtypes"))) {
            if (valsub == vx_p_allowtypes) {
            } else if (valsub instanceof Core.Type_typelist) {
              Core.Type_typelist valallowtypes = (Core.Type_typelist)valsub;
              ischanged = true;
              vx_p_allowtypes = valallowtypes;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("allowtypes"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":allowvalues"))) {
            if (valsub == vx_p_allowvalues) {
            } else if (valsub instanceof Core.Type_anylist) {
              Core.Type_anylist valallowvalues = (Core.Type_anylist)valsub;
              ischanged = true;
              vx_p_allowvalues = valallowvalues;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("allowvalues"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":disallowfuncs"))) {
            if (valsub == vx_p_disallowfuncs) {
            } else if (valsub instanceof Core.Type_funclist) {
              Core.Type_funclist valdisallowfuncs = (Core.Type_funclist)valsub;
              ischanged = true;
              vx_p_disallowfuncs = valdisallowfuncs;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("disallowfuncs"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":disallowtypes"))) {
            if (valsub == vx_p_disallowtypes) {
            } else if (valsub instanceof Core.Type_typelist) {
              Core.Type_typelist valdisallowtypes = (Core.Type_typelist)valsub;
              ischanged = true;
              vx_p_disallowtypes = valdisallowtypes;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("disallowtypes"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":disallowvalues"))) {
            if (valsub == vx_p_disallowvalues) {
            } else if (valsub instanceof Core.Type_anylist) {
              Core.Type_anylist valdisallowvalues = (Core.Type_anylist)valsub;
              ischanged = true;
              vx_p_disallowvalues = valdisallowvalues;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("disallowvalues"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":properties"))) {
            if (valsub == vx_p_properties) {
            } else if (valsub instanceof Core.Type_argmap) {
              Core.Type_argmap valproperties = (Core.Type_argmap)valsub;
              ischanged = true;
              vx_p_properties = valproperties;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("properties"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":proplast"))) {
            if (valsub == vx_p_proplast) {
            } else if (valsub instanceof Core.Type_arg) {
              Core.Type_arg valproplast = (Core.Type_arg)valsub;
              ischanged = true;
              vx_p_proplast = valproplast;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("proplast"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":traits"))) {
            if (valsub == vx_p_traits) {
            } else if (valsub instanceof Core.Type_typelist) {
              Core.Type_typelist valtraits = (Core.Type_typelist)valsub;
              ischanged = true;
              vx_p_traits = valtraits;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("traits"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_typedef work = new Core.Class_typedef();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_name = vx_p_name;
        work.vx_p_extend = vx_p_extend;
        work.vx_p_allowfuncs = vx_p_allowfuncs;
        work.vx_p_allowtypes = vx_p_allowtypes;
        work.vx_p_allowvalues = vx_p_allowvalues;
        work.vx_p_disallowfuncs = vx_p_disallowfuncs;
        work.vx_p_disallowtypes = vx_p_disallowtypes;
        work.vx_p_disallowvalues = vx_p_disallowvalues;
        work.vx_p_properties = vx_p_properties;
        work.vx_p_proplast = vx_p_proplast;
        work.vx_p_traits = vx_p_traits;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typedef;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "typedef", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_typedef e_typedef = new Core.Class_typedef();
  public static final Core.Type_typedef t_typedef = new Core.Class_typedef();

  /**
   * type: typelist
   * List of Types
   * (type typelist)
   */
  public interface Type_typelist extends Core.Type_list {
  }

  public static class Class_typelist extends Core.Class_base implements Type_typelist {

    public List<Core.Type_any> vx_p_list = Core.immutablelist(
      new ArrayList<Core.Type_any>()
    );

    @Override
    public List<Core.Type_any> vx_list() {
      List<Core.Type_any> output = Core.immutablelist(
        new ArrayList<Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_int index) {
      Core.Type_any output = Core.e_any;
      Core.Class_typelist list = this;
      int iindex = index.vx_int();
      List<Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.size()) {
        output = listval.get(iindex);
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_typelist output = Core.vx_copy(Core.e_typelist, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_typelist output = this;
      boolean ischanged = false;
      Core.Class_typelist value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      List<Core.Type_any> listval = new ArrayList<Core.Type_any>(value.vx_list());
      Core.Type_msg msg;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_typelist) {
          Core.Type_typelist multi = (Core.Type_typelist)valsub;
          ischanged = true;
          listval.addAll(multi.vx_list());
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any allowsub = (Core.Type_any)valsub;
          ischanged = true;
          listval.add(allowsub);
        } else if (valsub instanceof List<?>) {
          List<?> listunknown = (List<?>)valsub;
          for (Object item : listunknown) {
            if (false) {
            } else if (item instanceof Core.Type_any) {
              Core.Type_any valitem = (Core.Type_any)item;
              ischanged = true;
              listval.add(valitem);
            }
          }
        } else if (valsub instanceof Core.Type_any) {
          Core.Type_any anyinvalid = (Core.Type_any)valsub;
          msg = Core.vx_msg_from_error("vx/core/typelist", ":invalidtype", anyinvalid);
          msgblock = Core.vx_copy(msgblock, msg);
        } else {
          msg = Core.vx_msg_from_error("vx/core/typelist", ":invalidtype", Core.vx_new_string(valsub.toString()));
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_typelist work = new Core.Class_typelist();
        work.vx_p_list = Core.immutablelist(listval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typelist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typelist;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "typelist", // name
        ":list", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_typelist e_typelist = new Core.Class_typelist();
  public static final Core.Type_typelist t_typelist = new Core.Class_typelist();

  /**
   * type: typemap
   * Map of Any Type Class
   * (type typemap)
   */
  public interface Type_typemap extends Core.Type_map {
  }

  public static class Class_typemap extends Core.Class_base implements Type_typemap {

    public Map<String, Core.Type_any> vx_p_map = Core.immutablemap(new LinkedHashMap<String, Core.Type_any>());

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
      return Core.immutablemap(map);
    }

    @Override
    public Core.Type_boolean vx_set(final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      if (false) {
      } else if (value instanceof Core.Type_any) {
        Core.Type_any castval = (Core.Type_any)value;
        String key = name.vx_string();
        if (key.startsWith(":")) {
          key = key.substring(1);
        }
        Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>(this.vx_p_map);
        if (castval == Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Core.immutablemap(map);
        output = Core.c_true;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      Core.Class_typemap map = this;
      String skey = key.vx_string();
      Map<String, Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrDefault(skey, Core.e_any);
      return output;
    }

    @Override
    public Core.Type_map vx_new_from_map(final Map<String, Core.Type_any> mapval) {
      Core.Class_typemap output = new Core.Class_typemap();
      Core.Type_msgblock msgblock = Core.e_msgblock;
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value instanceof Core.Type_any) {
          Core.Type_any castval = (Core.Type_any)value;
          map.put(key, castval);
        } else {
          Core.Type_msg msg = Core.vx_msg_from_error("vx/core/typemap", ":invalidvalue", value);
          msgblock = Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Core.immutablemap(map);
      if (msgblock != Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_typemap output = Core.vx_copy(Core.e_typemap, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_typemap output = this;
      boolean ischanged = false;
      Core.Class_typemap value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Map<String, Core.Type_any> mapval = new LinkedHashMap<String, Core.Type_any>(value.vx_map());
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstring = (Core.Type_string)valsub;
            key = valstring.vx_string();
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            key = sval;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/typemap", ":keyexpected", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
        } else {
          Core.Type_any valany = Core.e_any;
          if (false) {
          } else if (valsub instanceof Core.Type_any) {
            Core.Type_any valallowed = (Core.Type_any)valsub;
            valany = valallowed;
          } else if (valsub instanceof Core.Type_any) {
            valany = (Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valinvalid = (Core.Type_any)valsub;
              msgval = valinvalid;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
            mapany.put("key", Core.vx_new_string(key));
            mapany.put("value", msgval);
            Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
            msg = Core.vx_msg_from_error("vx/core/typemap", ":invalidkeyvalue", msgmap);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (valany != Core.e_any) {
            ischanged = true;
            if (key.startsWith(":")) {
              key = key.substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_typemap work = new Core.Class_typemap();
        work.vx_p_map = Core.immutablemap(mapval);
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typemap;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typemap;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "typemap", // name
        ":map", // extends
        Core.e_typelist, // traits
        Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_typemap e_typemap = new Core.Class_typemap();
  public static final Core.Type_typemap t_typemap = new Core.Class_typemap();

  /**
   * type: user
   * User Type
   * (type user)
   */
  public interface Type_user extends Core.Type_struct {
    public Core.Type_security security();
    public Core.Type_string username();
    public Core.Type_string token();
  }

  public static class Class_user extends Core.Class_base implements Type_user {

    public Core.Type_security vx_p_security = null;

    @Override
    public Core.Type_security security() {
      Core.Type_security output = Core.e_security;
      Core.Type_security testnull = vx_p_security;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_username = null;

    @Override
    public Core.Type_string username() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_username;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_string vx_p_token = null;

    @Override
    public Core.Type_string token() {
      Core.Type_string output = Core.e_string;
      Core.Type_string testnull = vx_p_token;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":security"))) {
        output = this.security();
      } else if ((skey.equals(":username"))) {
        output = this.username();
      } else if ((skey.equals(":token"))) {
        output = this.token();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":security", this.security());
      map.put(":username", this.username());
      map.put(":token", this.token());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_user output = Core.vx_copy(Core.e_user, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_user output = this;
      boolean ischanged = false;
      Core.Class_user value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_security vx_p_security = value.security();
      Core.Type_string vx_p_username = value.username();
      Core.Type_string vx_p_token = value.token();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":security");
      validkeys.add(":username");
      validkeys.add(":token");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/user", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":security"))) {
            if (valsub == vx_p_security) {
            } else if (valsub instanceof Core.Type_security) {
              Core.Type_security valsecurity = (Core.Type_security)valsub;
              ischanged = true;
              vx_p_security = valsecurity;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("security"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":username"))) {
            if (valsub == vx_p_username) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valusername = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_username = valusername;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_username = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("username"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":token"))) {
            if (valsub == vx_p_token) {
            } else if (valsub instanceof Core.Type_string) {
              Core.Type_string valtoken = (Core.Type_string)valsub;
              ischanged = true;
              vx_p_token = valtoken;
            } else if (valsub instanceof String) {
              ischanged = true;
              vx_p_token = Core.vx_new(Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("token"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_user work = new Core.Class_user();
        work.vx_p_security = vx_p_security;
        work.vx_p_username = vx_p_username;
        work.vx_p_token = vx_p_token;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_user;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_user;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "user", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_user e_user = new Core.Class_user();
  public static final Core.Type_user t_user = new Core.Class_user();

  /**
   * type: value
   * (type value)
   */
  public interface Type_value extends Core.Type_struct {
    public Core.Type_any next();
    public Core.Type_int refs();
  }

  public static class Class_value extends Core.Class_base implements Type_value {

    public Core.Type_any vx_p_next = null;

    @Override
    public Core.Type_any next() {
      Core.Type_any output = Core.e_any;
      Core.Type_any testnull = vx_p_next;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Core.Type_int vx_p_refs = null;

    @Override
    public Core.Type_int refs() {
      Core.Type_int output = Core.e_int;
      Core.Type_int testnull = vx_p_refs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_any(final Core.Type_string key) {
      Core.Type_any output = Core.e_any;
      String skey = key.vx_string();
      if (false) {
      } else if ((skey.equals(":next"))) {
        output = this.next();
      } else if ((skey.equals(":refs"))) {
        output = this.refs();
      }
      return output;
    }

    @Override
    public Map<String, Core.Type_any> vx_map() {
      Map<String, Core.Type_any> map = new LinkedHashMap<String, Core.Type_any>();
      map.put(":next", this.next());
      map.put(":refs", this.refs());
      Map<String, Core.Type_any> output = Core.immutablemap(map);
      return output;
    }

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Type_value output = Core.vx_copy(Core.e_value, vals);
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Type_value output = this;
      boolean ischanged = false;
      Core.Class_value value = this;
      Core.Type_msgblock msgblock = Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Core.e_constdef) {
        ischanged = true;
      }
      Core.Type_any vx_p_next = value.next();
      Core.Type_int vx_p_refs = value.refs();
      List<String> validkeys = new ArrayList<String>();
      validkeys.add(":next");
      validkeys.add(":refs");
      String key = "";
      Core.Type_msg msg = Core.e_msg;
      Core.Type_any msgval = Core.e_any;
      for (Object valsub : vals) {
        if (valsub instanceof Core.Type_msgblock) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (valsub instanceof Core.Type_msg) {
          msgblock = Core.vx_copy(msgblock, valsub);
        } else if (key.equals("")) {
          boolean istestkey = false;
          String testkey = "";
          if (false) {
          } else if (valsub instanceof Core.Type_string) {
            Core.Type_string valstr = (Core.Type_string)valsub;
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub instanceof String) {
            String sval = (String)valsub;
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valmsg = (Core.Type_any)valsub;
              msgval = valmsg;
            } else {
              msgval = Core.vx_new_string(valsub.toString());
            }
            msg = Core.vx_msg_from_error("vx/core/value", ":invalidkeytype", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey;
            }
            boolean isvalidkey = validkeys.contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Core.vx_new_string(testkey);
              msg = Core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key.equals(":next"))) {
            if (valsub == vx_p_next) {
            } else if (valsub instanceof Core.Type_any) {
              Core.Type_any valnext = (Core.Type_any)valsub;
              ischanged = true;
              vx_p_next = valnext;
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("next"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else if ((key.equals(":refs"))) {
            if (valsub == vx_p_refs) {
            } else if (valsub instanceof Core.Type_int) {
              Core.Type_int valrefs = (Core.Type_int)valsub;
              ischanged = true;
              vx_p_refs = valrefs;
            } else if (valsub instanceof Integer) {
              ischanged = true;
              vx_p_refs = Core.vx_new(Core.t_int, valsub);
            } else {
              if (false) {
              } else if (valsub instanceof Core.Type_any) {
                Core.Type_any valinvalid = (Core.Type_any)valsub;
                msgval = valinvalid;
              } else {
                msgval = Core.vx_new_string(valsub.toString());
              }
              Map<String, Core.Type_any> mapany = new LinkedHashMap<String, Core.Type_any>();
              mapany.put("key", Core.vx_new_string("refs"));
              mapany.put("value", msgval);
              Core.Type_map msgmap = Core.t_anymap.vx_new_from_map(mapany);
              msg = Core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap);
              msgblock = Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Core.vx_new_string(key);
            msg = Core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval);
            msgblock = Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Core.e_msgblock)) {
        Core.Class_value work = new Core.Class_value();
        work.vx_p_next = vx_p_next;
        work.vx_p_refs = vx_p_refs;
        if (msgblock != Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_value;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_value;
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.typedef_new(
        "vx/core", // pkgname
        "value", // name
        ":struct", // extends
        Core.e_typelist, // traits
        Core.e_typelist, // allowtypes
        Core.e_typelist, // disallowtypes
        Core.e_funclist, // allowfuncs
        Core.e_funclist, // disallowfuncs
        Core.e_anylist, // allowvalues
        Core.e_anylist, // disallowvalues
        Core.e_argmap // properties
      );
      return output;
    }

  }

  public static final Core.Type_value e_value = new Core.Class_value();
  public static final Core.Type_value t_value = new Core.Class_value();

  /**
   * Constant: false
   * {boolean}
   */
  public static class Const_false {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "false", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_boolean output) {
      Core.Class_boolean outval = (Core.Class_boolean)output;
      outval.vx_p_constdef = constdef();
      outval.vxboolean = false;
    }

  }

  public static final Core.Type_boolean c_false = new Core.Class_boolean();

  public static final Core.Type_boolean e_boolean = Core.c_false;

  /**
   * Constant: global
   * Global variable for project data.
   * {project}
   */
  public static class Const_global {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "global", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "project", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_project output) {
      Core.Class_project outval = (Core.Class_project)output;
      outval.vx_p_constdef = constdef();
    }

  }

  public static final Core.Type_project c_global = new Core.Class_project();


  /**
   * Constant: infinity
   * Infinity. Returned during unusual calculations.
   * {int}
   */
  public static class Const_infinity {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "infinity", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static final Core.Type_int c_infinity = new Core.Class_int();


  /**
   * Constant: mempool-active
   * Active Value Memory Pool
   * {mempool}
   */
  public static class Const_mempool_active {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "mempool-active", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "mempool", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_mempool output) {
      Core.Class_mempool outval = (Core.Class_mempool)output;
      outval.vx_p_constdef = constdef();
    }

  }

  public static final Core.Type_mempool c_mempool_active = new Core.Class_mempool();


  /**
   * Constant: msg-error
   * Message is an Error
   * {int}
   */
  public static class Const_msg_error {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "msg-error", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 2;
    }

  }

  public static final Core.Type_int c_msg_error = new Core.Class_int();


  /**
   * Constant: msg-info
   * Message is just information
   * {int}
   */
  public static class Const_msg_info {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "msg-info", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static final Core.Type_int c_msg_info = new Core.Class_int();


  /**
   * Constant: msg-severe
   * Message is a Severe Error
   * {int}
   */
  public static class Const_msg_severe {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "msg-severe", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 3;
    }

  }

  public static final Core.Type_int c_msg_severe = new Core.Class_int();


  /**
   * Constant: msg-warning
   * Message is a Warning
   * {int}
   */
  public static class Const_msg_warning {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "msg-warning", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 1;
    }

  }

  public static final Core.Type_int c_msg_warning = new Core.Class_int();


  /**
   * Constant: neginfinity
   * Negative Infinity. Returned during unusual calculations.
   * {int}
   */
  public static class Const_neginfinity {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "neginfinity", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static final Core.Type_int c_neginfinity = new Core.Class_int();


  /**
   * Constant: newline
   * New line constant
   * {string}
   */
  public static class Const_newline {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "newline", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_string output) {
      Core.Class_string outval = (Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "\n";
    }

  }

  public static final Core.Type_string c_newline = new Core.Class_string();


  /**
   * Constant: notanumber
   * Not a number. Returned during invalid calculations.
   * {int}
   */
  public static class Const_notanumber {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "notanumber", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_int output) {
      Core.Class_int outval = (Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static final Core.Type_int c_notanumber = new Core.Class_int();


  /**
   * Constant: nothing
   * Nothing Value. Opposite of every other value. e.g. Nil, Null
   * {string}
   */
  public static class Const_nothing {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "nothing", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_string output) {
      Core.Class_string outval = (Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "nothing";
    }

  }

  public static final Core.Type_string c_nothing = new Core.Class_string();


  /**
   * Constant: path-test-resources
   * The test path from project file
   * {string}
   */
  public static class Const_path_test_resources {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "path-test-resources", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_string output) {
      Core.Class_string outval = (Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "src/test/resources";
    }

  }

  public static final Core.Type_string c_path_test_resources = new Core.Class_string();


  /**
   * Constant: quote
   * Quotation mark constant
   * {string}
   */
  public static class Const_quote {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "quote", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_string output) {
      Core.Class_string outval = (Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "\"";
    }

  }

  public static final Core.Type_string c_quote = new Core.Class_string();


  /**
   * Constant: true
   * {boolean}
   */
  public static class Const_true {
    public static Core.Type_constdef constdef() {
      Core.Type_constdef output = Core.constdef_new(
        "vx/core", // pkgname
        "true", // name
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Core.Type_boolean output) {
      Core.Class_boolean outval = (Core.Class_boolean)output;
      outval.vx_p_constdef = constdef();
      outval.vxboolean = true;
    }

  }

  public static final Core.Type_boolean c_true = new Core.Class_boolean();

  /**
   * @function not
   * Boolean not
   * @param  {boolean} value Thing to not
   * @return {boolean}
   * (func !)
   */
  public interface Func_not extends Core.Func_any_from_any {
    public Core.Type_boolean vx_not(final Core.Type_boolean value);
  }

  public static class Class_not extends Core.Class_base implements Func_not {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_not output = new Core.Class_not();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_not output = new Core.Class_not();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "!", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_not;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_not;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_boolean inputval = (Core.Type_boolean)value;
      Core.Type_any outputval = Core.f_not(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_boolean value = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_not(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_not(final Core.Type_boolean value) {
      Core.Type_boolean output = Core.f_not(value);
      return output;
    }

  }

  public static final Core.Func_not e_not = new Core.Class_not();
  public static final Core.Func_not t_not = new Core.Class_not();

  public static Core.Type_boolean f_not(final Core.Type_boolean value) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.vx_new_boolean(!value.vx_boolean());
    return output;
  }

  /**
   * @function notempty
   * Returns true if text is not empty.
   * @param  {string} text
   * @return {boolean}
   * (func !-empty)
   */
  public interface Func_notempty extends Core.Func_any_from_any {
    public Core.Type_boolean vx_notempty(final Core.Type_string text);
  }

  public static class Class_notempty extends Core.Class_base implements Func_notempty {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_notempty output = new Core.Class_notempty();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_notempty output = new Core.Class_notempty();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_notempty;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_notempty;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_notempty(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_notempty(text);
      return output;
    }

    @Override
    public Core.Type_boolean vx_notempty(final Core.Type_string text) {
      Core.Type_boolean output = Core.f_notempty(text);
      return output;
    }

  }

  public static final Core.Func_notempty e_notempty = new Core.Class_notempty();
  public static final Core.Func_notempty t_notempty = new Core.Class_notempty();

  public static Core.Type_boolean f_notempty(final Core.Type_string text) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_is_empty(
        text
      )
    );
    return output;
  }

  /**
   * @function notempty 1
   * Returns true if value is not empty.
   * @param  {any} value
   * @return {boolean}
   * (func !-empty)
   */
  public interface Func_notempty_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_notempty_1(final Core.Type_any value);
  }

  public static class Class_notempty_1 extends Core.Class_base implements Func_notempty_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_notempty_1 output = new Core.Class_notempty_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_notempty_1 output = new Core.Class_notempty_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_notempty_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_notempty_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_notempty_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_notempty_1(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_notempty_1(final Core.Type_any value) {
      Core.Type_boolean output = Core.f_notempty_1(value);
      return output;
    }

  }

  public static final Core.Func_notempty_1 e_notempty_1 = new Core.Class_notempty_1();
  public static final Core.Func_notempty_1 t_notempty_1 = new Core.Class_notempty_1();

  public static Core.Type_boolean f_notempty_1(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_is_empty_1(
        value
      )
    );
    return output;
  }

  /**
   * @function ne
   * Returns true if the first arg is not equal to any of the other arg.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func !=)
   */
  public interface Func_ne extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_ne(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_ne extends Core.Class_base implements Func_ne {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_ne output = new Core.Class_ne();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_ne output = new Core.Class_ne();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "!=", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_ne;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_ne;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_ne(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_ne(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_ne(val1, val2);
      return output;
    }

  }

  public static final Core.Func_ne e_ne = new Core.Class_ne();
  public static final Core.Func_ne t_ne = new Core.Class_ne();

  public static Core.Type_boolean f_ne(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_eq(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function neqeq
   * Returns true if the first arg is not strictly equal to any of the other arg.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func !==)
   */
  public interface Func_neqeq extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_neqeq(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_neqeq extends Core.Class_base implements Func_neqeq {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_neqeq output = new Core.Class_neqeq();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_neqeq output = new Core.Class_neqeq();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "!==", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_neqeq;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_neqeq;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_neqeq(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_neqeq(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_neqeq(val1, val2);
      return output;
    }

  }

  public static final Core.Func_neqeq e_neqeq = new Core.Class_neqeq();
  public static final Core.Func_neqeq t_neqeq = new Core.Class_neqeq();

  public static Core.Type_boolean f_neqeq(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_eqeq(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function multiply
   * Math int multiply
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func *)
   */
  public interface Func_multiply extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_int vx_multiply(final Core.Type_int num1, final Core.Type_int num2);
  }

  public static class Class_multiply extends Core.Class_base implements Func_multiply {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_multiply output = new Core.Class_multiply();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_multiply output = new Core.Class_multiply();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_multiply;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_multiply;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_int num1 = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int num2 = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_multiply(num1, num2);
      return output;
    }

    @Override
    public Core.Type_int vx_multiply(final Core.Type_int num1, final Core.Type_int num2) {
      Core.Type_int output = Core.f_multiply(num1, num2);
      return output;
    }

  }

  public static final Core.Func_multiply e_multiply = new Core.Class_multiply();
  public static final Core.Func_multiply t_multiply = new Core.Class_multiply();

  public static Core.Type_int f_multiply(final Core.Type_int num1, final Core.Type_int num2) {
    Core.Type_int output = Core.e_int;
    int result = num1.vx_int() * num2.vx_int();
    output = Core.vx_new_int(result);
    return output;
  }

  /**
   * @function multiply 1
   * Math multipy
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func *)
   */
  public interface Func_multiply_1 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_number vx_multiply_1(final Core.Type_number num1, final Core.Type_number num2);
  }

  public static class Class_multiply_1 extends Core.Class_base implements Func_multiply_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_multiply_1 output = new Core.Class_multiply_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_multiply_1 output = new Core.Class_multiply_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_multiply_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_multiply_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_number num1 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_number num2 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_multiply_1(num1, num2);
      return output;
    }

    @Override
    public Core.Type_number vx_multiply_1(final Core.Type_number num1, final Core.Type_number num2) {
      Core.Type_number output = Core.f_multiply_1(num1, num2);
      return output;
    }

  }

  public static final Core.Func_multiply_1 e_multiply_1 = new Core.Class_multiply_1();
  public static final Core.Func_multiply_1 t_multiply_1 = new Core.Class_multiply_1();

  public static Core.Type_number f_multiply_1(final Core.Type_number num1, final Core.Type_number num2) {
    Core.Type_number output = Core.e_number;
    float result = Core.vx_float_from_number(num1) * Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);
    return output;
  }

  /**
   * @function multiply 2
   * Math multiply
   * @param  {intlist} nums
   * @return {int}
   * (func *)
   */
  public interface Func_multiply_2 extends Core.Func_any_from_any {
    public Core.Type_int vx_multiply_2(final Core.Type_intlist nums);
  }

  public static class Class_multiply_2 extends Core.Class_base implements Func_multiply_2 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_multiply_2 output = new Core.Class_multiply_2();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_multiply_2 output = new Core.Class_multiply_2();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        2, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_multiply_2;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_multiply_2;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_intlist inputval = (Core.Type_intlist)value;
      Core.Type_any outputval = Core.f_multiply_2(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_intlist nums = Core.f_any_from_any(Core.t_intlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_multiply_2(nums);
      return output;
    }

    @Override
    public Core.Type_int vx_multiply_2(final Core.Type_intlist nums) {
      Core.Type_int output = Core.f_multiply_2(nums);
      return output;
    }

  }

  public static final Core.Func_multiply_2 e_multiply_2 = new Core.Class_multiply_2();
  public static final Core.Func_multiply_2 t_multiply_2 = new Core.Class_multiply_2();

  public static Core.Type_int f_multiply_2(final Core.Type_intlist nums) {
    Core.Type_int output = Core.e_int;
    output = Core.f_any_from_list_start_reduce(
      Core.t_int,
      nums,
      Core.vx_new_int(1),
      Core.t_any_from_reduce.vx_fn_new((total_any, num_any) -> {
        Core.Type_int total = Core.f_any_from_any(Core.t_int, total_any);
        Core.Type_int num = Core.f_any_from_any(Core.t_int, num_any);
        Core.Type_any output_1 = Core.f_multiply(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function multiply 3
   * Math multiply
   * @param  {numberlist} nums
   * @return {number}
   * (func *)
   */
  public interface Func_multiply_3 extends Core.Func_any_from_any {
    public Core.Type_number vx_multiply_3(final Core.Type_numberlist nums);
  }

  public static class Class_multiply_3 extends Core.Class_base implements Func_multiply_3 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_multiply_3 output = new Core.Class_multiply_3();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_multiply_3 output = new Core.Class_multiply_3();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        3, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_multiply_3;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_multiply_3;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_numberlist inputval = (Core.Type_numberlist)value;
      Core.Type_any outputval = Core.f_multiply_3(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_numberlist nums = Core.f_any_from_any(Core.t_numberlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_multiply_3(nums);
      return output;
    }

    @Override
    public Core.Type_number vx_multiply_3(final Core.Type_numberlist nums) {
      Core.Type_number output = Core.f_multiply_3(nums);
      return output;
    }

  }

  public static final Core.Func_multiply_3 e_multiply_3 = new Core.Class_multiply_3();
  public static final Core.Func_multiply_3 t_multiply_3 = new Core.Class_multiply_3();

  public static Core.Type_number f_multiply_3(final Core.Type_numberlist nums) {
    Core.Type_number output = Core.e_number;
    output = Core.f_any_from_list_start_reduce(
      Core.t_number,
      nums,
      Core.vx_new_int(1),
      Core.t_any_from_reduce.vx_fn_new((total_any, num_any) -> {
        Core.Type_number total = Core.f_any_from_any(Core.t_number, total_any);
        Core.Type_number num = Core.f_any_from_any(Core.t_number, num_any);
        Core.Type_any output_1 = Core.f_multiply_1(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function plus
   * Math int plus
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func +)
   */
  public interface Func_plus extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_int vx_plus(final Core.Type_int num1, final Core.Type_int num2);
  }

  public static class Class_plus extends Core.Class_base implements Func_plus {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_plus output = new Core.Class_plus();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_plus output = new Core.Class_plus();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_plus;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_plus;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_int num1 = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int num2 = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_plus(num1, num2);
      return output;
    }

    @Override
    public Core.Type_int vx_plus(final Core.Type_int num1, final Core.Type_int num2) {
      Core.Type_int output = Core.f_plus(num1, num2);
      return output;
    }

  }

  public static final Core.Func_plus e_plus = new Core.Class_plus();
  public static final Core.Func_plus t_plus = new Core.Class_plus();

  public static Core.Type_int f_plus(final Core.Type_int num1, final Core.Type_int num2) {
    Core.Type_int output = Core.e_int;
    int result = num1.vx_int() + num2.vx_int();
    output = Core.vx_new_int(result);
    return output;
  }

  /**
   * @function plus 1
   * Math number plus
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func +)
   */
  public interface Func_plus_1 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_number vx_plus_1(final Core.Type_number num1, final Core.Type_number num2);
  }

  public static class Class_plus_1 extends Core.Class_base implements Func_plus_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_plus_1 output = new Core.Class_plus_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_plus_1 output = new Core.Class_plus_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_plus_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_plus_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_number num1 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_number num2 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_plus_1(num1, num2);
      return output;
    }

    @Override
    public Core.Type_number vx_plus_1(final Core.Type_number num1, final Core.Type_number num2) {
      Core.Type_number output = Core.f_plus_1(num1, num2);
      return output;
    }

  }

  public static final Core.Func_plus_1 e_plus_1 = new Core.Class_plus_1();
  public static final Core.Func_plus_1 t_plus_1 = new Core.Class_plus_1();

  public static Core.Type_number f_plus_1(final Core.Type_number num1, final Core.Type_number num2) {
    Core.Type_number output = Core.e_number;
    float result = Core.vx_float_from_number(num1) + Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);
    return output;
  }

  /**
   * @function plus 2
   * Math int plus
   * @param  {intlist} nums
   * @return {int}
   * (func +)
   */
  public interface Func_plus_2 extends Core.Func_any_from_any {
    public Core.Type_int vx_plus_2(final Core.Type_intlist nums);
  }

  public static class Class_plus_2 extends Core.Class_base implements Func_plus_2 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_plus_2 output = new Core.Class_plus_2();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_plus_2 output = new Core.Class_plus_2();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        2, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_plus_2;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_plus_2;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_intlist inputval = (Core.Type_intlist)value;
      Core.Type_any outputval = Core.f_plus_2(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_intlist nums = Core.f_any_from_any(Core.t_intlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_plus_2(nums);
      return output;
    }

    @Override
    public Core.Type_int vx_plus_2(final Core.Type_intlist nums) {
      Core.Type_int output = Core.f_plus_2(nums);
      return output;
    }

  }

  public static final Core.Func_plus_2 e_plus_2 = new Core.Class_plus_2();
  public static final Core.Func_plus_2 t_plus_2 = new Core.Class_plus_2();

  public static Core.Type_int f_plus_2(final Core.Type_intlist nums) {
    Core.Type_int output = Core.e_int;
    output = Core.f_any_from_list_start_reduce(
      Core.t_int,
      nums,
      Core.vx_new_int(0),
      Core.t_any_from_reduce.vx_fn_new((total_any, num_any) -> {
        Core.Type_int total = Core.f_any_from_any(Core.t_int, total_any);
        Core.Type_int num = Core.f_any_from_any(Core.t_int, num_any);
        Core.Type_any output_1 = Core.f_plus(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function plus 3
   * Math number plus
   * @param  {numberlist} nums
   * @return {number}
   * (func +)
   */
  public interface Func_plus_3 extends Core.Func_any_from_any {
    public Core.Type_number vx_plus_3(final Core.Type_numberlist nums);
  }

  public static class Class_plus_3 extends Core.Class_base implements Func_plus_3 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_plus_3 output = new Core.Class_plus_3();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_plus_3 output = new Core.Class_plus_3();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        3, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_plus_3;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_plus_3;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_numberlist inputval = (Core.Type_numberlist)value;
      Core.Type_any outputval = Core.f_plus_3(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_numberlist nums = Core.f_any_from_any(Core.t_numberlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_plus_3(nums);
      return output;
    }

    @Override
    public Core.Type_number vx_plus_3(final Core.Type_numberlist nums) {
      Core.Type_number output = Core.f_plus_3(nums);
      return output;
    }

  }

  public static final Core.Func_plus_3 e_plus_3 = new Core.Class_plus_3();
  public static final Core.Func_plus_3 t_plus_3 = new Core.Class_plus_3();

  public static Core.Type_number f_plus_3(final Core.Type_numberlist nums) {
    Core.Type_number output = Core.e_number;
    output = Core.f_any_from_list_start_reduce(
      Core.t_number,
      nums,
      Core.vx_new_int(0),
      Core.t_any_from_reduce.vx_fn_new((total_any, num_any) -> {
        Core.Type_number total = Core.f_any_from_any(Core.t_number, total_any);
        Core.Type_number num = Core.f_any_from_any(Core.t_number, num_any);
        Core.Type_any output_1 = Core.f_plus_1(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function plus1
   * Math int plus 1
   * @param  {int} num
   * @return {int}
   * (func +1)
   */
  public interface Func_plus1 extends Core.Func_any_from_any {
    public Core.Type_int vx_plus1(final Core.Type_int num);
  }

  public static class Class_plus1 extends Core.Class_base implements Func_plus1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_plus1 output = new Core.Class_plus1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_plus1 output = new Core.Class_plus1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "+1", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_plus1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_plus1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_int inputval = (Core.Type_int)value;
      Core.Type_any outputval = Core.f_plus1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_int num = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_plus1(num);
      return output;
    }

    @Override
    public Core.Type_int vx_plus1(final Core.Type_int num) {
      Core.Type_int output = Core.f_plus1(num);
      return output;
    }

  }

  public static final Core.Func_plus1 e_plus1 = new Core.Class_plus1();
  public static final Core.Func_plus1 t_plus1 = new Core.Class_plus1();

  public static Core.Type_int f_plus1(final Core.Type_int num) {
    Core.Type_int output = Core.e_int;
    output = Core.f_plus(
      num,
      Core.vx_new_int(1)
    );
    return output;
  }

  /**
   * @function minus
   * Math int minus
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func -)
   */
  public interface Func_minus extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_int vx_minus(final Core.Type_int num1, final Core.Type_int num2);
  }

  public static class Class_minus extends Core.Class_base implements Func_minus {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_minus output = new Core.Class_minus();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_minus output = new Core.Class_minus();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_minus;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_minus;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_int num1 = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int num2 = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_minus(num1, num2);
      return output;
    }

    @Override
    public Core.Type_int vx_minus(final Core.Type_int num1, final Core.Type_int num2) {
      Core.Type_int output = Core.f_minus(num1, num2);
      return output;
    }

  }

  public static final Core.Func_minus e_minus = new Core.Class_minus();
  public static final Core.Func_minus t_minus = new Core.Class_minus();

  public static Core.Type_int f_minus(final Core.Type_int num1, final Core.Type_int num2) {
    Core.Type_int output = Core.e_int;
    int result = num1.vx_int() - num2.vx_int();
    output = Core.vx_new_int(result);
    return output;
  }

  /**
   * @function minus 1
   * Math number minus
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func -)
   */
  public interface Func_minus_1 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_number vx_minus_1(final Core.Type_number num1, final Core.Type_number num2);
  }

  public static class Class_minus_1 extends Core.Class_base implements Func_minus_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_minus_1 output = new Core.Class_minus_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_minus_1 output = new Core.Class_minus_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_minus_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_minus_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_number num1 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_number num2 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_minus_1(num1, num2);
      return output;
    }

    @Override
    public Core.Type_number vx_minus_1(final Core.Type_number num1, final Core.Type_number num2) {
      Core.Type_number output = Core.f_minus_1(num1, num2);
      return output;
    }

  }

  public static final Core.Func_minus_1 e_minus_1 = new Core.Class_minus_1();
  public static final Core.Func_minus_1 t_minus_1 = new Core.Class_minus_1();

  public static Core.Type_number f_minus_1(final Core.Type_number num1, final Core.Type_number num2) {
    Core.Type_number output = Core.e_number;
    float result = Core.vx_float_from_number(num1) - Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);
    return output;
  }

  /**
   * @function minus 2
   * Math integer minus
   * @param  {intlist} nums
   * @return {int}
   * (func -)
   */
  public interface Func_minus_2 extends Core.Func_any_from_any {
    public Core.Type_int vx_minus_2(final Core.Type_intlist nums);
  }

  public static class Class_minus_2 extends Core.Class_base implements Func_minus_2 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_minus_2 output = new Core.Class_minus_2();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_minus_2 output = new Core.Class_minus_2();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        2, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_minus_2;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_minus_2;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_intlist inputval = (Core.Type_intlist)value;
      Core.Type_any outputval = Core.f_minus_2(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_intlist nums = Core.f_any_from_any(Core.t_intlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_minus_2(nums);
      return output;
    }

    @Override
    public Core.Type_int vx_minus_2(final Core.Type_intlist nums) {
      Core.Type_int output = Core.f_minus_2(nums);
      return output;
    }

  }

  public static final Core.Func_minus_2 e_minus_2 = new Core.Class_minus_2();
  public static final Core.Func_minus_2 t_minus_2 = new Core.Class_minus_2();

  public static Core.Type_int f_minus_2(final Core.Type_intlist nums) {
    Core.Type_int output = Core.e_int;
    output = Core.f_any_from_list_start_reduce(
      Core.t_int,
      nums,
      Core.vx_new_int(0),
      Core.t_any_from_reduce.vx_fn_new((total_any, num_any) -> {
        Core.Type_int total = Core.f_any_from_any(Core.t_int, total_any);
        Core.Type_int num = Core.f_any_from_any(Core.t_int, num_any);
        Core.Type_any output_1 = Core.f_minus(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function minus 3
   * Math number minus
   * @param  {numberlist} nums
   * @return {number}
   * (func -)
   */
  public interface Func_minus_3 extends Core.Func_any_from_any {
    public Core.Type_number vx_minus_3(final Core.Type_numberlist nums);
  }

  public static class Class_minus_3 extends Core.Class_base implements Func_minus_3 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_minus_3 output = new Core.Class_minus_3();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_minus_3 output = new Core.Class_minus_3();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        3, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_minus_3;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_minus_3;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_numberlist inputval = (Core.Type_numberlist)value;
      Core.Type_any outputval = Core.f_minus_3(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_numberlist nums = Core.f_any_from_any(Core.t_numberlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_minus_3(nums);
      return output;
    }

    @Override
    public Core.Type_number vx_minus_3(final Core.Type_numberlist nums) {
      Core.Type_number output = Core.f_minus_3(nums);
      return output;
    }

  }

  public static final Core.Func_minus_3 e_minus_3 = new Core.Class_minus_3();
  public static final Core.Func_minus_3 t_minus_3 = new Core.Class_minus_3();

  public static Core.Type_number f_minus_3(final Core.Type_numberlist nums) {
    Core.Type_number output = Core.e_number;
    output = Core.f_any_from_list_start_reduce(
      Core.t_number,
      nums,
      Core.vx_new_int(0),
      Core.t_any_from_reduce.vx_fn_new((total_any, num_any) -> {
        Core.Type_number total = Core.f_any_from_any(Core.t_number, total_any);
        Core.Type_number num = Core.f_any_from_any(Core.t_number, num_any);
        Core.Type_any output_1 = Core.f_minus_1(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function minus1
   * Math int minus 1
   * @param  {int} num
   * @return {int}
   * (func -1)
   */
  public interface Func_minus1 extends Core.Func_any_from_any {
    public Core.Type_int vx_minus1(final Core.Type_int num);
  }

  public static class Class_minus1 extends Core.Class_base implements Func_minus1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_minus1 output = new Core.Class_minus1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_minus1 output = new Core.Class_minus1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "-1", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_minus1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_minus1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_int inputval = (Core.Type_int)value;
      Core.Type_any outputval = Core.f_minus1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_int num = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_minus1(num);
      return output;
    }

    @Override
    public Core.Type_int vx_minus1(final Core.Type_int num) {
      Core.Type_int output = Core.f_minus1(num);
      return output;
    }

  }

  public static final Core.Func_minus1 e_minus1 = new Core.Class_minus1();
  public static final Core.Func_minus1 t_minus1 = new Core.Class_minus1();

  public static Core.Type_int f_minus1(final Core.Type_int num) {
    Core.Type_int output = Core.e_int;
    output = Core.f_minus(
      num,
      Core.vx_new_int(1)
    );
    return output;
  }

  /**
   * @function dotmethod
   * Not Recommened: Support for Object Oriented dot notation. e.g. (this.foo 'a') = this.foo('a')
   * @param  {any} target
   * @param  {string} method
   * @param  {anylist} parameters
   * @return {any}
   * (func .)
   */
  public interface Func_dotmethod extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_any vx_dotmethod(final Core.Type_any target, final Core.Type_string method, final Core.Type_anylist parameters);
  }

  public static class Class_dotmethod extends Core.Class_base implements Func_dotmethod {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_dotmethod output = new Core.Class_dotmethod();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_dotmethod output = new Core.Class_dotmethod();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        ".", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_dotmethod;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_dotmethod;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any target = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string method = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_anylist parameters = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_dotmethod(target, method, parameters);
      return output;
    }

    @Override
    public Core.Type_any vx_dotmethod(final Core.Type_any target, final Core.Type_string method, final Core.Type_anylist parameters) {
      Core.Type_any output = Core.f_dotmethod(target, method, parameters);
      return output;
    }

  }

  public static final Core.Func_dotmethod e_dotmethod = new Core.Class_dotmethod();
  public static final Core.Func_dotmethod t_dotmethod = new Core.Class_dotmethod();

  public static Core.Type_any f_dotmethod(final Core.Type_any target, final Core.Type_string method, final Core.Type_anylist parameters) {
    Core.Type_any output = Core.e_any;
    return output;
  }

  /**
   * @function divide
   * Math divide
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func /)
   */
  public interface Func_divide extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_number vx_divide(final Core.Type_number num1, final Core.Type_number num2);
  }

  public static class Class_divide extends Core.Class_base implements Func_divide {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_divide output = new Core.Class_divide();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_divide output = new Core.Class_divide();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "/", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_divide;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_divide;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_number num1 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_number num2 = Core.f_any_from_any(Core.t_number, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_divide(num1, num2);
      return output;
    }

    @Override
    public Core.Type_number vx_divide(final Core.Type_number num1, final Core.Type_number num2) {
      Core.Type_number output = Core.f_divide(num1, num2);
      return output;
    }

  }

  public static final Core.Func_divide e_divide = new Core.Class_divide();
  public static final Core.Func_divide t_divide = new Core.Class_divide();

  public static Core.Type_number f_divide(final Core.Type_number num1, final Core.Type_number num2) {
    Core.Type_number output = Core.e_number;
    float float1 = Core.vx_float_from_number(num1);
    float float2 = Core.vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = Core.c_notanumber;
    } else {
      float result = float1 / float2;
      output = Core.vx_new_float(result);
    };
    return output;
  }

  /**
   * @function lt
   * Returns true if the first arg is less than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func <)
   */
  public interface Func_lt extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_lt(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_lt extends Core.Class_base implements Func_lt {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_lt output = new Core.Class_lt();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_lt output = new Core.Class_lt();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_lt;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_lt;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_lt(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_lt(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_lt(val1, val2);
      return output;
    }

  }

  public static final Core.Func_lt e_lt = new Core.Class_lt();
  public static final Core.Func_lt t_lt = new Core.Class_lt();

  public static Core.Type_boolean f_lt(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_switch(
      Core.t_boolean,
      Core.f_compare(
        val1,
        val2
      ),
      Core.vx_new(
        Core.t_thenelselist,
        Core.f_case_1(
          Core.vx_new_int(-1),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_1 = Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Core.f_else(
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_2 = Core.vx_new_boolean(false);
            return output_2;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function lt 1
   * Returns true if the first arg is less than all of the other args
   * @param  {anylist} values
   * @return {boolean}
   * (func <)
   */
  public interface Func_lt_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_lt_1(final Core.Type_anylist values);
  }

  public static class Class_lt_1 extends Core.Class_base implements Func_lt_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_lt_1 output = new Core.Class_lt_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_lt_1 output = new Core.Class_lt_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_lt_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_lt_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_lt_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist values = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_lt_1(values);
      return output;
    }

    @Override
    public Core.Type_boolean vx_lt_1(final Core.Type_anylist values) {
      Core.Type_boolean output = Core.f_lt_1(values);
      return output;
    }

  }

  public static final Core.Func_lt_1 e_lt_1 = new Core.Class_lt_1();
  public static final Core.Func_lt_1 t_lt_1 = new Core.Class_lt_1();

  public static Core.Type_boolean f_lt_1(final Core.Type_anylist values) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_any_from_list_start_reduce_next(
      Core.t_boolean,
      values,
      Core.vx_new_boolean(true),
      Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) -> {
        Core.Type_boolean reduce = Core.f_any_from_any(Core.t_boolean, reduce_any);
        Core.Type_any current = Core.f_any_from_any(Core.t_any, current_any);
        Core.Type_any next = Core.f_any_from_any(Core.t_any, next_any);
        Core.Type_any output_1 = Core.f_and(
          reduce,
          Core.f_lt(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function chainfirst
   * This is a special function that applies a value as the first argument for the first function.
   * The result is then used as the first argument on the next function, etc. Sometimes this
   * improves readability.
   * @param  {any-1} value
   * @param  {any<-anylist} fnlist
   * @return {any-1}
   * (func <-)
   */
  public interface Func_chainfirst extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_chainfirst(final T generic_any_1, final T value, final Core.Type_any_from_anylist fnlist);
  }

  public static class Class_chainfirst extends Core.Class_base implements Func_chainfirst {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_chainfirst output = new Core.Class_chainfirst();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_chainfirst output = new Core.Class_chainfirst();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "<-", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_chainfirst;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_chainfirst;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any_from_anylist fnlist = Core.f_any_from_any(Core.t_any_from_anylist, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_chainfirst(generic_any_1, value, fnlist);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_chainfirst(final T generic_any_1, final T value, final Core.Type_any_from_anylist fnlist) {
      T output = Core.f_chainfirst(generic_any_1, value, fnlist);
      return output;
    }

  }

  public static final Core.Func_chainfirst e_chainfirst = new Core.Class_chainfirst();
  public static final Core.Func_chainfirst t_chainfirst = new Core.Class_chainfirst();

  public static <T extends Core.Type_any> T f_chainfirst(final T generic_any_1, final T value, final Core.Type_any_from_anylist fnlist) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function chainlast
   * This is a special function that applies a value as the last argument for the first function.
   * The result is then used as the last argument on the next function, etc. Sometimes this
   * improves readability.
   * @param  {any-1} value
   * @param  {any<-anylist} fnlist
   * @return {any-1}
   * (func <<-)
   */
  public interface Func_chainlast extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_chainlast(final T generic_any_1, final T value, final Core.Type_any_from_anylist fnlist);
  }

  public static class Class_chainlast extends Core.Class_base implements Func_chainlast {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_chainlast output = new Core.Class_chainlast();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_chainlast output = new Core.Class_chainlast();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "<<-", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_chainlast;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_chainlast;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any_from_anylist fnlist = Core.f_any_from_any(Core.t_any_from_anylist, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_chainlast(generic_any_1, value, fnlist);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_chainlast(final T generic_any_1, final T value, final Core.Type_any_from_anylist fnlist) {
      T output = Core.f_chainlast(generic_any_1, value, fnlist);
      return output;
    }

  }

  public static final Core.Func_chainlast e_chainlast = new Core.Class_chainlast();
  public static final Core.Func_chainlast t_chainlast = new Core.Class_chainlast();

  public static <T extends Core.Type_any> T f_chainlast(final T generic_any_1, final T value, final Core.Type_any_from_anylist fnlist) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function le
   * Returns true if the first arg is less or equal than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func <=)
   */
  public interface Func_le extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_le(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_le extends Core.Class_base implements Func_le {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_le output = new Core.Class_le();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_le output = new Core.Class_le();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_le;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_le;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_le(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_le(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_le(val1, val2);
      return output;
    }

  }

  public static final Core.Func_le e_le = new Core.Class_le();
  public static final Core.Func_le t_le = new Core.Class_le();

  public static Core.Type_boolean f_le(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_gt(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function le 1
   * Returns true if the first arg is less or equal than all of the other args
   * @param  {anylist} args
   * @return {boolean}
   * (func <=)
   */
  public interface Func_le_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_le_1(final Core.Type_anylist args);
  }

  public static class Class_le_1 extends Core.Class_base implements Func_le_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_le_1 output = new Core.Class_le_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_le_1 output = new Core.Class_le_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_le_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_le_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_le_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist args = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_le_1(args);
      return output;
    }

    @Override
    public Core.Type_boolean vx_le_1(final Core.Type_anylist args) {
      Core.Type_boolean output = Core.f_le_1(args);
      return output;
    }

  }

  public static final Core.Func_le_1 e_le_1 = new Core.Class_le_1();
  public static final Core.Func_le_1 t_le_1 = new Core.Class_le_1();

  public static Core.Type_boolean f_le_1(final Core.Type_anylist args) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_gt_1(
        args
      )
    );
    return output;
  }

  /**
   * @function eq
   * Boolean equal/equivalent
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func =)
   */
  public interface Func_eq extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_eq(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_eq extends Core.Class_base implements Func_eq {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_eq output = new Core.Class_eq();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_eq output = new Core.Class_eq();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_eq;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_eq;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_eq(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_eq(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_eq(val1, val2);
      return output;
    }

  }

  public static final Core.Func_eq e_eq = new Core.Class_eq();
  public static final Core.Func_eq t_eq = new Core.Class_eq();

  public static Core.Type_boolean f_eq(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    boolean isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Core.Type_string strval1 = Core.f_string_from_any(val1);
      Core.Type_string strval2 = Core.f_string_from_any(val2);
      if (strval1.vx_string().equals(strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Core.vx_new_boolean(isequal);
    return output;
  }

  /**
   * @function eq 1
   * Boolean equal/equivalent
   * @param  {anylist} values
   * @return {boolean}
   * (func =)
   */
  public interface Func_eq_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_eq_1(final Core.Type_anylist values);
  }

  public static class Class_eq_1 extends Core.Class_base implements Func_eq_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_eq_1 output = new Core.Class_eq_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_eq_1 output = new Core.Class_eq_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_eq_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_eq_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_eq_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist values = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_eq_1(values);
      return output;
    }

    @Override
    public Core.Type_boolean vx_eq_1(final Core.Type_anylist values) {
      Core.Type_boolean output = Core.f_eq_1(values);
      return output;
    }

  }

  public static final Core.Func_eq_1 e_eq_1 = new Core.Class_eq_1();
  public static final Core.Func_eq_1 t_eq_1 = new Core.Class_eq_1();

  public static Core.Type_boolean f_eq_1(final Core.Type_anylist values) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_any_from_list_start_reduce_next(
      Core.t_boolean,
      values,
      Core.vx_new_boolean(false),
      Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) -> {
        Core.Type_boolean reduce = Core.f_any_from_any(Core.t_boolean, reduce_any);
        Core.Type_any current = Core.f_any_from_any(Core.t_any, current_any);
        Core.Type_any next = Core.f_any_from_any(Core.t_any, next_any);
        Core.Type_any output_1 = Core.f_and(
          reduce,
          Core.f_eq(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function eqeq
   * Strict equality check. Note that all non-empty, non-constants will not be equal.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func ==)
   */
  public interface Func_eqeq extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_eqeq(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_eqeq extends Core.Class_base implements Func_eqeq {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_eqeq output = new Core.Class_eqeq();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_eqeq output = new Core.Class_eqeq();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "==", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_eqeq;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_eqeq;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_eqeq(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_eqeq(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_eqeq(val1, val2);
      return output;
    }

  }

  public static final Core.Func_eqeq e_eqeq = new Core.Class_eqeq();
  public static final Core.Func_eqeq t_eqeq = new Core.Class_eqeq();

  public static Core.Type_boolean f_eqeq(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    boolean isequal = Core.vx_eqeq(val1, val2);
    output = Core.vx_new_boolean(isequal);
    return output;
  }

  /**
   * @function gt
   * Returns true if the first arg is greater than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func >)
   */
  public interface Func_gt extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_gt(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_gt extends Core.Class_base implements Func_gt {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_gt output = new Core.Class_gt();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_gt output = new Core.Class_gt();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_gt;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_gt;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_gt(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_gt(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_gt(val1, val2);
      return output;
    }

  }

  public static final Core.Func_gt e_gt = new Core.Class_gt();
  public static final Core.Func_gt t_gt = new Core.Class_gt();

  public static Core.Type_boolean f_gt(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_switch(
      Core.t_boolean,
      Core.f_compare(
        val1,
        val2
      ),
      Core.vx_new(
        Core.t_thenelselist,
        Core.f_case_1(
          Core.vx_new_int(1),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_1 = Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Core.f_else(
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_2 = Core.vx_new_boolean(false);
            return output_2;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function gt 1
   * Returns true if the first arg is greater than all of the other args
   * @param  {anylist} values
   * @return {boolean}
   * (func >)
   */
  public interface Func_gt_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_gt_1(final Core.Type_anylist values);
  }

  public static class Class_gt_1 extends Core.Class_base implements Func_gt_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_gt_1 output = new Core.Class_gt_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_gt_1 output = new Core.Class_gt_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_gt_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_gt_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_gt_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist values = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_gt_1(values);
      return output;
    }

    @Override
    public Core.Type_boolean vx_gt_1(final Core.Type_anylist values) {
      Core.Type_boolean output = Core.f_gt_1(values);
      return output;
    }

  }

  public static final Core.Func_gt_1 e_gt_1 = new Core.Class_gt_1();
  public static final Core.Func_gt_1 t_gt_1 = new Core.Class_gt_1();

  public static Core.Type_boolean f_gt_1(final Core.Type_anylist values) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_any_from_list_start_reduce_next(
      Core.t_boolean,
      values,
      Core.vx_new_boolean(true),
      Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) -> {
        Core.Type_boolean reduce = Core.f_any_from_any(Core.t_boolean, reduce_any);
        Core.Type_any current = Core.f_any_from_any(Core.t_any, current_any);
        Core.Type_any next = Core.f_any_from_any(Core.t_any, next_any);
        Core.Type_any output_1 = Core.f_and(
          reduce,
          Core.f_gt(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function ge
   * Returns true if val1 is greater or equal to val2
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func >=)
   */
  public interface Func_ge extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_ge(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_ge extends Core.Class_base implements Func_ge {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_ge output = new Core.Class_ge();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_ge output = new Core.Class_ge();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_ge;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_ge;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_ge(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_ge(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_boolean output = Core.f_ge(val1, val2);
      return output;
    }

  }

  public static final Core.Func_ge e_ge = new Core.Class_ge();
  public static final Core.Func_ge t_ge = new Core.Class_ge();

  public static Core.Type_boolean f_ge(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_lt(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function ge 1
   * Returns true if the first arg is greater or equal than all of the other args
   * @param  {anylist} args
   * @return {boolean}
   * (func >=)
   */
  public interface Func_ge_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_ge_1(final Core.Type_anylist args);
  }

  public static class Class_ge_1 extends Core.Class_base implements Func_ge_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_ge_1 output = new Core.Class_ge_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_ge_1 output = new Core.Class_ge_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_ge_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_ge_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_ge_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist args = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_ge_1(args);
      return output;
    }

    @Override
    public Core.Type_boolean vx_ge_1(final Core.Type_anylist args) {
      Core.Type_boolean output = Core.f_ge_1(args);
      return output;
    }

  }

  public static final Core.Func_ge_1 e_ge_1 = new Core.Class_ge_1();
  public static final Core.Func_ge_1 t_ge_1 = new Core.Class_ge_1();

  public static Core.Type_boolean f_ge_1(final Core.Type_anylist args) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_not(
      Core.f_lt_1(
        args
      )
    );
    return output;
  }

  /**
   * @function allowfuncs_from_security
   * Returns allowfuncs from a given security.
   * @param  {security} security
   * @return {funclist}
   * (func allowfuncs<-security)
   */
  public interface Func_allowfuncs_from_security extends Core.Func_any_from_any {
    public Core.Type_funclist vx_allowfuncs_from_security(final Core.Type_security security);
  }

  public static class Class_allowfuncs_from_security extends Core.Class_base implements Func_allowfuncs_from_security {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_allowfuncs_from_security output = new Core.Class_allowfuncs_from_security();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_allowfuncs_from_security output = new Core.Class_allowfuncs_from_security();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "allowfuncs<-security", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "funclist", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_func), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_allowfuncs_from_security;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_allowfuncs_from_security;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_security inputval = (Core.Type_security)value;
      Core.Type_any outputval = Core.f_allowfuncs_from_security(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_security security = Core.f_any_from_any(Core.t_security, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_allowfuncs_from_security(security);
      return output;
    }

    @Override
    public Core.Type_funclist vx_allowfuncs_from_security(final Core.Type_security security) {
      Core.Type_funclist output = Core.f_allowfuncs_from_security(security);
      return output;
    }

  }

  public static final Core.Func_allowfuncs_from_security e_allowfuncs_from_security = new Core.Class_allowfuncs_from_security();
  public static final Core.Func_allowfuncs_from_security t_allowfuncs_from_security = new Core.Class_allowfuncs_from_security();

  public static Core.Type_funclist f_allowfuncs_from_security(final Core.Type_security security) {
    Core.Type_funclist output = Core.e_funclist;
    output = security.allowfuncs();
    return output;
  }

  /**
   * @function allowtypenames_from_typedef
   * Return allow name list from type
   * @param  {typedef} vtypedef
   * @return {stringlist}
   * (func allowtypenames<-typedef)
   */
  public interface Func_allowtypenames_from_typedef extends Core.Func_any_from_any {
    public Core.Type_stringlist vx_allowtypenames_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_allowtypenames_from_typedef extends Core.Class_base implements Func_allowtypenames_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_allowtypenames_from_typedef output = new Core.Class_allowtypenames_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_allowtypenames_from_typedef output = new Core.Class_allowtypenames_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "allowtypenames<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_string), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_allowtypenames_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_allowtypenames_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_allowtypenames_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_allowtypenames_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_stringlist vx_allowtypenames_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_stringlist output = Core.f_allowtypenames_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_allowtypenames_from_typedef e_allowtypenames_from_typedef = new Core.Class_allowtypenames_from_typedef();
  public static final Core.Func_allowtypenames_from_typedef t_allowtypenames_from_typedef = new Core.Class_allowtypenames_from_typedef();

  public static Core.Type_stringlist f_allowtypenames_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_stringlist output = Core.e_stringlist;
    output = Core.f_typenames_from_typelist(
      Core.f_allowtypes_from_typedef(
        vtypedef
      )
    );
    return output;
  }

  /**
   * @function allowtypes_from_typedef
   * Return allow type list from type
   * @param  {typedef} vtypedef
   * @return {typelist}
   * (func allowtypes<-typedef)
   */
  public interface Func_allowtypes_from_typedef extends Core.Func_any_from_any {
    public Core.Type_typelist vx_allowtypes_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_allowtypes_from_typedef extends Core.Class_base implements Func_allowtypes_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_allowtypes_from_typedef output = new Core.Class_allowtypes_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_allowtypes_from_typedef output = new Core.Class_allowtypes_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "allowtypes<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_allowtypes_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_allowtypes_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_allowtypes_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_allowtypes_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_typelist vx_allowtypes_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_typelist output = Core.f_allowtypes_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_allowtypes_from_typedef e_allowtypes_from_typedef = new Core.Class_allowtypes_from_typedef();
  public static final Core.Func_allowtypes_from_typedef t_allowtypes_from_typedef = new Core.Class_allowtypes_from_typedef();

  public static Core.Type_typelist f_allowtypes_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_typelist output = Core.e_typelist;
    output = vtypedef.allowtypes();
    return output;
  }

  /**
   * @function and
   * Returns true if all values are true
   * @param  {boolean} val1
   * @param  {boolean} val2
   * @return {boolean}
   * (func and)
   */
  public interface Func_and extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_and(final Core.Type_boolean val1, final Core.Type_boolean val2);
  }

  public static class Class_and extends Core.Class_base implements Func_and {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_and output = new Core.Class_and();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_and output = new Core.Class_and();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_and;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_and;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_boolean val1 = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_boolean val2 = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_and(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_and(final Core.Type_boolean val1, final Core.Type_boolean val2) {
      Core.Type_boolean output = Core.f_and(val1, val2);
      return output;
    }

  }

  public static final Core.Func_and e_and = new Core.Class_and();
  public static final Core.Func_and t_and = new Core.Class_and();

  public static Core.Type_boolean f_and(final Core.Type_boolean val1, final Core.Type_boolean val2) {
    Core.Type_boolean output = Core.e_boolean;
    if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    };
    return output;
  }

  /**
   * @function and 1
   * Returns true if all values are true
   * @param  {booleanlist} values
   * @return {boolean}
   * (func and)
   */
  public interface Func_and_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_and_1(final Core.Type_booleanlist values);
  }

  public static class Class_and_1 extends Core.Class_base implements Func_and_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_and_1 output = new Core.Class_and_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_and_1 output = new Core.Class_and_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_and_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_and_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_booleanlist inputval = (Core.Type_booleanlist)value;
      Core.Type_any outputval = Core.f_and_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_booleanlist values = Core.f_any_from_any(Core.t_booleanlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_and_1(values);
      return output;
    }

    @Override
    public Core.Type_boolean vx_and_1(final Core.Type_booleanlist values) {
      Core.Type_boolean output = Core.f_and_1(values);
      return output;
    }

  }

  public static final Core.Func_and_1 e_and_1 = new Core.Class_and_1();
  public static final Core.Func_and_1 t_and_1 = new Core.Class_and_1();

  public static Core.Type_boolean f_and_1(final Core.Type_booleanlist values) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_switch(
      Core.t_boolean,
      Core.f_length_1(
        values
      ),
      Core.vx_new(
        Core.t_thenelselist,
        Core.f_case_1(
          Core.vx_new_int(0),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_1 = Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Core.f_case_1(
          Core.vx_new_int(1),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_2 = Core.f_any_from_list(
              Core.t_boolean,
              values,
              Core.vx_new_int(1)
            );
            return output_2;
          })
        ),
        Core.f_else(
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_3 = Core.f_any_from_list_start_reduce_next(
              Core.t_boolean,
              values,
              Core.vx_new_boolean(true),
              Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) -> {
                Core.Type_boolean reduce = Core.f_any_from_any(Core.t_boolean, reduce_any);
                Core.Type_boolean current = Core.f_any_from_any(Core.t_boolean, current_any);
                Core.Type_boolean next = Core.f_any_from_any(Core.t_boolean, next_any);
                Core.Type_any output_4 = Core.f_and(
                  reduce,
                  Core.f_and(
                    current,
                    next
                  )
                );
                return output_4;
              })
            );
            return output_3;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function any_from_any
   * Function Type taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any)
   */
  public interface Func_any_from_any extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value);
    public Core.Func_any_from_any vx_fn_new(Class_any_from_any.IFn fn);
  }

  public static class Class_any_from_any extends Core.Class_base implements Func_any_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_any output = new Core.Class_any_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_any output = new Core.Class_any_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_any;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_any value);
    }

    public Class_any_from_any.IFn fn = null;

    @Override
    public Core.Func_any_from_any vx_fn_new(Class_any_from_any.IFn fn) {
      Core.Class_any_from_any output = new Core.Class_any_from_any();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_any_from_any(generic_any_1, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_any.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(value);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_any e_any_from_any = new Core.Class_any_from_any();
  public static final Core.Func_any_from_any t_any_from_any = new Core.Class_any_from_any();

  @SuppressWarnings("unchecked")
  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_any(final T generic_any_1, final U value) {
    T output = Core.f_empty(generic_any_1);
    output = (T)value;
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_any_async
   * Function Type taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-async)
   */
  public interface Func_any_from_any_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_any_async(final T generic_any_1, final U value);
    public Core.Func_any_from_any_async vx_fn_new(Class_any_from_any_async.IFn fn);
  }

  public static class Class_any_from_any_async extends Core.Class_base implements Func_any_from_any_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_any_async output = new Core.Class_any_from_any_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_any_async output = new Core.Class_any_from_any_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_any_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_any_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve(Core.Type_any value);
    }

    public Class_any_from_any_async.IFn fn = null;

    @Override
    public Core.Func_any_from_any_async vx_fn_new(Class_any_from_any_async.IFn fn) {
      Core.Class_any_from_any_async output = new Core.Class_any_from_any_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_any_async(generic_any_1, value);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_any_async(final T generic_any_1, final U value) {
      CompletableFuture<T> output;
      Class_any_from_any_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve(value);
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_any_async e_any_from_any_async = new Core.Class_any_from_any_async();
  public static final Core.Func_any_from_any_async t_any_from_any_async = new Core.Class_any_from_any_async();

  public static <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> f_any_from_any_async(final T generic_any_1, final U value) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_any_context
   * Function Type taking any value any-2 and returning generic any-1 using context
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-context)
   */
  public interface Func_any_from_any_context extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value);
    public Core.Func_any_from_any_context vx_fn_new(Class_any_from_any_context.IFn fn);
  }

  public static class Class_any_from_any_context extends Core.Class_base implements Func_any_from_any_context {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_any_context output = new Core.Class_any_from_any_context();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_any_context output = new Core.Class_any_from_any_context();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_any_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_any_context;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_context context, Core.Type_any value);
    }

    public Class_any_from_any_context.IFn fn = null;

    @Override
    public Core.Func_any_from_any_context vx_fn_new(Class_any_from_any_context.IFn fn) {
      Core.Class_any_from_any_context output = new Core.Class_any_from_any_context();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_any_from_any_context(generic_any_1, context, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_any_context.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(context, value);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_any_context e_any_from_any_context = new Core.Class_any_from_any_context();
  public static final Core.Func_any_from_any_context t_any_from_any_context = new Core.Class_any_from_any_context();

  @SuppressWarnings("unchecked")
  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value) {
    T output = Core.f_empty(generic_any_1);
    output = (T)value;
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_any_context_async
   * Generic Function taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-context-async)
   */
  public interface Func_any_from_any_context_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_any_context_async(final T generic_any_1, final Core.Type_context context, final U value);
    public Core.Func_any_from_any_context_async vx_fn_new(Class_any_from_any_context_async.IFn fn);
  }

  public static class Class_any_from_any_context_async extends Core.Class_base implements Func_any_from_any_context_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_any_context_async output = new Core.Class_any_from_any_context_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_any_context_async output = new Core.Class_any_from_any_context_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_any_context_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_any_context_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve(Core.Type_context context, Core.Type_any value);
    }

    public Class_any_from_any_context_async.IFn fn = null;

    @Override
    public Core.Func_any_from_any_context_async vx_fn_new(Class_any_from_any_context_async.IFn fn) {
      Core.Class_any_from_any_context_async output = new Core.Class_any_from_any_context_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_any_context_async(generic_any_1, context, value);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_any_context_async(final T generic_any_1, final Core.Type_context context, final U value) {
      CompletableFuture<T> output;
      Class_any_from_any_context_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve(context, value);
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_any_context_async e_any_from_any_context_async = new Core.Class_any_from_any_context_async();
  public static final Core.Func_any_from_any_context_async t_any_from_any_context_async = new Core.Class_any_from_any_context_async();

  public static <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> f_any_from_any_context_async(final T generic_any_1, final Core.Type_context context, final U value) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_any_key_value
   * Generic Function returning Generic any-1 from a any-1, a key, and a value.
   * @param  {any-1} current
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-key-value)
   */
  public interface Func_any_from_any_key_value extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_key_value(final T generic_any_1, final T current, final Core.Type_string key, final U value);
    public Core.Func_any_from_any_key_value vx_fn_new(Class_any_from_any_key_value.IFn fn);
  }

  public static class Class_any_from_any_key_value extends Core.Class_base implements Func_any_from_any_key_value {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_any_key_value output = new Core.Class_any_from_any_key_value();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_any_key_value output = new Core.Class_any_from_any_key_value();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-key-value", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_any_key_value;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_any_key_value;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_any current, Core.Type_string key, Core.Type_any value);
    }

    public Class_any_from_any_key_value.IFn fn = null;

    @Override
    public Core.Func_any_from_any_key_value vx_fn_new(Class_any_from_any_key_value.IFn fn) {
      Core.Class_any_from_any_key_value output = new Core.Class_any_from_any_key_value();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any current = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string key = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_any_from_any_key_value(generic_any_1, current, key, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_key_value(final T generic_any_1, final T current, final Core.Type_string key, final U value) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_any_key_value.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(current, key, value);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_any_key_value e_any_from_any_key_value = new Core.Class_any_from_any_key_value();
  public static final Core.Func_any_from_any_key_value t_any_from_any_key_value = new Core.Class_any_from_any_key_value();

  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_any_key_value(final T generic_any_1, final T current, final Core.Type_string key, final U value) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function any_from_func
   * Generic Function returning Generic any-1 with any parameters
   * @return {any-1}
   * (func any<-func)
   */
  public interface Func_any_from_func extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_any_from_func(final T generic_any_1);
    public Core.Func_any_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public static class Class_any_from_func extends Core.Class_base implements Func_any_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_func output = new Core.Class_any_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_func output = new Core.Class_any_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_func;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve();
    }

    public Class_any_from_func.IFn fn = null;

    @Override
    public Core.Func_any_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Core.Class_any_from_func output = new Core.Class_any_from_func();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_any_from_func(generic_any_1);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_any_from_func(final T generic_any_1) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_func.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve();
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_func e_any_from_func = new Core.Class_any_from_func();
  public static final Core.Func_any_from_func t_any_from_func = new Core.Class_any_from_func();

  public static <T extends Core.Type_any> T f_any_from_func(final T generic_any_1) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_func_async
   * Generic Function returning Generic any-1 with any parameters
   * @return {any-1}
   * (func any<-func-async)
   */
  public interface Func_any_from_func_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any> CompletableFuture<T> vx_any_from_func_async(final T generic_any_1);
    public Core.Func_any_from_func_async vx_fn_new(Class_any_from_func_async.IFn fn);
  }

  public static class Class_any_from_func_async extends Core.Class_base implements Func_any_from_func_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_func_async output = new Core.Class_any_from_func_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_func_async output = new Core.Class_any_from_func_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-func-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_func_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_func_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve();
    }

    public Class_any_from_func_async.IFn fn = null;

    @Override
    public Core.Func_any_from_func_async vx_fn_new(Class_any_from_func_async.IFn fn) {
      Core.Class_any_from_func_async output = new Core.Class_any_from_func_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_func_async(generic_any_1);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any> CompletableFuture<T> vx_any_from_func_async(final T generic_any_1) {
      CompletableFuture<T> output;
      Class_any_from_func_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve();
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_func_async e_any_from_func_async = new Core.Class_any_from_func_async();
  public static final Core.Func_any_from_func_async t_any_from_func_async = new Core.Class_any_from_func_async();

  public static <T extends Core.Type_any> CompletableFuture<T> f_any_from_func_async(final T generic_any_1) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_int
   * Generic Function returning Generic any-1 from an int
   * @param  {int} value
   * @return {any-1}
   * (func any<-int)
   */
  public interface Func_any_from_int extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_any_from_int(final T generic_any_1, final Core.Type_int value);
    public Core.Func_any_from_int vx_fn_new(Class_any_from_int.IFn fn);
  }

  public static class Class_any_from_int extends Core.Class_base implements Func_any_from_int {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_int output = new Core.Class_any_from_int();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_int output = new Core.Class_any_from_int();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-int", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_int;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_int;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_int value);
    }

    public Class_any_from_int.IFn fn = null;

    @Override
    public Core.Func_any_from_int vx_fn_new(Class_any_from_int.IFn fn) {
      Core.Class_any_from_int output = new Core.Class_any_from_int();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int value = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_any_from_int(generic_any_1, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_any_from_int(final T generic_any_1, final Core.Type_int value) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_int.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(value);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_int e_any_from_int = new Core.Class_any_from_int();
  public static final Core.Func_any_from_int t_any_from_int = new Core.Class_any_from_int();

  public static <T extends Core.Type_any> T f_any_from_int(final T generic_any_1, final Core.Type_int value) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function any_from_int_any
   * Generic Function returning Generic any-1 from an int and a value
   * @param  {int} num
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-int-any)
   */
  public interface Func_any_from_int_any extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_int_any(final T generic_any_1, final Core.Type_int num, final U value);
    public Core.Func_any_from_int_any vx_fn_new(Class_any_from_int_any.IFn fn);
  }

  public static class Class_any_from_int_any extends Core.Class_base implements Func_any_from_int_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_int_any output = new Core.Class_any_from_int_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_int_any output = new Core.Class_any_from_int_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-int-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_int_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_int_any;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_int num, Core.Type_any value);
    }

    public Class_any_from_int_any.IFn fn = null;

    @Override
    public Core.Func_any_from_int_any vx_fn_new(Class_any_from_int_any.IFn fn) {
      Core.Class_any_from_int_any output = new Core.Class_any_from_int_any();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int num = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_any_from_int_any(generic_any_1, num, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_int_any(final T generic_any_1, final Core.Type_int num, final U value) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_int_any.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(num, value);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_int_any e_any_from_int_any = new Core.Class_any_from_int_any();
  public static final Core.Func_any_from_int_any t_any_from_int_any = new Core.Class_any_from_int_any();

  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_int_any(final T generic_any_1, final Core.Type_int num, final U value) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function any_from_key_value
   * Generic Function returning Generic any-1 from a key and a value
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-key-value)
   */
  public interface Func_any_from_key_value extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_key_value(final T generic_any_1, final Core.Type_string key, final U value);
    public Core.Func_any_from_key_value vx_fn_new(Class_any_from_key_value.IFn fn);
  }

  public static class Class_any_from_key_value extends Core.Class_base implements Func_any_from_key_value {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_key_value output = new Core.Class_any_from_key_value();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_key_value output = new Core.Class_any_from_key_value();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_key_value;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_key_value;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_string key, Core.Type_any value);
    }

    public Class_any_from_key_value.IFn fn = null;

    @Override
    public Core.Func_any_from_key_value vx_fn_new(Class_any_from_key_value.IFn fn) {
      Core.Class_any_from_key_value output = new Core.Class_any_from_key_value();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string key = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_any_from_key_value(generic_any_1, key, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_key_value(final T generic_any_1, final Core.Type_string key, final U value) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_key_value.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(key, value);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_key_value e_any_from_key_value = new Core.Class_any_from_key_value();
  public static final Core.Func_any_from_key_value t_any_from_key_value = new Core.Class_any_from_key_value();

  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_key_value(final T generic_any_1, final Core.Type_string key, final U value) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_key_value_async
   * Generic Function returning Asynchronous Generic any-1 from a key and a value
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-key-value-async)
   */
  public interface Func_any_from_key_value_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_key_value_async(final T generic_any_1, final Core.Type_string key, final U value);
    public Core.Func_any_from_key_value_async vx_fn_new(Class_any_from_key_value_async.IFn fn);
  }

  public static class Class_any_from_key_value_async extends Core.Class_base implements Func_any_from_key_value_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_key_value_async output = new Core.Class_any_from_key_value_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_key_value_async output = new Core.Class_any_from_key_value_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_key_value_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_key_value_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve(Core.Type_string key, Core.Type_any value);
    }

    public Class_any_from_key_value_async.IFn fn = null;

    @Override
    public Core.Func_any_from_key_value_async vx_fn_new(Class_any_from_key_value_async.IFn fn) {
      Core.Class_any_from_key_value_async output = new Core.Class_any_from_key_value_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string key = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_key_value_async(generic_any_1, key, value);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_key_value_async(final T generic_any_1, final Core.Type_string key, final U value) {
      CompletableFuture<T> output;
      Class_any_from_key_value_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve(key, value);
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_key_value_async e_any_from_key_value_async = new Core.Class_any_from_key_value_async();
  public static final Core.Func_any_from_key_value_async t_any_from_key_value_async = new Core.Class_any_from_key_value_async();

  public static <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> f_any_from_key_value_async(final T generic_any_1, final Core.Type_string key, final U value) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_list
   * Returns nth value from a list or none if out of bounds
   * @param  {list-1} values
   * @param  {int} index
   * @return {any-1}
   * (func any<-list)
   */
  public interface Func_any_from_list extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_any_from_list(final T generic_any_1, final X values, final Core.Type_int index);
  }

  public static class Class_any_from_list extends Core.Class_base implements Func_any_from_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_list output = new Core.Class_any_from_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_list output = new Core.Class_any_from_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int index = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_any_from_list(generic_any_1, values, index);
      return output;
    }

    @Override
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_any_from_list(final T generic_any_1, final X values, final Core.Type_int index) {
      T output = Core.f_any_from_list(generic_any_1, values, index);
      return output;
    }

  }

  public static final Core.Func_any_from_list e_any_from_list = new Core.Class_any_from_list();
  public static final Core.Func_any_from_list t_any_from_list = new Core.Class_any_from_list();

  public static <T extends Core.Type_any, X extends Core.Type_list> T f_any_from_list(final T generic_any_1, final X values, final Core.Type_int index) {
    T output = Core.f_empty(generic_any_1);
    int intindex = index.vx_int();
    int intsize = values.vx_list().size();
    if (intindex <= intsize) {
      List<Core.Type_any> listvalue = values.vx_list();
      Core.Type_any value = listvalue.get(intindex - 1);
      output = Core.f_any_from_any(generic_any_1, value);
    };
    return output;
  }

  /**
   * @function any_from_list_start_reduce
   * Returns a val from a list reduce operation
   * @param  {list-2} list
   * @param  {any-1} valstart
   * @param  {any<-reduce} fn-reduce
   * @return {any-1}
   * (func any<-list-start-reduce)
   */
  public interface Func_any_from_list_start_reduce extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, Y extends Core.Type_list> T vx_any_from_list_start_reduce(final T generic_any_1, final Y list, final T valstart, final Core.Func_any_from_reduce fn_reduce);
  }

  public static class Class_any_from_list_start_reduce extends Core.Class_base implements Func_any_from_list_start_reduce {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_list_start_reduce output = new Core.Class_any_from_list_start_reduce();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_list_start_reduce output = new Core.Class_any_from_list_start_reduce();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_list_start_reduce;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_list_start_reduce;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list list = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any valstart = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      Core.Func_any_from_reduce fn_reduce = Core.f_any_from_any(Core.t_any_from_reduce, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
      return output;
    }

    @Override
    public <T extends Core.Type_any, Y extends Core.Type_list> T vx_any_from_list_start_reduce(final T generic_any_1, final Y list, final T valstart, final Core.Func_any_from_reduce fn_reduce) {
      T output = Core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
      return output;
    }

  }

  public static final Core.Func_any_from_list_start_reduce e_any_from_list_start_reduce = new Core.Class_any_from_list_start_reduce();
  public static final Core.Func_any_from_list_start_reduce t_any_from_list_start_reduce = new Core.Class_any_from_list_start_reduce();

  public static <T extends Core.Type_any, Y extends Core.Type_list> T f_any_from_list_start_reduce(final T generic_any_1, final Y list, final T valstart, final Core.Func_any_from_reduce fn_reduce) {
    T output = Core.f_empty(generic_any_1);
    output = Core.vx_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
    return output;
  }

  /**
   * @function any_from_list_start_reduce_next
   * Returns a val from a list reduce operation
   * @param  {list-2} list
   * @param  {any-1} valstart
   * @param  {any<-reduce-next} fn-reduce-next
   * @return {any-1}
   * (func any<-list-start-reduce-next)
   */
  public interface Func_any_from_list_start_reduce_next extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, Y extends Core.Type_list> T vx_any_from_list_start_reduce_next(final T generic_any_1, final Y list, final T valstart, final Core.Func_any_from_reduce_next fn_reduce_next);
  }

  public static class Class_any_from_list_start_reduce_next extends Core.Class_base implements Func_any_from_list_start_reduce_next {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_list_start_reduce_next output = new Core.Class_any_from_list_start_reduce_next();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_list_start_reduce_next output = new Core.Class_any_from_list_start_reduce_next();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce-next", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_list_start_reduce_next;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_list_start_reduce_next;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list list = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any valstart = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      Core.Func_any_from_reduce_next fn_reduce_next = Core.f_any_from_any(Core.t_any_from_reduce_next, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next);
      return output;
    }

    @Override
    public <T extends Core.Type_any, Y extends Core.Type_list> T vx_any_from_list_start_reduce_next(final T generic_any_1, final Y list, final T valstart, final Core.Func_any_from_reduce_next fn_reduce_next) {
      T output = Core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next);
      return output;
    }

  }

  public static final Core.Func_any_from_list_start_reduce_next e_any_from_list_start_reduce_next = new Core.Class_any_from_list_start_reduce_next();
  public static final Core.Func_any_from_list_start_reduce_next t_any_from_list_start_reduce_next = new Core.Class_any_from_list_start_reduce_next();

  public static <T extends Core.Type_any, Y extends Core.Type_list> T f_any_from_list_start_reduce_next(final T generic_any_1, final Y list, final T valstart, final Core.Func_any_from_reduce_next fn_reduce_next) {
    T output = Core.f_empty(generic_any_1);
    output = valstart;
    final List<Core.Type_any> listval = list.vx_list();
    Core.Type_any current = Core.e_any;
    boolean first = true;
    for (final Core.Type_any next : listval) {
      if (first) {
        first = false;
      } else {
        output = fn_reduce_next.vx_any_from_reduce_next(generic_any_1, output, current, next);
      }
      current = next;
    };
    return output;
  }

  /**
   * @function any_from_map
   * Returns value from a map or empty if not found
   * @param  {map-1} valuemap
   * @param  {string} key
   * @return {any-1}
   * (func any<-map)
   */
  public interface Func_any_from_map extends Core.Type_func, Core.Type_replfunc {
    public <N extends Core.Type_map, T extends Core.Type_any> T vx_any_from_map(final T generic_any_1, final N valuemap, final Core.Type_string key);
  }

  public static class Class_any_from_map extends Core.Class_base implements Func_any_from_map {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_map output = new Core.Class_any_from_map();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_map output = new Core.Class_any_from_map();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-map", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_map;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_map;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string key = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_any_from_map(generic_any_1, valuemap, key);
      return output;
    }

    @Override
    public <N extends Core.Type_map, T extends Core.Type_any> T vx_any_from_map(final T generic_any_1, final N valuemap, final Core.Type_string key) {
      T output = Core.f_any_from_map(generic_any_1, valuemap, key);
      return output;
    }

  }

  public static final Core.Func_any_from_map e_any_from_map = new Core.Class_any_from_map();
  public static final Core.Func_any_from_map t_any_from_map = new Core.Class_any_from_map();

  public static <N extends Core.Type_map, T extends Core.Type_any> T f_any_from_map(final T generic_any_1, final N valuemap, final Core.Type_string key) {
    T output = Core.f_empty(generic_any_1);
    output = Core.vx_any_from_map(generic_any_1, valuemap, key);
    return output;
  }

  /**
   * @function any_from_map_start_reduce
   * Returns a value by reducing each element of a map.
   * @param  {map-1} map
   * @param  {any-1} start
   * @param  {any<-any-key-value} fn-reduce
   * @return {any-1}
   * (func any<-map-start-reduce)
   */
  public interface Func_any_from_map_start_reduce extends Core.Type_func, Core.Type_replfunc {
    public <N extends Core.Type_map, T extends Core.Type_any> T vx_any_from_map_start_reduce(final T generic_any_1, final N map, final T start, final Core.Func_any_from_any_key_value fn_reduce);
  }

  public static class Class_any_from_map_start_reduce extends Core.Class_base implements Func_any_from_map_start_reduce {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_map_start_reduce output = new Core.Class_any_from_map_start_reduce();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_map_start_reduce output = new Core.Class_any_from_map_start_reduce();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-map-start-reduce", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_map_start_reduce;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_map_start_reduce;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map map = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any start = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      Core.Func_any_from_any_key_value fn_reduce = Core.f_any_from_any(Core.t_any_from_any_key_value, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
      return output;
    }

    @Override
    public <N extends Core.Type_map, T extends Core.Type_any> T vx_any_from_map_start_reduce(final T generic_any_1, final N map, final T start, final Core.Func_any_from_any_key_value fn_reduce) {
      T output = Core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
      return output;
    }

  }

  public static final Core.Func_any_from_map_start_reduce e_any_from_map_start_reduce = new Core.Class_any_from_map_start_reduce();
  public static final Core.Func_any_from_map_start_reduce t_any_from_map_start_reduce = new Core.Class_any_from_map_start_reduce();

  public static <N extends Core.Type_map, T extends Core.Type_any> T f_any_from_map_start_reduce(final T generic_any_1, final N map, final T start, final Core.Func_any_from_any_key_value fn_reduce) {
    T output = Core.f_empty(generic_any_1);
    output = Core.vx_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
    return output;
  }

  /**
   * @function any_from_none
   * Function Type returning Generic any-1 with no parameters
   * @return {any-1}
   * (func any<-none)
   */
  public interface Func_any_from_none extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_any_from_none(final T generic_any_1);
    public Core.Func_any_from_none vx_fn_new(Class_any_from_none.IFn fn);
  }

  public static class Class_any_from_none extends Core.Class_base implements Func_any_from_none {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_none output = new Core.Class_any_from_none();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_none output = new Core.Class_any_from_none();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-none", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_none;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_none;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve();
    }

    public Class_any_from_none.IFn fn = null;

    @Override
    public Core.Func_any_from_none vx_fn_new(Class_any_from_none.IFn fn) {
      Core.Class_any_from_none output = new Core.Class_any_from_none();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_any_from_none(generic_any_1);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_any_from_none(final T generic_any_1) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_none.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve();
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_none e_any_from_none = new Core.Class_any_from_none();
  public static final Core.Func_any_from_none t_any_from_none = new Core.Class_any_from_none();

  public static <T extends Core.Type_any> T f_any_from_none(final T generic_any_1) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_none_async
   * Function Type returning Generic any-1 with no parameters
   * @return {any-1}
   * (func any<-none-async)
   */
  public interface Func_any_from_none_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any> CompletableFuture<T> vx_any_from_none_async(final T generic_any_1);
    public Core.Func_any_from_none_async vx_fn_new(Class_any_from_none_async.IFn fn);
  }

  public static class Class_any_from_none_async extends Core.Class_base implements Func_any_from_none_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_none_async output = new Core.Class_any_from_none_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_none_async output = new Core.Class_any_from_none_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-none-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_none_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_none_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve();
    }

    public Class_any_from_none_async.IFn fn = null;

    @Override
    public Core.Func_any_from_none_async vx_fn_new(Class_any_from_none_async.IFn fn) {
      Core.Class_any_from_none_async output = new Core.Class_any_from_none_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_none_async(generic_any_1);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any> CompletableFuture<T> vx_any_from_none_async(final T generic_any_1) {
      CompletableFuture<T> output;
      Class_any_from_none_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve();
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_none_async e_any_from_none_async = new Core.Class_any_from_none_async();
  public static final Core.Func_any_from_none_async t_any_from_none_async = new Core.Class_any_from_none_async();

  public static <T extends Core.Type_any> CompletableFuture<T> f_any_from_none_async(final T generic_any_1) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_reduce
   * @param  {any-1} result
   * @param  {any-2} item
   * @return {any-1}
   * (func any<-reduce)
   */
  public interface Func_any_from_reduce extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_reduce(final T generic_any_1, final T result, final U item);
    public Core.Func_any_from_reduce vx_fn_new(Class_any_from_reduce.IFn fn);
  }

  public static class Class_any_from_reduce extends Core.Class_base implements Func_any_from_reduce {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_reduce output = new Core.Class_any_from_reduce();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_reduce output = new Core.Class_any_from_reduce();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_reduce;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_reduce;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_any result, Core.Type_any item);
    }

    public Class_any_from_reduce.IFn fn = null;

    @Override
    public Core.Func_any_from_reduce vx_fn_new(Class_any_from_reduce.IFn fn) {
      Core.Class_any_from_reduce output = new Core.Class_any_from_reduce();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any result = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any item = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_any_from_reduce(generic_any_1, result, item);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_reduce(final T generic_any_1, final T result, final U item) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_reduce.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(result, item);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_reduce e_any_from_reduce = new Core.Class_any_from_reduce();
  public static final Core.Func_any_from_reduce t_any_from_reduce = new Core.Class_any_from_reduce();

  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_reduce(final T generic_any_1, final T result, final U item) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_reduce_async
   * @param  {any-1} result
   * @param  {any-2} item
   * @return {any-1}
   * (func any<-reduce-async)
   */
  public interface Func_any_from_reduce_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_reduce_async(final T generic_any_1, final T result, final U item);
    public Core.Func_any_from_reduce_async vx_fn_new(Class_any_from_reduce_async.IFn fn);
  }

  public static class Class_any_from_reduce_async extends Core.Class_base implements Func_any_from_reduce_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_reduce_async output = new Core.Class_any_from_reduce_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_reduce_async output = new Core.Class_any_from_reduce_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_reduce_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_reduce_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve(Core.Type_any result, Core.Type_any item);
    }

    public Class_any_from_reduce_async.IFn fn = null;

    @Override
    public Core.Func_any_from_reduce_async vx_fn_new(Class_any_from_reduce_async.IFn fn) {
      Core.Class_any_from_reduce_async output = new Core.Class_any_from_reduce_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any result = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any item = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_reduce_async(generic_any_1, result, item);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_reduce_async(final T generic_any_1, final T result, final U item) {
      CompletableFuture<T> output;
      Class_any_from_reduce_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve(result, item);
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_reduce_async e_any_from_reduce_async = new Core.Class_any_from_reduce_async();
  public static final Core.Func_any_from_reduce_async t_any_from_reduce_async = new Core.Class_any_from_reduce_async();

  public static <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> f_any_from_reduce_async(final T generic_any_1, final T result, final U item) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_reduce_next
   * @param  {any-1} result
   * @param  {any-2} current
   * @param  {any-2} next
   * @return {any-1}
   * (func any<-reduce-next)
   */
  public interface Func_any_from_reduce_next extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_reduce_next(final T generic_any_1, final T result, final U current, final U next);
    public Core.Func_any_from_reduce_next vx_fn_new(Class_any_from_reduce_next.IFn fn);
  }

  public static class Class_any_from_reduce_next extends Core.Class_base implements Func_any_from_reduce_next {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_reduce_next output = new Core.Class_any_from_reduce_next();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_reduce_next output = new Core.Class_any_from_reduce_next();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_reduce_next;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_reduce_next;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_any result, Core.Type_any current, Core.Type_any next);
    }

    public Class_any_from_reduce_next.IFn fn = null;

    @Override
    public Core.Func_any_from_reduce_next vx_fn_new(Class_any_from_reduce_next.IFn fn) {
      Core.Class_any_from_reduce_next output = new Core.Class_any_from_reduce_next();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any result = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any current = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_any next = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_any_from_reduce_next(generic_any_1, result, current, next);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_reduce_next(final T generic_any_1, final T result, final U current, final U next) {
      T output = Core.f_empty(generic_any_1);
      Class_any_from_reduce_next.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(result, current, next);
        output = Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_reduce_next e_any_from_reduce_next = new Core.Class_any_from_reduce_next();
  public static final Core.Func_any_from_reduce_next t_any_from_reduce_next = new Core.Class_any_from_reduce_next();

  public static <T extends Core.Type_any, U extends Core.Type_any> T f_any_from_reduce_next(final T generic_any_1, final T result, final U current, final U next) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_reduce_next_async
   * @param  {any-1} result
   * @param  {any-2} current
   * @param  {any-2} next
   * @return {any-1}
   * (func any<-reduce-next-async)
   */
  public interface Func_any_from_reduce_next_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_reduce_next_async(final T generic_any_1, final T result, final U current, final U next);
    public Core.Func_any_from_reduce_next_async vx_fn_new(Class_any_from_reduce_next_async.IFn fn);
  }

  public static class Class_any_from_reduce_next_async extends Core.Class_base implements Func_any_from_reduce_next_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_reduce_next_async output = new Core.Class_any_from_reduce_next_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_reduce_next_async output = new Core.Class_any_from_reduce_next_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_reduce_next_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_reduce_next_async;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public CompletableFuture<Core.Type_any> resolve(Core.Type_any result, Core.Type_any current, Core.Type_any next);
    }

    public Class_any_from_reduce_next_async.IFn fn = null;

    @Override
    public Core.Func_any_from_reduce_next_async vx_fn_new(Class_any_from_reduce_next_async.IFn fn) {
      Core.Class_any_from_reduce_next_async output = new Core.Class_any_from_reduce_next_async();
      output.fn = fn;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any result = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any current = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_any next = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(2)));
      CompletableFuture<Core.Type_any> future = Core.f_any_from_reduce_next_async(generic_any_1, result, current, next);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_reduce_next_async(final T generic_any_1, final T result, final U current, final U next) {
      CompletableFuture<T> output;
      Class_any_from_reduce_next_async.IFn fnlocal = this.fn;
      if (fnlocal == null) {
        output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
      } else {
        CompletableFuture<Core.Type_any> future = fnlocal.resolve(result, current, next);
        output = Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static final Core.Func_any_from_reduce_next_async e_any_from_reduce_next_async = new Core.Class_any_from_reduce_next_async();
  public static final Core.Func_any_from_reduce_next_async t_any_from_reduce_next_async = new Core.Class_any_from_reduce_next_async();

  public static <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> f_any_from_reduce_next_async(final T generic_any_1, final T result, final U current, final U next) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_struct
   * Returns value from a struct
   * @param  {struct-2} vstruct
   * @param  {string} key
   * @return {any-1}
   * (func any<-struct)
   */
  public interface Func_any_from_struct extends Core.Type_func, Core.Type_replfunc {
    public <R extends Core.Type_struct, T extends Core.Type_any> T vx_any_from_struct(final T generic_any_1, final R vstruct, final Core.Type_string key);
  }

  public static class Class_any_from_struct extends Core.Class_base implements Func_any_from_struct {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_any_from_struct output = new Core.Class_any_from_struct();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_any_from_struct output = new Core.Class_any_from_struct();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "any<-struct", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_any_from_struct;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_any_from_struct;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_struct vstruct = Core.f_any_from_any(Core.t_struct, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string key = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_any_from_struct(generic_any_1, vstruct, key);
      return output;
    }

    @Override
    public <R extends Core.Type_struct, T extends Core.Type_any> T vx_any_from_struct(final T generic_any_1, final R vstruct, final Core.Type_string key) {
      T output = Core.f_any_from_struct(generic_any_1, vstruct, key);
      return output;
    }

  }

  public static final Core.Func_any_from_struct e_any_from_struct = new Core.Class_any_from_struct();
  public static final Core.Func_any_from_struct t_any_from_struct = new Core.Class_any_from_struct();

  public static <R extends Core.Type_struct, T extends Core.Type_any> T f_any_from_struct(final T generic_any_1, final R vstruct, final Core.Type_string key) {
    T output = Core.f_empty(generic_any_1);
    Core.Type_any val = vstruct.vx_any(key);
    output = Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  /**
   * 
   * @async
   * @function async
   * Returns an asynchonous version value. This exists mostly for type-casting.
   * @param  {any-1} value
   * @return {any-1}
   * (func async)
   */
  public interface Func_async extends Core.Func_any_from_any_async {
    public <T extends Core.Type_any> CompletableFuture<T> vx_async(final T generic_any_1, final T value);
  }

  public static class Class_async extends Core.Class_base implements Func_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_async output = new Core.Class_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_async output = new Core.Class_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_async;
      return output;
    }

    @Override
    public Core.Func_any_from_any_async vx_fn_new(Core.Class_any_from_any_async.IFn fn) {
      return Core.e_any_from_any_async;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_any_async(final T generic_any_1, final U value) {
      T inputval = Core.f_any_from_any(generic_any_1, value);
      CompletableFuture<T> output = Core.f_async(generic_any_1, inputval);
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_async(generic_any_1, value);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any> CompletableFuture<T> vx_async(final T generic_any_1, final T value) {
      CompletableFuture<T> output = Core.f_async(generic_any_1, value);
      return output;
    }

  }

  public static final Core.Func_async e_async = new Core.Class_async();
  public static final Core.Func_async t_async = new Core.Class_async();

  public static <T extends Core.Type_any> CompletableFuture<T> f_async(final T generic_any_1, final T value) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    output = Core.vx_async_new_from_value(value);
    return output;
  }

  /**
   * @function boolean_permission_from_func
   * Returns true if the given func has permission.
   * @param  {func} func
   * @return {boolean}
   * (func boolean-permission<-func)
   */
  public interface Func_boolean_permission_from_func extends Core.Func_any_from_any_context {
    public Core.Type_boolean vx_boolean_permission_from_func(final Core.Type_context context, final Core.Type_func func);
  }

  public static class Class_boolean_permission_from_func extends Core.Class_base implements Func_boolean_permission_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_boolean_permission_from_func output = new Core.Class_boolean_permission_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_boolean_permission_from_func output = new Core.Class_boolean_permission_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "boolean-permission<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_boolean_permission_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_boolean_permission_from_func;
      return output;
    }

    @Override
    public Core.Func_any_from_any_context vx_fn_new(Core.Class_any_from_any_context.IFn fn) {
      return Core.e_any_from_any_context;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_func inputval = (Core.Type_func)value;
      Core.Type_any outputval = Core.f_boolean_permission_from_func(context, inputval);
      output = Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_func func = Core.f_any_from_any(Core.t_func, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_boolean_permission_from_func(context, func);
      return output;
    }

    @Override
    public Core.Type_boolean vx_boolean_permission_from_func(final Core.Type_context context, final Core.Type_func func) {
      Core.Type_boolean output = Core.f_boolean_permission_from_func(context, func);
      return output;
    }

  }

  public static final Core.Func_boolean_permission_from_func e_boolean_permission_from_func = new Core.Class_boolean_permission_from_func();
  public static final Core.Func_boolean_permission_from_func t_boolean_permission_from_func = new Core.Class_boolean_permission_from_func();

  public static Core.Type_boolean f_boolean_permission_from_func(final Core.Type_context context, final Core.Type_func func) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_contains_1(
      Core.f_allowfuncs_from_security(
        Core.f_security_from_context(
          context
        )
      ),
      func
    );
    return output;
  }

  /**
   * @function boolean_write_from_map_name_value
   * Returns true if it alters a mutable map false if it fails.
   * @param  {map-1} valuemap
   * @param  {string} name
   * @param  {any-1} value
   * @return {boolean}
   * (func boolean-write<-map-name-value)
   */
  public interface Func_boolean_write_from_map_name_value extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_boolean_write_from_map_name_value(final Core.Type_map valuemap, final Core.Type_string name, final Core.Type_any value);
  }

  public static class Class_boolean_write_from_map_name_value extends Core.Class_base implements Func_boolean_write_from_map_name_value {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_boolean_write_from_map_name_value output = new Core.Class_boolean_write_from_map_name_value();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_boolean_write_from_map_name_value output = new Core.Class_boolean_write_from_map_name_value();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "boolean-write<-map-name-value", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_boolean_write_from_map_name_value;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_boolean_write_from_map_name_value;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string name = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_boolean_write_from_map_name_value(valuemap, name, value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_boolean_write_from_map_name_value(final Core.Type_map valuemap, final Core.Type_string name, final Core.Type_any value) {
      Core.Type_boolean output = Core.f_boolean_write_from_map_name_value(valuemap, name, value);
      return output;
    }

  }

  public static final Core.Func_boolean_write_from_map_name_value e_boolean_write_from_map_name_value = new Core.Class_boolean_write_from_map_name_value();
  public static final Core.Func_boolean_write_from_map_name_value t_boolean_write_from_map_name_value = new Core.Class_boolean_write_from_map_name_value();

  public static Core.Type_boolean f_boolean_write_from_map_name_value(final Core.Type_map valuemap, final Core.Type_string name, final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.vx_boolean_write_from_map_name_value(valuemap, name, value);
    return output;
  }

  /**
   * @function boolean_from_any
   * Function Type taking generic any-1 and returning boolean
   * @param  {any-1} value
   * @return {boolean}
   * (func boolean<-any)
   */
  public interface Func_boolean_from_any extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_boolean_from_any(final Core.Type_any value);
    public Core.Func_boolean_from_any vx_fn_new(Class_boolean_from_any.IFn fn);
  }

  public static class Class_boolean_from_any extends Core.Class_base implements Func_boolean_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_boolean_from_any output = new Core.Class_boolean_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_boolean_from_any output = new Core.Class_boolean_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_boolean_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_boolean_from_any;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve(Core.Type_any value);
    }

    public Class_boolean_from_any.IFn fn = null;

    @Override
    public Core.Func_boolean_from_any vx_fn_new(Class_boolean_from_any.IFn fn) {
      Core.Class_boolean_from_any output = new Core.Class_boolean_from_any();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_boolean_from_any(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_boolean_from_any(final Core.Type_any value) {
      Core.Type_boolean output = Core.c_false;
      Class_boolean_from_any.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve(value);
        output = Core.f_any_from_any(Core.t_boolean, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_boolean_from_any e_boolean_from_any = new Core.Class_boolean_from_any();
  public static final Core.Func_boolean_from_any t_boolean_from_any = new Core.Class_boolean_from_any();

  public static Core.Type_boolean f_boolean_from_any(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    return output;
  }

  /**
   * @function boolean_from_func
   * Function Type returning boolean with any parameters
   * @return {boolean}
   * (func boolean<-func)
   */
  public interface Func_boolean_from_func extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_boolean_from_func();
    public Core.Func_boolean_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public static class Class_boolean_from_func extends Core.Class_base implements Func_boolean_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_boolean_from_func output = new Core.Class_boolean_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_boolean_from_func output = new Core.Class_boolean_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_boolean_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_boolean_from_func;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve();
    }

    public Class_any_from_func.IFn fn = null;

    @Override
    public Core.Func_boolean_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Core.Class_boolean_from_func output = new Core.Class_boolean_from_func();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      output = Core.f_boolean_from_func();
      return output;
    }

    @Override
    public Core.Type_boolean vx_boolean_from_func() {
      Core.Type_boolean output = Core.c_false;
      Core.Class_any_from_func.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve();
        output = Core.f_any_from_any(Core.t_boolean, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_boolean_from_func e_boolean_from_func = new Core.Class_boolean_from_func();
  public static final Core.Func_boolean_from_func t_boolean_from_func = new Core.Class_boolean_from_func();

  public static Core.Type_boolean f_boolean_from_func() {
    Core.Type_boolean output = Core.e_boolean;
    return output;
  }

  /**
   * @function boolean_from_none
   * Function Type returning boolean with no parameters
   * @return {boolean}
   * (func boolean<-none)
   */
  public interface Func_boolean_from_none extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_boolean_from_none();
    public Core.Func_boolean_from_none vx_fn_new(Class_any_from_func.IFn fn);
  }

  public static class Class_boolean_from_none extends Core.Class_base implements Func_boolean_from_none {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_boolean_from_none output = new Core.Class_boolean_from_none();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_boolean_from_none output = new Core.Class_boolean_from_none();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-none", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_boolean_from_none;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_boolean_from_none;
      return output;
    }

    @FunctionalInterface
    public interface IFn {
      public Core.Type_any resolve();
    }

    public Class_any_from_func.IFn fn = null;

    @Override
    public Core.Func_boolean_from_none vx_fn_new(Class_any_from_func.IFn fn) {
      Core.Class_boolean_from_none output = new Core.Class_boolean_from_none();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      output = Core.f_boolean_from_none();
      return output;
    }

    @Override
    public Core.Type_boolean vx_boolean_from_none() {
      Core.Type_boolean output = Core.c_false;
      Core.Class_any_from_func.IFn fnlocal = this.fn;
      if (fnlocal != null) {
        Core.Type_any anyoutput = fnlocal.resolve();
        output = Core.f_any_from_any(Core.t_boolean, anyoutput);
      }
      return output;
    }

  }

  public static final Core.Func_boolean_from_none e_boolean_from_none = new Core.Class_boolean_from_none();
  public static final Core.Func_boolean_from_none t_boolean_from_none = new Core.Class_boolean_from_none();

  public static Core.Type_boolean f_boolean_from_none() {
    Core.Type_boolean output = Core.e_boolean;
    return output;
  }

  /**
   * @function case
   * @param  {list-1} values
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func case)
   */
  public interface Func_case extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_thenelse vx_case(final Core.Type_list values, final Core.Func_any_from_func fn_any);
  }

  public static class Class_case extends Core.Class_base implements Func_case {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_case output = new Core.Class_case();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_case output = new Core.Class_case();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_case;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_case;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_case(values, fn_any);
      return output;
    }

    @Override
    public Core.Type_thenelse vx_case(final Core.Type_list values, final Core.Func_any_from_func fn_any) {
      Core.Type_thenelse output = Core.f_case(values, fn_any);
      return output;
    }

  }

  public static final Core.Func_case e_case = new Core.Class_case();
  public static final Core.Func_case t_case = new Core.Class_case();

  public static Core.Type_thenelse f_case(final Core.Type_list values, final Core.Func_any_from_func fn_any) {
    Core.Type_thenelse output = Core.e_thenelse;
    output = Core.f_new(
      Core.t_thenelse,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":code"),
        Core.vx_new_string(":casemany"),
        Core.vx_new_string(":values"),
        values,
        Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function case 1
   * @param  {any-1} value
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func case)
   */
  public interface Func_case_1 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_thenelse vx_case_1(final Core.Type_any value, final Core.Func_any_from_func fn_any);
  }

  public static class Class_case_1 extends Core.Class_base implements Func_case_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_case_1 output = new Core.Class_case_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_case_1 output = new Core.Class_case_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_case_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_case_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_case_1(value, fn_any);
      return output;
    }

    @Override
    public Core.Type_thenelse vx_case_1(final Core.Type_any value, final Core.Func_any_from_func fn_any) {
      Core.Type_thenelse output = Core.f_case_1(value, fn_any);
      return output;
    }

  }

  public static final Core.Func_case_1 e_case_1 = new Core.Class_case_1();
  public static final Core.Func_case_1 t_case_1 = new Core.Class_case_1();

  public static Core.Type_thenelse f_case_1(final Core.Type_any value, final Core.Func_any_from_func fn_any) {
    Core.Type_thenelse output = Core.e_thenelse;
    output = Core.f_new(
      Core.t_thenelse,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":code"),
        Core.vx_new_string(":case"),
        Core.vx_new_string(":value"),
        value,
        Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function compare
   * Returns 0 if vals are equal, 1 if val1 > val2, -1 if val1 < val2
   * @param  {any} val1
   * @param  {any} val2
   * @return {int}
   * (func compare)
   */
  public interface Func_compare extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_int vx_compare(final Core.Type_any val1, final Core.Type_any val2);
  }

  public static class Class_compare extends Core.Class_base implements Func_compare {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_compare output = new Core.Class_compare();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_compare output = new Core.Class_compare();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "compare", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_compare;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_compare;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any val1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any val2 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_compare(val1, val2);
      return output;
    }

    @Override
    public Core.Type_int vx_compare(final Core.Type_any val1, final Core.Type_any val2) {
      Core.Type_int output = Core.f_compare(val1, val2);
      return output;
    }

  }

  public static final Core.Func_compare e_compare = new Core.Class_compare();
  public static final Core.Func_compare t_compare = new Core.Class_compare();

  public static Core.Type_int f_compare(final Core.Type_any val1, final Core.Type_any val2) {
    Core.Type_int output = Core.e_int;
    int intresult = 0;
    if ((val1 instanceof Core.Type_number) && (val2 instanceof Core.Type_number)) {
      Core.Type_number num1 = (Core.Type_number)val1;
      Core.Type_number num2 = (Core.Type_number)val2;
      float float1 = Core.vx_new(Core.t_float, num1).vx_float();
      float float2 = Core.vx_new(Core.t_float, num2).vx_float();
      if (float1 < float2) {
        intresult = -1;
      } else if (float1 > float2) {
        intresult = 1;
      }
    } else {
      String stringval1 = Core.f_string_from_any(val1).vx_string();
      String stringval2 = Core.f_string_from_any(val2).vx_string();
      int compare = stringval1.compareTo(stringval2);
      if (compare > 0) {
        intresult = 1;
      } else if (compare < 0) {
        intresult = -1;
      }
    }
    output = Core.vx_new_int(intresult);
    return output;
  }

  /**
   * @function contains
   * Returns true if the given list contains the given value.
   * @param  {string} text
   * @param  {string} find
   * @return {boolean}
   * (func contains)
   */
  public interface Func_contains extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_contains(final Core.Type_string text, final Core.Type_string find);
  }

  public static class Class_contains extends Core.Class_base implements Func_contains {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_contains output = new Core.Class_contains();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_contains output = new Core.Class_contains();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_contains;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_contains;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string find = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_contains(text, find);
      return output;
    }

    @Override
    public Core.Type_boolean vx_contains(final Core.Type_string text, final Core.Type_string find) {
      Core.Type_boolean output = Core.f_contains(text, find);
      return output;
    }

  }

  public static final Core.Func_contains e_contains = new Core.Class_contains();
  public static final Core.Func_contains t_contains = new Core.Class_contains();

  public static Core.Type_boolean f_contains(final Core.Type_string text, final Core.Type_string find) {
    Core.Type_boolean output = Core.e_boolean;
    boolean check = vx_boolean_from_string_find(
      text.vx_string(),
      find.vx_string());
    output = Core.vx_new_boolean(check);
    return output;
  }

  /**
   * @function contains 1
   * Returns true if the given list contains the given value.
   * @param  {list-2} values Any list
   * @param  {any} find Any value
   * @return {boolean}
   * (func contains)
   */
  public interface Func_contains_1 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_contains_1(final Core.Type_list values, final Core.Type_any find);
  }

  public static class Class_contains_1 extends Core.Class_base implements Func_contains_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_contains_1 output = new Core.Class_contains_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_contains_1 output = new Core.Class_contains_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_contains_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_contains_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any find = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_contains_1(values, find);
      return output;
    }

    @Override
    public Core.Type_boolean vx_contains_1(final Core.Type_list values, final Core.Type_any find) {
      Core.Type_boolean output = Core.f_contains_1(values, find);
      return output;
    }

  }

  public static final Core.Func_contains_1 e_contains_1 = new Core.Class_contains_1();
  public static final Core.Func_contains_1 t_contains_1 = new Core.Class_contains_1();

  public static Core.Type_boolean f_contains_1(final Core.Type_list values, final Core.Type_any find) {
    Core.Type_boolean output = Core.e_boolean;
    boolean booleanresult = false;
    List<Core.Type_any> listvalues = values.vx_list();
    for (Core.Type_any item : listvalues) {
      Core.Type_boolean iseq = Core.f_eq(item, find);
      if (iseq.vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = Core.vx_new_boolean(booleanresult);
    return output;
  }

  /**
   * @function context_main
   * Returns the default context for app main execution. Arguments come from the command line.
   * @param  {anylist} args
   * @return {context}
   * (func context-main)
   */
  public interface Func_context_main extends Core.Func_any_from_any {
    public Core.Type_context vx_context_main(final Core.Type_anylist args);
  }

  public static class Class_context_main extends Core.Class_base implements Func_context_main {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_context_main output = new Core.Class_context_main();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_context_main output = new Core.Class_context_main();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "context-main", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "context", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_context_main;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_context_main;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_context_main(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist args = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_context_main(args);
      return output;
    }

    @Override
    public Core.Type_context vx_context_main(final Core.Type_anylist args) {
      Core.Type_context output = Core.f_context_main(args);
      return output;
    }

  }

  public static final Core.Func_context_main e_context_main = new Core.Class_context_main();
  public static final Core.Func_context_main t_context_main = new Core.Class_context_main();

  public static Core.Type_context f_context_main(final Core.Type_anylist args) {
    Core.Type_context output = Core.e_context;
    output = Core.f_empty(
      Core.t_context
    );
    return output;
  }

  /**
   * @function copy
   * Returns a copy of a given value with the given values added or updated.
   * @param  {any-1} value
   * @param  {anylist} values
   * @return {any-1}
   * (func copy)
   */
  public interface Func_copy extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_copy(final T value, final Core.Type_anylist values);
  }

  public static class Class_copy extends Core.Class_base implements Func_copy {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_copy output = new Core.Class_copy();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_copy output = new Core.Class_copy();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "copy", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_copy;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_copy;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_anylist values = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_copy(value, values);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_copy(final T value, final Core.Type_anylist values) {
      T output = Core.f_copy(value, values);
      return output;
    }

  }

  public static final Core.Func_copy e_copy = new Core.Class_copy();
  public static final Core.Func_copy t_copy = new Core.Class_copy();

  @SuppressWarnings("unchecked")
  public static <T extends Core.Type_any> T f_copy(final T value, final Core.Type_anylist values) {
    Core.Type_any[] arrayany = Core.arrayany_from_anylist(
      values);
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(value.vx_copy(arrayobj));
    return output;
  }

  /**
   * @function else
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func else)
   */
  public interface Func_else extends Core.Func_any_from_any {
    public Core.Type_thenelse vx_else(final Core.Func_any_from_func fn_any);
  }

  public static class Class_else extends Core.Class_base implements Func_else {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_else output = new Core.Class_else();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_else output = new Core.Class_else();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "else", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_else;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_else;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Func_any_from_func inputval = (Core.Func_any_from_func)value;
      Core.Type_any outputval = Core.f_else(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_else(fn_any);
      return output;
    }

    @Override
    public Core.Type_thenelse vx_else(final Core.Func_any_from_func fn_any) {
      Core.Type_thenelse output = Core.f_else(fn_any);
      return output;
    }

  }

  public static final Core.Func_else e_else = new Core.Class_else();
  public static final Core.Func_else t_else = new Core.Class_else();

  public static Core.Type_thenelse f_else(final Core.Func_any_from_func fn_any) {
    Core.Type_thenelse output = Core.e_thenelse;
    output = Core.f_new(
      Core.t_thenelse,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":code"),
        Core.vx_new_string(":else"),
        Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function empty
   * Returns the empty value for a given type. Can be called using (empty type) or simply (type)
   * @param  {any-1} type
   * @return {any-1}
   * (func empty)
   */
  public interface Func_empty extends Core.Func_any_from_any {
    public <T extends Core.Type_any> T vx_empty(final T type);
  }

  public static class Class_empty extends Core.Class_base implements Func_empty {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_empty output = new Core.Class_empty();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_empty output = new Core.Class_empty();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "empty", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_empty;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_empty;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_empty(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any type = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_empty(type);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_empty(final T type) {
      T output = Core.f_empty(type);
      return output;
    }

  }

  public static final Core.Func_empty e_empty = new Core.Class_empty();
  public static final Core.Func_empty t_empty = new Core.Class_empty();

  public static <T extends Core.Type_any> T f_empty(final T type) {
    T output = Core.vx_empty(type);
    return output;
  }

  /**
   * @function extends_from_any
   * @param  {any-1} value
   * @return {string}
   * (func extends<-any)
   */
  public interface Func_extends_from_any extends Core.Func_any_from_any {
    public Core.Type_string vx_extends_from_any(final Core.Type_any value);
  }

  public static class Class_extends_from_any extends Core.Class_base implements Func_extends_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_extends_from_any output = new Core.Class_extends_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_extends_from_any output = new Core.Class_extends_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "extends<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_extends_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_extends_from_any;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_extends_from_any(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_extends_from_any(value);
      return output;
    }

    @Override
    public Core.Type_string vx_extends_from_any(final Core.Type_any value) {
      Core.Type_string output = Core.f_extends_from_any(value);
      return output;
    }

  }

  public static final Core.Func_extends_from_any e_extends_from_any = new Core.Class_extends_from_any();
  public static final Core.Func_extends_from_any t_extends_from_any = new Core.Class_extends_from_any();

  public static Core.Type_string f_extends_from_any(final Core.Type_any value) {
    Core.Type_string output = Core.e_string;
    output = Core.f_extends_from_typedef(
      Core.f_typedef_from_any(
        value
      )
    );
    return output;
  }

  /**
   * @function extends_from_typedef
   * Get the basetype of a given type
   * @param  {typedef} vtypedef
   * @return {string}
   * (func extends<-typedef)
   */
  public interface Func_extends_from_typedef extends Core.Func_any_from_any {
    public Core.Type_string vx_extends_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_extends_from_typedef extends Core.Class_base implements Func_extends_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_extends_from_typedef output = new Core.Class_extends_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_extends_from_typedef output = new Core.Class_extends_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "extends<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_extends_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_extends_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_extends_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_extends_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_string vx_extends_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_string output = Core.f_extends_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_extends_from_typedef e_extends_from_typedef = new Core.Class_extends_from_typedef();
  public static final Core.Func_extends_from_typedef t_extends_from_typedef = new Core.Class_extends_from_typedef();

  public static Core.Type_string f_extends_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_string output = Core.e_string;
    output = vtypedef.extend();
    return output;
  }

  /**
   * @function first_from_list
   * Returns first value
   * @param  {list-1} values
   * @return {any-1}
   * (func first<-list)
   */
  public interface Func_first_from_list extends Core.Func_any_from_any {
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_first_from_list(final T generic_any_1, final X values);
  }

  public static class Class_first_from_list extends Core.Class_base implements Func_first_from_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_first_from_list output = new Core.Class_first_from_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_first_from_list output = new Core.Class_first_from_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "first<-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_first_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_first_from_list;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_first_from_list(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_first_from_list(generic_any_1, values);
      return output;
    }

    @Override
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_first_from_list(final T generic_any_1, final X values) {
      T output = Core.f_first_from_list(generic_any_1, values);
      return output;
    }

  }

  public static final Core.Func_first_from_list e_first_from_list = new Core.Class_first_from_list();
  public static final Core.Func_first_from_list t_first_from_list = new Core.Class_first_from_list();

  public static <T extends Core.Type_any, X extends Core.Type_list> T f_first_from_list(final T generic_any_1, final X values) {
    T output = Core.f_empty(generic_any_1);
    output = Core.f_any_from_list(
      generic_any_1,
      values,
      Core.vx_new_int(1)
    );
    return output;
  }

  /**
   * @function first_from_list_any_from_any
   * Returns first value that is not nothing
   * @param  {list-1} values
   * @param  {any<-any} fn-any<-any
   * @return {any-1}
   * (func first<-list-any<-any)
   */
  public interface Func_first_from_list_any_from_any extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_first_from_list_any_from_any(final T generic_any_1, final X values, final Core.Func_any_from_any fn_any_from_any);
  }

  public static class Class_first_from_list_any_from_any extends Core.Class_base implements Func_first_from_list_any_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_first_from_list_any_from_any output = new Core.Class_first_from_list_any_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_first_from_list_any_from_any output = new Core.Class_first_from_list_any_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "first<-list-any<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_first_from_list_any_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_first_from_list_any_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_any fn_any_from_any = Core.f_any_from_any(Core.t_any_from_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any);
      return output;
    }

    @Override
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_first_from_list_any_from_any(final T generic_any_1, final X values, final Core.Func_any_from_any fn_any_from_any) {
      T output = Core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any);
      return output;
    }

  }

  public static final Core.Func_first_from_list_any_from_any e_first_from_list_any_from_any = new Core.Class_first_from_list_any_from_any();
  public static final Core.Func_first_from_list_any_from_any t_first_from_list_any_from_any = new Core.Class_first_from_list_any_from_any();

  public static <T extends Core.Type_any, X extends Core.Type_list> T f_first_from_list_any_from_any(final T generic_any_1, final X values, final Core.Func_any_from_any fn_any_from_any) {
    T output = Core.f_empty(generic_any_1);
    List<Core.Type_any> listvalue = values.vx_list();
    for (Core.Type_any value : listvalue) {
      if (value != Core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value);
        break;
      }
    };
    return output;
  }

  /**
   * @function float_from_string
   * Returns float from a given string.
   * @param  {string} text
   * @return {float}
   * (func float<-string)
   */
  public interface Func_float_from_string extends Core.Func_any_from_any {
    public Core.Type_float vx_float_from_string(final Core.Type_string text);
  }

  public static class Class_float_from_string extends Core.Class_base implements Func_float_from_string {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_float_from_string output = new Core.Class_float_from_string();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_float_from_string output = new Core.Class_float_from_string();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "float<-string", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "float", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_float_from_string;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_float_from_string;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_float_from_string(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_float_from_string(text);
      return output;
    }

    @Override
    public Core.Type_float vx_float_from_string(final Core.Type_string text) {
      Core.Type_float output = Core.f_float_from_string(text);
      return output;
    }

  }

  public static final Core.Func_float_from_string e_float_from_string = new Core.Class_float_from_string();
  public static final Core.Func_float_from_string t_float_from_string = new Core.Class_float_from_string();

  public static Core.Type_float f_float_from_string(final Core.Type_string text) {
    Core.Type_float output = Core.e_float;
    float num = Core.vx_float_from_string(text.vx_string());
    output = Core.vx_new_float(num);
    return output;
  }

  /**
   * @function fn
   * Shell for lambda function calls
   * @param  {arglist} parameters
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func fn)
   */
  public interface Func_fn extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_fn(final T generic_any_1, final Core.Type_arglist parameters, final Core.Func_any_from_func fn_any);
  }

  public static class Class_fn extends Core.Class_base implements Func_fn {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_fn output = new Core.Class_fn();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_fn output = new Core.Class_fn();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "fn", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_fn;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_arglist parameters = Core.f_any_from_any(Core.t_arglist, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_fn(generic_any_1, parameters, fn_any);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_fn(final T generic_any_1, final Core.Type_arglist parameters, final Core.Func_any_from_func fn_any) {
      T output = Core.f_fn(generic_any_1, parameters, fn_any);
      return output;
    }

  }

  public static final Core.Func_fn e_fn = new Core.Class_fn();
  public static final Core.Func_fn t_fn = new Core.Class_fn();

  public static <T extends Core.Type_any> T f_fn(final T generic_any_1, final Core.Type_arglist parameters, final Core.Func_any_from_func fn_any) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function funcdef_from_func
   * Returns the definition of a function
   * @param  {func} value
   * @return {funcdef}
   * (func funcdef<-func)
   */
  public interface Func_funcdef_from_func extends Core.Func_any_from_any {
    public Core.Type_funcdef vx_funcdef_from_func(final Core.Type_func value);
  }

  public static class Class_funcdef_from_func extends Core.Class_base implements Func_funcdef_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_funcdef_from_func output = new Core.Class_funcdef_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_funcdef_from_func output = new Core.Class_funcdef_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "funcdef<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "funcdef", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_funcdef_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_funcdef_from_func;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_func inputval = (Core.Type_func)value;
      Core.Type_any outputval = Core.f_funcdef_from_func(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_func value = Core.f_any_from_any(Core.t_func, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_funcdef_from_func(value);
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef_from_func(final Core.Type_func value) {
      Core.Type_funcdef output = Core.f_funcdef_from_func(value);
      return output;
    }

  }

  public static final Core.Func_funcdef_from_func e_funcdef_from_func = new Core.Class_funcdef_from_func();
  public static final Core.Func_funcdef_from_func t_funcdef_from_func = new Core.Class_funcdef_from_func();

  public static Core.Type_funcdef f_funcdef_from_func(final Core.Type_func value) {
    Core.Type_funcdef output = Core.e_funcdef;
    output = value.vx_funcdef();
    return output;
  }

  /**
   * @function funcname_from_funcdef
   * Get the name of a given funcdef
   * @param  {funcdef} funcdef
   * @return {string}
   * (func funcname<-funcdef)
   */
  public interface Func_funcname_from_funcdef extends Core.Func_any_from_any {
    public Core.Type_string vx_funcname_from_funcdef(final Core.Type_funcdef funcdef);
  }

  public static class Class_funcname_from_funcdef extends Core.Class_base implements Func_funcname_from_funcdef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_funcname_from_funcdef output = new Core.Class_funcname_from_funcdef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_funcname_from_funcdef output = new Core.Class_funcname_from_funcdef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "funcname<-funcdef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_funcname_from_funcdef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_funcname_from_funcdef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_funcdef inputval = (Core.Type_funcdef)value;
      Core.Type_any outputval = Core.f_funcname_from_funcdef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_funcdef funcdef = Core.f_any_from_any(Core.t_funcdef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_funcname_from_funcdef(funcdef);
      return output;
    }

    @Override
    public Core.Type_string vx_funcname_from_funcdef(final Core.Type_funcdef funcdef) {
      Core.Type_string output = Core.f_funcname_from_funcdef(funcdef);
      return output;
    }

  }

  public static final Core.Func_funcname_from_funcdef e_funcname_from_funcdef = new Core.Class_funcname_from_funcdef();
  public static final Core.Func_funcname_from_funcdef t_funcname_from_funcdef = new Core.Class_funcname_from_funcdef();

  public static Core.Type_string f_funcname_from_funcdef(final Core.Type_funcdef funcdef) {
    Core.Type_string output = Core.e_string;
    output = Core.f_new(
      Core.t_string,
      Core.vx_new(
        Core.t_anylist,
        funcdef.pkgname(),
        Core.vx_new_string("/"),
        funcdef.name()
      )
    );
    return output;
  }

  /**
   * @function if
   * Logical If function
   * @param  {boolean} clause
   * @param  {any-1} then
   * @return {any-1}
   * (func if)
   */
  public interface Func_if extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_if(final T generic_any_1, final Core.Type_boolean clause, final T then);
  }

  public static class Class_if extends Core.Class_base implements Func_if {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_if output = new Core.Class_if();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_if output = new Core.Class_if();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_if;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_if;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_boolean clause = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any then = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_if(generic_any_1, clause, then);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_if(final T generic_any_1, final Core.Type_boolean clause, final T then) {
      T output = Core.f_if(generic_any_1, clause, then);
      return output;
    }

  }

  public static final Core.Func_if e_if = new Core.Class_if();
  public static final Core.Func_if t_if = new Core.Class_if();

  public static <T extends Core.Type_any> T f_if(final T generic_any_1, final Core.Type_boolean clause, final T then) {
    T output = Core.f_empty(generic_any_1);
    if (clause.vx_boolean()) {
      output = then;
    };
    return output;
  }

  /**
   * @function if 1
   * Logical If function
   * @param  {boolean} clause
   * @param  {any-1} thenval
   * @param  {any-1} elseval
   * @return {any-1}
   * (func if)
   */
  public interface Func_if_1 extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_if_1(final T generic_any_1, final Core.Type_boolean clause, final T thenval, final T elseval);
  }

  public static class Class_if_1 extends Core.Class_base implements Func_if_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_if_1 output = new Core.Class_if_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_if_1 output = new Core.Class_if_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_if_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_if_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_boolean clause = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any thenval = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_any elseval = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_if_1(generic_any_1, clause, thenval, elseval);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_if_1(final T generic_any_1, final Core.Type_boolean clause, final T thenval, final T elseval) {
      T output = Core.f_if_1(generic_any_1, clause, thenval, elseval);
      return output;
    }

  }

  public static final Core.Func_if_1 e_if_1 = new Core.Class_if_1();
  public static final Core.Func_if_1 t_if_1 = new Core.Class_if_1();

  public static <T extends Core.Type_any> T f_if_1(final T generic_any_1, final Core.Type_boolean clause, final T thenval, final T elseval) {
    T output = Core.f_empty(generic_any_1);
    if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    };
    return output;
  }

  /**
   * @function if 2
   * Logical If function
   * @param  {thenelselist} thenelselist
   * @return {any-1}
   * (func if)
   */
  public interface Func_if_2 extends Core.Func_any_from_any {
    public <T extends Core.Type_any> T vx_if_2(final T generic_any_1, final Core.Type_thenelselist thenelselist);
  }

  public static class Class_if_2 extends Core.Class_base implements Func_if_2 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_if_2 output = new Core.Class_if_2();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_if_2 output = new Core.Class_if_2();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        2, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_if_2;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_if_2;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_thenelselist inputval = (Core.Type_thenelselist)value;
      Core.Type_any outputval = Core.f_if_2(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_thenelselist thenelselist = Core.f_any_from_any(Core.t_thenelselist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_if_2(generic_any_1, thenelselist);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_if_2(final T generic_any_1, final Core.Type_thenelselist thenelselist) {
      T output = Core.f_if_2(generic_any_1, thenelselist);
      return output;
    }

  }

  public static final Core.Func_if_2 e_if_2 = new Core.Class_if_2();
  public static final Core.Func_if_2 t_if_2 = new Core.Class_if_2();

  public static <T extends Core.Type_any> T f_if_2(final T generic_any_1, final Core.Type_thenelselist thenelselist) {
    T output = Core.f_empty(generic_any_1);
    output = Core.vx_if_2(generic_any_1, thenelselist);
    return output;
  }

  /**
   * @function int_from_func
   * Function Type returning int with any parameters
   * @return {int}
   * (func int<-func)
   */
  public interface Func_int_from_func extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_int vx_int_from_func();
    public Core.Func_int_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public static class Class_int_from_func extends Core.Class_base implements Func_int_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_int_from_func output = new Core.Class_int_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_int_from_func output = new Core.Class_int_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "int<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_int_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_int_from_func;
      return output;
    }

    public Class_any_from_func.IFn fn = null;

    @Override
    public Core.Func_int_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Core.Class_int_from_func output = new Core.Class_int_from_func();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      output = Core.f_int_from_func();
      return output;
    }

    @Override
    public Core.Type_int vx_int_from_func() {
      Core.Type_int output = Core.f_int_from_func();
      return output;
    }

  }

  public static final Core.Func_int_from_func e_int_from_func = new Core.Class_int_from_func();
  public static final Core.Func_int_from_func t_int_from_func = new Core.Class_int_from_func();

  public static Core.Type_int f_int_from_func() {
    Core.Type_int output = Core.e_int;
    return output;
  }

  /**
   * @function int_from_string
   * Function Type converting string to int
   * @param  {string} value
   * @return {int}
   * (func int<-string)
   */
  public interface Func_int_from_string extends Core.Func_any_from_any {
    public Core.Type_int vx_int_from_string(final Core.Type_string value);
  }

  public static class Class_int_from_string extends Core.Class_base implements Func_int_from_string {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_int_from_string output = new Core.Class_int_from_string();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_int_from_string output = new Core.Class_int_from_string();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "int<-string", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_int_from_string;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_int_from_string;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_int_from_string(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string value = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_int_from_string(value);
      return output;
    }

    @Override
    public Core.Type_int vx_int_from_string(final Core.Type_string value) {
      Core.Type_int output = Core.f_int_from_string(value);
      return output;
    }

  }

  public static final Core.Func_int_from_string e_int_from_string = new Core.Class_int_from_string();
  public static final Core.Func_int_from_string t_int_from_string = new Core.Class_int_from_string();

  public static Core.Type_int f_int_from_string(final Core.Type_string value) {
    Core.Type_int output = Core.e_int;
    output = Core.f_switch(
      Core.t_int,
      value,
      Core.vx_new(
        Core.t_thenelselist,
        Core.f_case_1(
          Core.vx_new_string("notanumber"),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_1 = Core.c_notanumber;
            return output_1;
          })
        ),
        Core.f_case_1(
          Core.vx_new_string("infinity"),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_2 = Core.c_infinity;
            return output_2;
          })
        ),
        Core.f_case_1(
          Core.vx_new_string("neginfinity"),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_3 = Core.c_neginfinity;
            return output_3;
          })
        ),
        Core.f_else(
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_int intresult = Core.e_int;
            String strval = value.vx_string();
            try {
              float floatresult = Float.parseFloat(strval);
              int iresult = (int)floatresult;
              intresult = Core.vx_new_int(iresult);
            } catch (Exception ex) {
              intresult = Core.c_notanumber;
            }
            return intresult;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function is_empty
   * Returns true if text is empty.
   * @param  {string} text
   * @return {boolean}
   * (func is-empty)
   */
  public interface Func_is_empty extends Core.Func_any_from_any {
    public Core.Type_boolean vx_is_empty(final Core.Type_string text);
  }

  public static class Class_is_empty extends Core.Class_base implements Func_is_empty {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_empty output = new Core.Class_is_empty();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_empty output = new Core.Class_is_empty();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_empty;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_empty;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_is_empty(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_empty(text);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_empty(final Core.Type_string text) {
      Core.Type_boolean output = Core.f_is_empty(text);
      return output;
    }

  }

  public static final Core.Func_is_empty e_is_empty = new Core.Class_is_empty();
  public static final Core.Func_is_empty t_is_empty = new Core.Class_is_empty();

  public static Core.Type_boolean f_is_empty(final Core.Type_string text) {
    Core.Type_boolean output = Core.e_boolean;
    if (text.vx_string().length() == 0) {
      output = Core.c_true;
    };
    return output;
  }

  /**
   * @function is_empty 1
   * Returns true if an value is empty
   * @param  {any} value
   * @return {boolean}
   * (func is-empty)
   */
  public interface Func_is_empty_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_is_empty_1(final Core.Type_any value);
  }

  public static class Class_is_empty_1 extends Core.Class_base implements Func_is_empty_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_empty_1 output = new Core.Class_is_empty_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_empty_1 output = new Core.Class_is_empty_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_empty_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_empty_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_is_empty_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_empty_1(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_empty_1(final Core.Type_any value) {
      Core.Type_boolean output = Core.f_is_empty_1(value);
      return output;
    }

  }

  public static final Core.Func_is_empty_1 e_is_empty_1 = new Core.Class_is_empty_1();
  public static final Core.Func_is_empty_1 t_is_empty_1 = new Core.Class_is_empty_1();

  public static Core.Type_boolean f_is_empty_1(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    if (value == value.vx_empty()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    };
    return output;
  }

  /**
   * @function is_endswith
   * Returns true if text ends with find.
   * @param  {string} text
   * @param  {string} find
   * @return {boolean}
   * (func is-endswith)
   */
  public interface Func_is_endswith extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_is_endswith(final Core.Type_string text, final Core.Type_string find);
  }

  public static class Class_is_endswith extends Core.Class_base implements Func_is_endswith {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_endswith output = new Core.Class_is_endswith();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_endswith output = new Core.Class_is_endswith();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-endswith", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_endswith;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_endswith;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string find = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_is_endswith(text, find);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_endswith(final Core.Type_string text, final Core.Type_string find) {
      Core.Type_boolean output = Core.f_is_endswith(text, find);
      return output;
    }

  }

  public static final Core.Func_is_endswith e_is_endswith = new Core.Class_is_endswith();
  public static final Core.Func_is_endswith t_is_endswith = new Core.Class_is_endswith();

  public static Core.Type_boolean f_is_endswith(final Core.Type_string text, final Core.Type_string find) {
    Core.Type_boolean output = Core.e_boolean;
    String stext = text.vx_string();
    String sfind = find.vx_string();
    if (stext.endsWith(sfind)) {
      output = Core.c_true;
    };
    return output;
  }

  /**
   * @function is_float
   * Returns true if the value is a float.
   * @param  {any} value
   * @return {boolean}
   * (func is-float)
   */
  public interface Func_is_float extends Core.Func_any_from_any {
    public Core.Type_boolean vx_is_float(final Core.Type_any value);
  }

  public static class Class_is_float extends Core.Class_base implements Func_is_float {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_float output = new Core.Class_is_float();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_float output = new Core.Class_is_float();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-float", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_float;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_float;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_is_float(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_float(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_float(final Core.Type_any value) {
      Core.Type_boolean output = Core.f_is_float(value);
      return output;
    }

  }

  public static final Core.Func_is_float e_is_float = new Core.Class_is_float();
  public static final Core.Func_is_float t_is_float = new Core.Class_is_float();

  public static Core.Type_boolean f_is_float(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    boolean result = Core.vx_is_float(value);
    output = Core.vx_new_boolean(result);
    return output;
  }

  /**
   * @function is_func
   * Returns true if value is a function.
   * @param  {any} value
   * @return {boolean}
   * (func is-func)
   */
  public interface Func_is_func extends Core.Func_any_from_any {
    public Core.Type_boolean vx_is_func(final Core.Type_any value);
  }

  public static class Class_is_func extends Core.Class_base implements Func_is_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_func output = new Core.Class_is_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_func output = new Core.Class_is_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_func;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_is_func(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_func(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_func(final Core.Type_any value) {
      Core.Type_boolean output = Core.f_is_func(value);
      return output;
    }

  }

  public static final Core.Func_is_func e_is_func = new Core.Class_is_func();
  public static final Core.Func_is_func t_is_func = new Core.Class_is_func();

  public static Core.Type_boolean f_is_func(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    if (value instanceof Core.Type_func) {
      output = Core.c_true;
    };
    return output;
  }

  /**
   * @function is_int
   * Returns true if the value is an integer.
   * @param  {any} value
   * @return {boolean}
   * (func is-int)
   */
  public interface Func_is_int extends Core.Func_any_from_any {
    public Core.Type_boolean vx_is_int(final Core.Type_any value);
  }

  public static class Class_is_int extends Core.Class_base implements Func_is_int {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_int output = new Core.Class_is_int();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_int output = new Core.Class_is_int();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-int", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_int;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_int;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_is_int(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_int(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_int(final Core.Type_any value) {
      Core.Type_boolean output = Core.f_is_int(value);
      return output;
    }

  }

  public static final Core.Func_is_int e_is_int = new Core.Class_is_int();
  public static final Core.Func_is_int t_is_int = new Core.Class_is_int();

  public static Core.Type_boolean f_is_int(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    boolean result = Core.vx_is_int(value);
    output = Core.vx_new_boolean(result);
    return output;
  }

  /**
   * @function is_number
   * Return true if value is a number
   * @param  {any} value
   * @return {boolean}
   * (func is-number)
   */
  public interface Func_is_number extends Core.Func_any_from_any {
    public Core.Type_boolean vx_is_number(final Core.Type_any value);
  }

  public static class Class_is_number extends Core.Class_base implements Func_is_number {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_number output = new Core.Class_is_number();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_number output = new Core.Class_is_number();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-number", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_number;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_number;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_is_number(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_number(value);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_number(final Core.Type_any value) {
      Core.Type_boolean output = Core.f_is_number(value);
      return output;
    }

  }

  public static final Core.Func_is_number e_is_number = new Core.Class_is_number();
  public static final Core.Func_is_number t_is_number = new Core.Class_is_number();

  public static Core.Type_boolean f_is_number(final Core.Type_any value) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_switch(
      Core.t_boolean,
      Core.f_typename_from_any(
        value
      ),
      Core.vx_new(
        Core.t_thenelselist,
        Core.f_case(
          Core.f_new(
            Core.t_list,
            Core.vx_new(
              Core.t_anylist,
              Core.vx_new_string("vx/core/decimal"),
              Core.vx_new_string("vx/core/float"),
              Core.vx_new_string("vx/core/int"),
              Core.vx_new_string("vx/core/number")
            )
          ),
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_1 = Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Core.f_else(
          Core.t_any_from_func.vx_fn_new(() -> {
            Core.Type_any output_2 = Core.vx_new_boolean(false);
            return output_2;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function is_pass_from_permission
   * Returns true if permission passes.
   * @param  {permission} permission
   * @return {boolean}
   * (func is-pass<-permission)
   */
  public interface Func_is_pass_from_permission extends Core.Func_any_from_any_context {
    public Core.Type_boolean vx_is_pass_from_permission(final Core.Type_context context, final Core.Type_permission permission);
  }

  public static class Class_is_pass_from_permission extends Core.Class_base implements Func_is_pass_from_permission {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_is_pass_from_permission output = new Core.Class_is_pass_from_permission();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_is_pass_from_permission output = new Core.Class_is_pass_from_permission();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "is-pass<-permission", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_is_pass_from_permission;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_is_pass_from_permission;
      return output;
    }

    @Override
    public Core.Func_any_from_any_context vx_fn_new(Core.Class_any_from_any_context.IFn fn) {
      return Core.e_any_from_any_context;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_permission inputval = (Core.Type_permission)value;
      Core.Type_any outputval = Core.f_is_pass_from_permission(context, inputval);
      output = Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_permission permission = Core.f_any_from_any(Core.t_permission, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_is_pass_from_permission(context, permission);
      return output;
    }

    @Override
    public Core.Type_boolean vx_is_pass_from_permission(final Core.Type_context context, final Core.Type_permission permission) {
      Core.Type_boolean output = Core.f_is_pass_from_permission(context, permission);
      return output;
    }

  }

  public static final Core.Func_is_pass_from_permission e_is_pass_from_permission = new Core.Class_is_pass_from_permission();
  public static final Core.Func_is_pass_from_permission t_is_pass_from_permission = new Core.Class_is_pass_from_permission();

  public static Core.Type_boolean f_is_pass_from_permission(final Core.Type_context context, final Core.Type_permission permission) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_let(
      Core.t_boolean,
      Core.t_any_from_func.vx_fn_new(() -> {
        Core.Type_string id = permission.id();
        Core.Type_permission lookup = Core.f_permission_from_id_context(
          context,
          id
        );
        Core.Type_any output_1 = Core.f_eq(
          lookup,
          permission
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function last_from_list
   * Returns last value
   * @param  {list-1} values
   * @return {any-1}
   * (func last<-list)
   */
  public interface Func_last_from_list extends Core.Func_any_from_any {
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_last_from_list(final T generic_any_1, final X values);
  }

  public static class Class_last_from_list extends Core.Class_base implements Func_last_from_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_last_from_list output = new Core.Class_last_from_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_last_from_list output = new Core.Class_last_from_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "last<-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_last_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_last_from_list;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_last_from_list(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_last_from_list(generic_any_1, values);
      return output;
    }

    @Override
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_last_from_list(final T generic_any_1, final X values) {
      T output = Core.f_last_from_list(generic_any_1, values);
      return output;
    }

  }

  public static final Core.Func_last_from_list e_last_from_list = new Core.Class_last_from_list();
  public static final Core.Func_last_from_list t_last_from_list = new Core.Class_last_from_list();

  public static <T extends Core.Type_any, X extends Core.Type_list> T f_last_from_list(final T generic_any_1, final X values) {
    T output = Core.f_empty(generic_any_1);
    output = Core.f_let(
      generic_any_1,
      Core.t_any_from_func.vx_fn_new(() -> {
        Core.Type_int len = Core.f_length_1(
          values
        );
        Core.Type_any output_1 = Core.f_any_from_list(
          generic_any_1,
          values,
          len
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function length
   * Returns length of a string.
   * @param  {string} text
   * @return {int}
   * (func length)
   */
  public interface Func_length extends Core.Func_any_from_any {
    public Core.Type_int vx_length(final Core.Type_string text);
  }

  public static class Class_length extends Core.Class_base implements Func_length {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_length output = new Core.Class_length();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_length output = new Core.Class_length();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_length;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_length;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_length(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_length(text);
      return output;
    }

    @Override
    public Core.Type_int vx_length(final Core.Type_string text) {
      Core.Type_int output = Core.f_length(text);
      return output;
    }

  }

  public static final Core.Func_length e_length = new Core.Class_length();
  public static final Core.Func_length t_length = new Core.Class_length();

  public static Core.Type_int f_length(final Core.Type_string text) {
    Core.Type_int output = Core.e_int;
    int len = text.vx_string().length();
    output = Core.vx_new_int(len);
    return output;
  }

  /**
   * @function length 1
   * Returns the currently used size/length of a list
   * @param  {list-1} values
   * @return {int}
   * (func length)
   */
  public interface Func_length_1 extends Core.Func_any_from_any {
    public Core.Type_int vx_length_1(final Core.Type_list values);
  }

  public static class Class_length_1 extends Core.Class_base implements Func_length_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_length_1 output = new Core.Class_length_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_length_1 output = new Core.Class_length_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_length_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_length_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_length_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_length_1(values);
      return output;
    }

    @Override
    public Core.Type_int vx_length_1(final Core.Type_list values) {
      Core.Type_int output = Core.f_length_1(values);
      return output;
    }

  }

  public static final Core.Func_length_1 e_length_1 = new Core.Class_length_1();
  public static final Core.Func_length_1 t_length_1 = new Core.Class_length_1();

  public static Core.Type_int f_length_1(final Core.Type_list values) {
    Core.Type_int output = Core.e_int;
    int intresult = values.vx_list().size();
    output = Core.vx_new_int(intresult);
    return output;
  }

  /**
   * @function length 2
   * Returns the length of the given map.
   * @param  {map-1} valuemap
   * @return {int}
   * (func length)
   */
  public interface Func_length_2 extends Core.Func_any_from_any {
    public Core.Type_int vx_length_2(final Core.Type_map valuemap);
  }

  public static class Class_length_2 extends Core.Class_base implements Func_length_2 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_length_2 output = new Core.Class_length_2();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_length_2 output = new Core.Class_length_2();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        2, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Core.vx_new(Core.t_typelist, Core.t_number), // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_length_2;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_length_2;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_map inputval = (Core.Type_map)value;
      Core.Type_any outputval = Core.f_length_2(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_length_2(valuemap);
      return output;
    }

    @Override
    public Core.Type_int vx_length_2(final Core.Type_map valuemap) {
      Core.Type_int output = Core.f_length_2(valuemap);
      return output;
    }

  }

  public static final Core.Func_length_2 e_length_2 = new Core.Class_length_2();
  public static final Core.Func_length_2 t_length_2 = new Core.Class_length_2();

  public static Core.Type_int f_length_2(final Core.Type_map valuemap) {
    Core.Type_int output = Core.e_int;
    output = Core.f_length_1(
      Core.f_stringlist_from_map(
        valuemap
      )
    );
    return output;
  }

  /**
   * @function let
   * @param  {arglist} args
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func let)
   */
  public interface Func_let extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_let(final T generic_any_1, final Core.Func_any_from_func fn_any);
  }

  public static class Class_let extends Core.Class_base implements Func_let {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_let output = new Core.Class_let();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_let output = new Core.Class_let();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "let", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_let;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_let;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_let(generic_any_1, fn_any);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_let(final T generic_any_1, final Core.Func_any_from_func fn_any) {
      T output = Core.f_let(generic_any_1, fn_any);
      return output;
    }

  }

  public static final Core.Func_let e_let = new Core.Class_let();
  public static final Core.Func_let t_let = new Core.Class_let();

  public static <T extends Core.Type_any> T f_let(final T generic_any_1, final Core.Func_any_from_func fn_any) {
    T output = Core.f_empty(generic_any_1);
    output = fn_any.vx_any_from_func(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function let_async
   * Same as normal let but returns async values.
   * @param  {arglist} args
   * @param  {any<-func-async} fn-any-async
   * @return {any-1}
   * (func let-async)
   */
  public interface Func_let_async extends Core.Type_func, Core.Type_replfunc_async {
    public <T extends Core.Type_any> CompletableFuture<T> vx_let_async(final T generic_any_1, final Core.Func_any_from_func_async fn_any_async);
  }

  public static class Class_let_async extends Core.Class_base implements Func_let_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_let_async output = new Core.Class_let_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_let_async output = new Core.Class_let_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "let-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_let_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_let_async;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func_async fn_any_async = Core.f_any_from_any(Core.t_any_from_func_async, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_let_async(generic_any_1, fn_any_async);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any> CompletableFuture<T> vx_let_async(final T generic_any_1, final Core.Func_any_from_func_async fn_any_async) {
      CompletableFuture<T> output = Core.f_let_async(generic_any_1, fn_any_async);
      return output;
    }

  }

  public static final Core.Func_let_async e_let_async = new Core.Class_let_async();
  public static final Core.Func_let_async t_let_async = new Core.Class_let_async();

  public static <T extends Core.Type_any> CompletableFuture<T> f_let_async(final T generic_any_1, final Core.Func_any_from_func_async fn_any_async) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    output = fn_any_async.vx_any_from_func_async(generic_any_1);
    return output;
  }

  /**
   * @function list_join_from_list
   * Returns a list by joining the valid values in each value list
   * @param  {list-2} values
   * @return {list-1}
   * (func list-join<-list)
   */
  public interface Func_list_join_from_list extends Core.Func_any_from_any {
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_join_from_list(final X generic_list_1, final Y values);
  }

  public static class Class_list_join_from_list extends Core.Class_base implements Func_list_join_from_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_join_from_list output = new Core.Class_list_join_from_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_join_from_list output = new Core.Class_list_join_from_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_join_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_join_from_list;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_list_join_from_list(Core.t_list, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_list_join_from_list(generic_list_1, values);
      return output;
    }

    @Override
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_join_from_list(final X generic_list_1, final Y values) {
      X output = Core.f_list_join_from_list(generic_list_1, values);
      return output;
    }

  }

  public static final Core.Func_list_join_from_list e_list_join_from_list = new Core.Class_list_join_from_list();
  public static final Core.Func_list_join_from_list t_list_join_from_list = new Core.Class_list_join_from_list();

  public static <X extends Core.Type_list, Y extends Core.Type_list> X f_list_join_from_list(final X generic_list_1, final Y values) {
    X output = Core.f_empty(generic_list_1);
    output = Core.f_list_join_from_list_1(
      generic_list_1,
      values,
      Core.t_any_from_any.vx_fn_new((value_any) -> {
        Core.Type_any value = Core.f_any_from_any(Core.t_any, value_any);
        Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function list_join_from_list 1
   * Returns a flattened list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-any} fn-any<-any
   * @return {list-1}
   * (func list-join<-list)
   */
  public interface Func_list_join_from_list_1 extends Core.Type_func, Core.Type_replfunc {
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_join_from_list_1(final X generic_list_1, final Y values, final Core.Func_any_from_any fn_any_from_any);
  }

  public static class Class_list_join_from_list_1 extends Core.Class_base implements Func_list_join_from_list_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_join_from_list_1 output = new Core.Class_list_join_from_list_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_join_from_list_1 output = new Core.Class_list_join_from_list_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_join_from_list_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_join_from_list_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_any fn_any_from_any = Core.f_any_from_any(Core.t_any_from_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

    @Override
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_join_from_list_1(final X generic_list_1, final Y values, final Core.Func_any_from_any fn_any_from_any) {
      X output = Core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

  }

  public static final Core.Func_list_join_from_list_1 e_list_join_from_list_1 = new Core.Class_list_join_from_list_1();
  public static final Core.Func_list_join_from_list_1 t_list_join_from_list_1 = new Core.Class_list_join_from_list_1();

  public static <X extends Core.Type_list, Y extends Core.Type_list> X f_list_join_from_list_1(final X generic_list_1, final Y values, final Core.Func_any_from_any fn_any_from_any) {
    X output = Core.f_empty(generic_list_1);
    List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = new ArrayList<>();
    for (Core.Type_any val : list_value) {
      Core.Type_any listoflist = fn_any_from_any.vx_any_from_any(generic_list_1, val);
      if (listoflist instanceof Core.Type_list) {
        Core.Type_list vallist = (Core.Type_list)listoflist;
        List<Core.Type_any> listval = vallist.vx_list();
        list_result.addAll(listval);
      }
    }
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
    return output;
  }

  /**
   * @function list_from_list
   * Return a list with allowed values from another list
   * @param  {list-2} values
   * @return {list-1}
   * (func list<-list)
   */
  public interface Func_list_from_list extends Core.Func_any_from_any {
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_from_list(final X generic_list_1, final Y values);
  }

  public static class Class_list_from_list extends Core.Class_base implements Func_list_from_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_list output = new Core.Class_list_from_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_list output = new Core.Class_list_from_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_list;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_list_from_list(Core.t_list, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_list_from_list(generic_list_1, values);
      return output;
    }

    @Override
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_from_list(final X generic_list_1, final Y values) {
      X output = Core.f_list_from_list(generic_list_1, values);
      return output;
    }

  }

  public static final Core.Func_list_from_list e_list_from_list = new Core.Class_list_from_list();
  public static final Core.Func_list_from_list t_list_from_list = new Core.Class_list_from_list();

  public static <X extends Core.Type_list, Y extends Core.Type_list> X f_list_from_list(final X generic_list_1, final Y values) {
    X output = Core.f_empty(generic_list_1);
    output = Core.f_list_from_list_1(
      generic_list_1,
      values,
      Core.t_any_from_any.vx_fn_new((value_any) -> {
        Core.Type_any value = Core.f_any_from_any(Core.t_any, value_any);
        Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function list_from_list 1
   * Returns a list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-any} fn-any<-any
   * @return {list-1}
   * (func list<-list)
   */
  public interface Func_list_from_list_1 extends Core.Type_func, Core.Type_replfunc {
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_from_list_1(final X generic_list_1, final Y values, final Core.Func_any_from_any fn_any_from_any);
  }

  public static class Class_list_from_list_1 extends Core.Class_base implements Func_list_from_list_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_list_1 output = new Core.Class_list_from_list_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_list_1 output = new Core.Class_list_from_list_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_list_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_list_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_any fn_any_from_any = Core.f_any_from_any(Core.t_any_from_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_list_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

    @Override
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_from_list_1(final X generic_list_1, final Y values, final Core.Func_any_from_any fn_any_from_any) {
      X output = Core.f_list_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

  }

  public static final Core.Func_list_from_list_1 e_list_from_list_1 = new Core.Class_list_from_list_1();
  public static final Core.Func_list_from_list_1 t_list_from_list_1 = new Core.Class_list_from_list_1();

  public static <X extends Core.Type_list, Y extends Core.Type_list> X f_list_from_list_1(final X generic_list_1, final Y values, final Core.Func_any_from_any fn_any_from_any) {
    X output = Core.f_empty(generic_list_1);
    List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any.vx_any_from_any(generic_list_1, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
    return output;
  }

  /**
   * 
   * @async
   * @function list_from_list_async
   * Returns an asynchronous list of the processed asynchronous items from another list
   * @param  {list-2} values
   * @param  {any<-any-async} fn-any<-any-async
   * @return {list-1}
   * (func list<-list-async)
   */
  public interface Func_list_from_list_async extends Core.Type_func, Core.Type_replfunc_async {
    public <X extends Core.Type_list, Y extends Core.Type_list> CompletableFuture<X> vx_list_from_list_async(final X generic_list_1, final Y values, final Core.Func_any_from_any_async fn_any_from_any_async);
  }

  public static class Class_list_from_list_async extends Core.Class_base implements Func_list_from_list_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_list_async output = new Core.Class_list_from_list_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_list_async output = new Core.Class_list_from_list_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_list_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_list_async;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_any_async fn_any_from_any_async = Core.f_any_from_any(Core.t_any_from_any_async, arglist.vx_any(Core.vx_new_int(1)));
      CompletableFuture<Core.Type_list> future = Core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <X extends Core.Type_list, Y extends Core.Type_list> CompletableFuture<X> vx_list_from_list_async(final X generic_list_1, final Y values, final Core.Func_any_from_any_async fn_any_from_any_async) {
      CompletableFuture<X> output = Core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
      return output;
    }

  }

  public static final Core.Func_list_from_list_async e_list_from_list_async = new Core.Class_list_from_list_async();
  public static final Core.Func_list_from_list_async t_list_from_list_async = new Core.Class_list_from_list_async();

  public static <X extends Core.Type_list, Y extends Core.Type_list> CompletableFuture<X> f_list_from_list_async(final X generic_list_1, final Y values, final Core.Func_any_from_any_async fn_any_from_any_async) {
    CompletableFuture<X> output = Core.vx_async_new_from_value(Core.f_empty(generic_list_1));
    output = Core.vx_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
    return output;
  }

  /**
   * @function list_from_list_intany
   * Returns a list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-int-any} fn-any<-int-any
   * @return {list-1}
   * (func list<-list-intany)
   */
  public interface Func_list_from_list_intany extends Core.Type_func, Core.Type_replfunc {
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_from_list_intany(final X generic_list_1, final Y values, final Core.Func_any_from_int_any fn_any_from_int_any);
  }

  public static class Class_list_from_list_intany extends Core.Class_base implements Func_list_from_list_intany {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_list_intany output = new Core.Class_list_from_list_intany();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_list_intany output = new Core.Class_list_from_list_intany();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-intany", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_list_intany;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_list_intany;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list values = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_int_any fn_any_from_int_any = Core.f_any_from_any(Core.t_any_from_int_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
      return output;
    }

    @Override
    public <X extends Core.Type_list, Y extends Core.Type_list> X vx_list_from_list_intany(final X generic_list_1, final Y values, final Core.Func_any_from_int_any fn_any_from_int_any) {
      X output = Core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
      return output;
    }

  }

  public static final Core.Func_list_from_list_intany e_list_from_list_intany = new Core.Class_list_from_list_intany();
  public static final Core.Func_list_from_list_intany t_list_from_list_intany = new Core.Class_list_from_list_intany();

  public static <X extends Core.Type_list, Y extends Core.Type_list> X f_list_from_list_intany(final X generic_list_1, final Y values, final Core.Func_any_from_int_any fn_any_from_int_any) {
    X output = Core.f_empty(generic_list_1);
    output = Core.vx_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
    return output;
  }

  /**
   * @function list_from_map
   * Returns a list of allowed values from a map.
   * @param  {map-2} valuemap
   * @return {list-1}
   * (func list<-map)
   */
  public interface Func_list_from_map extends Core.Func_any_from_any {
    public <O extends Core.Type_map, X extends Core.Type_list> X vx_list_from_map(final X generic_list_1, final O valuemap);
  }

  public static class Class_list_from_map extends Core.Class_base implements Func_list_from_map {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_map output = new Core.Class_list_from_map();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_map output = new Core.Class_list_from_map();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_map;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_map;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_map inputval = (Core.Type_map)value;
      Core.Type_any outputval = Core.f_list_from_map(Core.t_list, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_list_from_map(generic_list_1, valuemap);
      return output;
    }

    @Override
    public <O extends Core.Type_map, X extends Core.Type_list> X vx_list_from_map(final X generic_list_1, final O valuemap) {
      X output = Core.f_list_from_map(generic_list_1, valuemap);
      return output;
    }

  }

  public static final Core.Func_list_from_map e_list_from_map = new Core.Class_list_from_map();
  public static final Core.Func_list_from_map t_list_from_map = new Core.Class_list_from_map();

  public static <O extends Core.Type_map, X extends Core.Type_list> X f_list_from_map(final X generic_list_1, final O valuemap) {
    X output = Core.f_empty(generic_list_1);
    output = Core.f_list_from_map_1(
      generic_list_1,
      valuemap,
      Core.t_any_from_key_value.vx_fn_new((key_any, value_any) -> {
        Core.Type_string key = Core.f_any_from_any(Core.t_string, key_any);
        Core.Type_any value = Core.f_any_from_any(Core.t_any, value_any);
        Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function list_from_map 1
   * Returns a list from a map by applying a function to each key value.
   * @param  {map-2} valuemap
   * @param  {any<-key-value} fn-any<-key-value
   * @return {list-1}
   * (func list<-map)
   */
  public interface Func_list_from_map_1 extends Core.Type_func, Core.Type_replfunc {
    public <O extends Core.Type_map, X extends Core.Type_list> X vx_list_from_map_1(final X generic_list_1, final O valuemap, final Core.Func_any_from_key_value fn_any_from_key_value);
  }

  public static class Class_list_from_map_1 extends Core.Class_base implements Func_list_from_map_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_map_1 output = new Core.Class_list_from_map_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_map_1 output = new Core.Class_list_from_map_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_map_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_map_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_key_value fn_any_from_key_value = Core.f_any_from_any(Core.t_any_from_key_value, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value);
      return output;
    }

    @Override
    public <O extends Core.Type_map, X extends Core.Type_list> X vx_list_from_map_1(final X generic_list_1, final O valuemap, final Core.Func_any_from_key_value fn_any_from_key_value) {
      X output = Core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value);
      return output;
    }

  }

  public static final Core.Func_list_from_map_1 e_list_from_map_1 = new Core.Class_list_from_map_1();
  public static final Core.Func_list_from_map_1 t_list_from_map_1 = new Core.Class_list_from_map_1();

  public static <O extends Core.Type_map, X extends Core.Type_list> X f_list_from_map_1(final X generic_list_1, final O valuemap, final Core.Func_any_from_key_value fn_any_from_key_value) {
    X output = Core.f_empty(generic_list_1);
    Map<String, Core.Type_any> map_value = valuemap.vx_map();
    List<Core.Type_any> listresult = Core.arraylist_from_linkedhashmap_fn(map_value, (key, val) -> {
      Core.Type_string valkey = Core.vx_new_string(key);
      return fn_any_from_key_value.vx_any_from_key_value(Core.t_any, valkey, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(listresult));
    return output;
  }

  /**
   * 
   * @async
   * @function list_from_map_async
   * @param  {map-2} valuemap
   * @param  {any<-key-value-async} fn-any<-key-value-async
   * @return {list-1}
   * (func list<-map-async)
   */
  public interface Func_list_from_map_async extends Core.Type_func, Core.Type_replfunc_async {
    public <O extends Core.Type_map, X extends Core.Type_list> CompletableFuture<X> vx_list_from_map_async(final X generic_list_1, final O valuemap, final Core.Func_any_from_key_value_async fn_any_from_key_value_async);
  }

  public static class Class_list_from_map_async extends Core.Class_base implements Func_list_from_map_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_map_async output = new Core.Class_list_from_map_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_map_async output = new Core.Class_list_from_map_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-map-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_map_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_map_async;
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_key_value_async fn_any_from_key_value_async = Core.f_any_from_any(Core.t_any_from_key_value_async, arglist.vx_any(Core.vx_new_int(1)));
      CompletableFuture<Core.Type_list> future = Core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <O extends Core.Type_map, X extends Core.Type_list> CompletableFuture<X> vx_list_from_map_async(final X generic_list_1, final O valuemap, final Core.Func_any_from_key_value_async fn_any_from_key_value_async) {
      CompletableFuture<X> output = Core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async);
      return output;
    }

  }

  public static final Core.Func_list_from_map_async e_list_from_map_async = new Core.Class_list_from_map_async();
  public static final Core.Func_list_from_map_async t_list_from_map_async = new Core.Class_list_from_map_async();

  public static <O extends Core.Type_map, X extends Core.Type_list> CompletableFuture<X> f_list_from_map_async(final X generic_list_1, final O valuemap, final Core.Func_any_from_key_value_async fn_any_from_key_value_async) {
    CompletableFuture<X> output = Core.vx_async_new_from_value(Core.f_empty(generic_list_1));
    return output;
  }

  /**
   * @function list_from_type
   * Create an empty list from a type. Used internally for default lists
   * @param  {any} type
   * @return {any}
   * (func list<-type)
   */
  public interface Func_list_from_type extends Core.Func_any_from_any {
    public Core.Type_any vx_list_from_type(final Core.Type_any type);
  }

  public static class Class_list_from_type extends Core.Class_base implements Func_list_from_type {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_list_from_type output = new Core.Class_list_from_type();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_list_from_type output = new Core.Class_list_from_type();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "list<-type", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_list_from_type;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_list_from_type;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_list_from_type(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any type = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_list_from_type(type);
      return output;
    }

    @Override
    public Core.Type_any vx_list_from_type(final Core.Type_any type) {
      Core.Type_any output = Core.f_list_from_type(type);
      return output;
    }

  }

  public static final Core.Func_list_from_type e_list_from_type = new Core.Class_list_from_type();
  public static final Core.Func_list_from_type t_list_from_type = new Core.Class_list_from_type();

  public static Core.Type_any f_list_from_type(final Core.Type_any type) {
    Core.Type_any output = Core.e_any;
    return output;
  }

  /**
   * @function log
   * Writes a value to the console.
   * @param  {any} value
   * @return {any}
   * (func log)
   */
  public interface Func_log extends Core.Func_any_from_any {
    public Core.Type_any vx_log(final Core.Type_any value);
  }

  public static class Class_log extends Core.Class_base implements Func_log {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_log output = new Core.Class_log();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_log output = new Core.Class_log();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_log;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_log;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_log(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_log(value);
      return output;
    }

    @Override
    public Core.Type_any vx_log(final Core.Type_any value) {
      Core.Type_any output = Core.f_log(value);
      return output;
    }

  }

  public static final Core.Func_log e_log = new Core.Class_log();
  public static final Core.Func_log t_log = new Core.Class_log();

  public static Core.Type_any f_log(final Core.Type_any value) {
    Core.Type_any output = Core.e_any;
    Core.vx_log(value);
    output = value;
    return output;
  }

  /**
   * @function log 1
   * Writes a string and a value to the console.
   * @param  {string} text
   * @param  {any-1} value
   * @return {any-1}
   * (func log)
   */
  public interface Func_log_1 extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_log_1(final T generic_any_1, final Core.Type_string text, final T value);
  }

  public static class Class_log_1 extends Core.Class_base implements Func_log_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_log_1 output = new Core.Class_log_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_log_1 output = new Core.Class_log_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_log_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_log_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_log_1(generic_any_1, text, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_log_1(final T generic_any_1, final Core.Type_string text, final T value) {
      T output = Core.f_log_1(generic_any_1, text, value);
      return output;
    }

  }

  public static final Core.Func_log_1 e_log_1 = new Core.Class_log_1();
  public static final Core.Func_log_1 t_log_1 = new Core.Class_log_1();

  public static <T extends Core.Type_any> T f_log_1(final T generic_any_1, final Core.Type_string text, final T value) {
    T output = Core.f_empty(generic_any_1);
    Core.vx_log(text);
    Core.vx_log(value);
    output = value;
    return output;
  }

  /**
   * @function main
   * The default function for app main execution. Arguments come from the command line.
   * @param  {anylist} args
   * @return {string}
   * (func main)
   */
  public interface Func_main extends Core.Func_any_from_any {
    public Core.Type_string vx_main(final Core.Type_anylist args);
  }

  public static class Class_main extends Core.Class_base implements Func_main {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_main output = new Core.Class_main();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_main output = new Core.Class_main();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "main", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_main;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_main;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_main(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_anylist args = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_main(args);
      return output;
    }

    @Override
    public Core.Type_string vx_main(final Core.Type_anylist args) {
      Core.Type_string output = Core.f_main(args);
      return output;
    }

  }

  public static final Core.Func_main e_main = new Core.Class_main();
  public static final Core.Func_main t_main = new Core.Class_main();

  public static Core.Type_string f_main(final Core.Type_anylist args) {
    Core.Type_string output = Core.e_string;
    output = Core.f_new(
      Core.t_string,
      args
    );
    return output;
  }

  /**
   * @function map_from_list
   * Returns a map from a list by applying a function to generate a key for each value.
   * @param  {list-2} vallist
   * @param  {any<-any} fn-any<-any
   * @return {map-1}
   * (func map<-list)
   */
  public interface Func_map_from_list extends Core.Type_func, Core.Type_replfunc {
    public <N extends Core.Type_map, Y extends Core.Type_list> N vx_map_from_list(final N generic_map_1, final Y vallist, final Core.Func_any_from_any fn_any_from_any);
  }

  public static class Class_map_from_list extends Core.Class_base implements Func_map_from_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_map_from_list output = new Core.Class_map_from_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_map_from_list output = new Core.Class_map_from_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "map<-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_map_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_map_from_list;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_map generic_map_1 = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list vallist = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_any fn_any_from_any = Core.f_any_from_any(Core.t_any_from_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_map_from_list(generic_map_1, vallist, fn_any_from_any);
      return output;
    }

    @Override
    public <N extends Core.Type_map, Y extends Core.Type_list> N vx_map_from_list(final N generic_map_1, final Y vallist, final Core.Func_any_from_any fn_any_from_any) {
      N output = Core.f_map_from_list(generic_map_1, vallist, fn_any_from_any);
      return output;
    }

  }

  public static final Core.Func_map_from_list e_map_from_list = new Core.Class_map_from_list();
  public static final Core.Func_map_from_list t_map_from_list = new Core.Class_map_from_list();

  public static <N extends Core.Type_map, Y extends Core.Type_list> N f_map_from_list(final N generic_map_1, final Y vallist, final Core.Func_any_from_any fn_any_from_any) {
    N output = Core.f_empty(generic_map_1);
    List<Core.Type_any> listval = vallist.vx_list();
    Map<String, Core.Type_any> mapresult = Core.vx_map_from_list_fn(listval, (val) -> {
      return fn_any_from_any.vx_any_from_any(Core.t_string, val);
    });
    output = Core.f_any_from_any(generic_map_1, output.vx_new_from_map(mapresult));
    return output;
  }

  /**
   * @function map_from_map
   * Return a map with allowed values from another map
   * @param  {map-2} valuemap
   * @return {map-1}
   * (func map<-map)
   */
  public interface Func_map_from_map extends Core.Func_any_from_any {
    public <N extends Core.Type_map, O extends Core.Type_map> N vx_map_from_map(final N generic_map_1, final O valuemap);
  }

  public static class Class_map_from_map extends Core.Class_base implements Func_map_from_map {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_map_from_map output = new Core.Class_map_from_map();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_map_from_map output = new Core.Class_map_from_map();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_map_from_map;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_map_from_map;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_map inputval = (Core.Type_map)value;
      Core.Type_any outputval = Core.f_map_from_map(Core.t_map, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_map generic_map_1 = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_map_from_map(generic_map_1, valuemap);
      return output;
    }

    @Override
    public <N extends Core.Type_map, O extends Core.Type_map> N vx_map_from_map(final N generic_map_1, final O valuemap) {
      N output = Core.f_map_from_map(generic_map_1, valuemap);
      return output;
    }

  }

  public static final Core.Func_map_from_map e_map_from_map = new Core.Class_map_from_map();
  public static final Core.Func_map_from_map t_map_from_map = new Core.Class_map_from_map();

  public static <N extends Core.Type_map, O extends Core.Type_map> N f_map_from_map(final N generic_map_1, final O valuemap) {
    N output = Core.f_empty(generic_map_1);
    output = Core.f_map_from_map_1(
      generic_map_1,
      valuemap,
      Core.t_any_from_key_value.vx_fn_new((key_any, value_any) -> {
        Core.Type_string key = Core.f_any_from_any(Core.t_string, key_any);
        Core.Type_any value = Core.f_any_from_any(Core.t_any, value_any);
        Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function map_from_map 1
   * Returns a map from a map by applying a function to each key value.
   * @param  {map-2} valuemap
   * @param  {any<-key-value} fn-any<-key-value
   * @return {map-1}
   * (func map<-map)
   */
  public interface Func_map_from_map_1 extends Core.Type_func, Core.Type_replfunc {
    public <N extends Core.Type_map, O extends Core.Type_map> N vx_map_from_map_1(final N generic_map_1, final O valuemap, final Core.Func_any_from_key_value fn_any_from_key_value);
  }

  public static class Class_map_from_map_1 extends Core.Class_base implements Func_map_from_map_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_map_from_map_1 output = new Core.Class_map_from_map_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_map_from_map_1 output = new Core.Class_map_from_map_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_map_from_map_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_map_from_map_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_map generic_map_1 = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_map valuemap = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_key_value fn_any_from_key_value = Core.f_any_from_any(Core.t_any_from_key_value, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value);
      return output;
    }

    @Override
    public <N extends Core.Type_map, O extends Core.Type_map> N vx_map_from_map_1(final N generic_map_1, final O valuemap, final Core.Func_any_from_key_value fn_any_from_key_value) {
      N output = Core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value);
      return output;
    }

  }

  public static final Core.Func_map_from_map_1 e_map_from_map_1 = new Core.Class_map_from_map_1();
  public static final Core.Func_map_from_map_1 t_map_from_map_1 = new Core.Class_map_from_map_1();

  public static <N extends Core.Type_map, O extends Core.Type_map> N f_map_from_map_1(final N generic_map_1, final O valuemap, final Core.Func_any_from_key_value fn_any_from_key_value) {
    N output = Core.f_empty(generic_map_1);
    output = Core.vx_map_from_map_fn(
      generic_map_1,
      valuemap,
      fn_any_from_key_value);
    return output;
  }

  /**
   * @function msg_from_error
   * Returns a msg from error string
   * @param  {string} error
   * @return {msg}
   * (func msg<-error)
   */
  public interface Func_msg_from_error extends Core.Func_any_from_any {
    public Core.Type_msg vx_msg_from_error(final Core.Type_string error);
  }

  public static class Class_msg_from_error extends Core.Class_base implements Func_msg_from_error {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_msg_from_error output = new Core.Class_msg_from_error();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_msg_from_error output = new Core.Class_msg_from_error();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msg_from_error;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msg_from_error;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_msg_from_error(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string error = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_msg_from_error(error);
      return output;
    }

    @Override
    public Core.Type_msg vx_msg_from_error(final Core.Type_string error) {
      Core.Type_msg output = Core.f_msg_from_error(error);
      return output;
    }

  }

  public static final Core.Func_msg_from_error e_msg_from_error = new Core.Class_msg_from_error();
  public static final Core.Func_msg_from_error t_msg_from_error = new Core.Class_msg_from_error();

  public static Core.Type_msg f_msg_from_error(final Core.Type_string error) {
    Core.Type_msg output = Core.e_msg;
    output = Core.f_new(
      Core.t_msg,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":severity"),
        Core.c_msg_error,
        Core.vx_new_string(":text"),
        error
      )
    );
    return output;
  }

  /**
   * @function msg_from_error 1
   * Returns a msg from error code and detail
   * @param  {string} code
   * @param  {any} detail
   * @return {msg}
   * (func msg<-error)
   */
  public interface Func_msg_from_error_1 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_msg vx_msg_from_error_1(final Core.Type_string code, final Core.Type_any detail);
  }

  public static class Class_msg_from_error_1 extends Core.Class_base implements Func_msg_from_error_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_msg_from_error_1 output = new Core.Class_msg_from_error_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_msg_from_error_1 output = new Core.Class_msg_from_error_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msg_from_error_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msg_from_error_1;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string code = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any detail = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_msg_from_error_1(code, detail);
      return output;
    }

    @Override
    public Core.Type_msg vx_msg_from_error_1(final Core.Type_string code, final Core.Type_any detail) {
      Core.Type_msg output = Core.f_msg_from_error_1(code, detail);
      return output;
    }

  }

  public static final Core.Func_msg_from_error_1 e_msg_from_error_1 = new Core.Class_msg_from_error_1();
  public static final Core.Func_msg_from_error_1 t_msg_from_error_1 = new Core.Class_msg_from_error_1();

  public static Core.Type_msg f_msg_from_error_1(final Core.Type_string code, final Core.Type_any detail) {
    Core.Type_msg output = Core.e_msg;
    output = Core.f_new(
      Core.t_msg,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":code"),
        code,
        Core.vx_new_string(":detail"),
        detail,
        Core.vx_new_string(":severity"),
        Core.c_msg_error
      )
    );
    return output;
  }

  /**
   * @function msg_from_error 2
   * Returns a msg from error path code and detail
   * @param  {string} path
   * @param  {string} code
   * @param  {any} detail
   * @return {msg}
   * (func msg<-error)
   */
  public interface Func_msg_from_error_2 extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_msg vx_msg_from_error_2(final Core.Type_string path, final Core.Type_string code, final Core.Type_any detail);
  }

  public static class Class_msg_from_error_2 extends Core.Class_base implements Func_msg_from_error_2 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_msg_from_error_2 output = new Core.Class_msg_from_error_2();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_msg_from_error_2 output = new Core.Class_msg_from_error_2();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        2, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msg_from_error_2;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msg_from_error_2;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string path = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string code = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_any detail = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_msg_from_error_2(path, code, detail);
      return output;
    }

    @Override
    public Core.Type_msg vx_msg_from_error_2(final Core.Type_string path, final Core.Type_string code, final Core.Type_any detail) {
      Core.Type_msg output = Core.f_msg_from_error_2(path, code, detail);
      return output;
    }

  }

  public static final Core.Func_msg_from_error_2 e_msg_from_error_2 = new Core.Class_msg_from_error_2();
  public static final Core.Func_msg_from_error_2 t_msg_from_error_2 = new Core.Class_msg_from_error_2();

  public static Core.Type_msg f_msg_from_error_2(final Core.Type_string path, final Core.Type_string code, final Core.Type_any detail) {
    Core.Type_msg output = Core.e_msg;
    output = Core.f_new(
      Core.t_msg,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":code"),
        code,
        Core.vx_new_string(":path"),
        path,
        Core.vx_new_string(":severity"),
        Core.c_msg_error,
        Core.vx_new_string(":detail"),
        detail
      )
    );
    return output;
  }

  /**
   * @function msg_from_warning
   * Returns a msg from a warning string
   * @param  {string} warning
   * @return {msg}
   * (func msg<-warning)
   */
  public interface Func_msg_from_warning extends Core.Func_any_from_any {
    public Core.Type_msg vx_msg_from_warning(final Core.Type_string warning);
  }

  public static class Class_msg_from_warning extends Core.Class_base implements Func_msg_from_warning {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_msg_from_warning output = new Core.Class_msg_from_warning();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_msg_from_warning output = new Core.Class_msg_from_warning();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-warning", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msg_from_warning;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msg_from_warning;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_msg_from_warning(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string warning = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_msg_from_warning(warning);
      return output;
    }

    @Override
    public Core.Type_msg vx_msg_from_warning(final Core.Type_string warning) {
      Core.Type_msg output = Core.f_msg_from_warning(warning);
      return output;
    }

  }

  public static final Core.Func_msg_from_warning e_msg_from_warning = new Core.Class_msg_from_warning();
  public static final Core.Func_msg_from_warning t_msg_from_warning = new Core.Class_msg_from_warning();

  public static Core.Type_msg f_msg_from_warning(final Core.Type_string warning) {
    Core.Type_msg output = Core.e_msg;
    output = Core.f_new(
      Core.t_msg,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":severity"),
        Core.c_msg_warning,
        Core.vx_new_string(":text"),
        warning
      )
    );
    return output;
  }

  /**
   * @function msgblock_from_msgblock_msg
   * Return a new Msgblock with the added msg
   * @param  {msgblock} origblock
   * @param  {msg} addmsg
   * @return {msgblock}
   * (func msgblock<-msgblock-msg)
   */
  public interface Func_msgblock_from_msgblock_msg extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_msgblock vx_msgblock_from_msgblock_msg(final Core.Type_msgblock origblock, final Core.Type_msg addmsg);
  }

  public static class Class_msgblock_from_msgblock_msg extends Core.Class_base implements Func_msgblock_from_msgblock_msg {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_msgblock_from_msgblock_msg output = new Core.Class_msgblock_from_msgblock_msg();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_msgblock_from_msgblock_msg output = new Core.Class_msgblock_from_msgblock_msg();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msg", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msgblock_from_msgblock_msg;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msgblock_from_msgblock_msg;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_msgblock origblock = Core.f_any_from_any(Core.t_msgblock, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_msg addmsg = Core.f_any_from_any(Core.t_msg, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_msgblock_from_msgblock_msg(origblock, addmsg);
      return output;
    }

    @Override
    public Core.Type_msgblock vx_msgblock_from_msgblock_msg(final Core.Type_msgblock origblock, final Core.Type_msg addmsg) {
      Core.Type_msgblock output = Core.f_msgblock_from_msgblock_msg(origblock, addmsg);
      return output;
    }

  }

  public static final Core.Func_msgblock_from_msgblock_msg e_msgblock_from_msgblock_msg = new Core.Class_msgblock_from_msgblock_msg();
  public static final Core.Func_msgblock_from_msgblock_msg t_msgblock_from_msgblock_msg = new Core.Class_msgblock_from_msgblock_msg();

  public static Core.Type_msgblock f_msgblock_from_msgblock_msg(final Core.Type_msgblock origblock, final Core.Type_msg addmsg) {
    Core.Type_msgblock output = Core.e_msgblock;
    output = Core.f_copy(
      origblock,
      Core.vx_new(
        Core.t_anylist,
        addmsg
      )
    );
    return output;
  }

  /**
   * @function msgblock_from_msgblock_msgblock
   * Return a new Msgblock with the added block
   * @param  {msgblock} origblock
   * @param  {msgblock} addblock
   * @return {msgblock}
   * (func msgblock<-msgblock-msgblock)
   */
  public interface Func_msgblock_from_msgblock_msgblock extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_msgblock vx_msgblock_from_msgblock_msgblock(final Core.Type_msgblock origblock, final Core.Type_msgblock addblock);
  }

  public static class Class_msgblock_from_msgblock_msgblock extends Core.Class_base implements Func_msgblock_from_msgblock_msgblock {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_msgblock_from_msgblock_msgblock output = new Core.Class_msgblock_from_msgblock_msgblock();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_msgblock_from_msgblock_msgblock output = new Core.Class_msgblock_from_msgblock_msgblock();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msgblock", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_msgblock_from_msgblock_msgblock;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_msgblock_from_msgblock_msgblock;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_msgblock origblock = Core.f_any_from_any(Core.t_msgblock, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_msgblock addblock = Core.f_any_from_any(Core.t_msgblock, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_msgblock_from_msgblock_msgblock(origblock, addblock);
      return output;
    }

    @Override
    public Core.Type_msgblock vx_msgblock_from_msgblock_msgblock(final Core.Type_msgblock origblock, final Core.Type_msgblock addblock) {
      Core.Type_msgblock output = Core.f_msgblock_from_msgblock_msgblock(origblock, addblock);
      return output;
    }

  }

  public static final Core.Func_msgblock_from_msgblock_msgblock e_msgblock_from_msgblock_msgblock = new Core.Class_msgblock_from_msgblock_msgblock();
  public static final Core.Func_msgblock_from_msgblock_msgblock t_msgblock_from_msgblock_msgblock = new Core.Class_msgblock_from_msgblock_msgblock();

  public static Core.Type_msgblock f_msgblock_from_msgblock_msgblock(final Core.Type_msgblock origblock, final Core.Type_msgblock addblock) {
    Core.Type_msgblock output = Core.e_msgblock;
    output = Core.f_new(
      Core.t_msgblock,
      Core.vx_new(
        Core.t_anylist,
        origblock,
        addblock
      )
    );
    return output;
  }

  /**
   * @function name_from_typedef
   * Returns the name from a typedef.
   * @param  {typedef} vtypedef
   * @return {string}
   * (func name<-typedef)
   */
  public interface Func_name_from_typedef extends Core.Func_any_from_any {
    public Core.Type_string vx_name_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_name_from_typedef extends Core.Class_base implements Func_name_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_name_from_typedef output = new Core.Class_name_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_name_from_typedef output = new Core.Class_name_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "name<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_name_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_name_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_name_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_name_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_string vx_name_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_string output = Core.f_name_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_name_from_typedef e_name_from_typedef = new Core.Class_name_from_typedef();
  public static final Core.Func_name_from_typedef t_name_from_typedef = new Core.Class_name_from_typedef();

  public static Core.Type_string f_name_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_string output = Core.e_string;
    output = vtypedef.name();
    return output;
  }

  /**
   * @function native
   * Native Function Call
   * @param  {anylist} clauses
   * @return {any-1}
   * (func native)
   */
  public interface Func_native extends Core.Func_any_from_any {
    public <T extends Core.Type_any> T vx_native(final T generic_any_1, final Core.Type_anylist clauses);
  }

  public static class Class_native extends Core.Class_base implements Func_native {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_native output = new Core.Class_native();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_native output = new Core.Class_native();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "native", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_native;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_native;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_anylist inputval = (Core.Type_anylist)value;
      Core.Type_any outputval = Core.f_native(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_anylist clauses = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_native(generic_any_1, clauses);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_native(final T generic_any_1, final Core.Type_anylist clauses) {
      T output = Core.f_native(generic_any_1, clauses);
      return output;
    }

  }

  public static final Core.Func_native e_native = new Core.Class_native();
  public static final Core.Func_native t_native = new Core.Class_native();

  public static <T extends Core.Type_any> T f_native(final T generic_any_1, final Core.Type_anylist clauses) {
    T output = Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function native_from_any
   * Returns native value of value object
   * @param  {any-1} value
   * @return {any}
   * (func native<-any)
   */
  public interface Func_native_from_any extends Core.Func_any_from_any {
    public Core.Type_any vx_native_from_any(final Core.Type_any value);
  }

  public static class Class_native_from_any extends Core.Class_base implements Func_native_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_native_from_any output = new Core.Class_native_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_native_from_any output = new Core.Class_native_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "native<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_native_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_native_from_any;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_native_from_any(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_native_from_any(value);
      return output;
    }

    @Override
    public Core.Type_any vx_native_from_any(final Core.Type_any value) {
      Core.Type_any output = Core.f_native_from_any(value);
      return output;
    }

  }

  public static final Core.Func_native_from_any e_native_from_any = new Core.Class_native_from_any();
  public static final Core.Func_native_from_any t_native_from_any = new Core.Class_native_from_any();

  public static Core.Type_any f_native_from_any(final Core.Type_any value) {
    Core.Type_any output = Core.e_any;
    return output;
  }

  /**
   * @function new
   * Create a new Value of Type A
   * @param  {any-1} type
   * @param  {anylist} values
   * @return {any-1}
   * (func new)
   */
  public interface Func_new extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any> T vx_new(final T type, final Core.Type_anylist values);
  }

  public static class Class_new extends Core.Class_base implements Func_new {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_new output = new Core.Class_new();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_new output = new Core.Class_new();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "new", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_new;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_new;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any type = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_anylist values = Core.f_any_from_any(Core.t_anylist, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_new(type, values);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_new(final T type, final Core.Type_anylist values) {
      T output = Core.f_new(type, values);
      return output;
    }

  }

  public static final Core.Func_new e_new = new Core.Class_new();
  public static final Core.Func_new t_new = new Core.Class_new();

  @SuppressWarnings("unchecked")
  public static <T extends Core.Type_any> T f_new(final T type, final Core.Type_anylist values) {
    Core.Type_any[] arrayany = Core.arrayany_from_anylist(values);
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));
    return output;
  }

  /**
   * @function number_from_func
   * Function Type returning number with any parameters
   * @return {number}
   * (func number<-func)
   */
  public interface Func_number_from_func extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_number vx_number_from_func();
  }

  public static class Class_number_from_func extends Core.Class_base implements Func_number_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_number_from_func output = new Core.Class_number_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_number_from_func output = new Core.Class_number_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "number<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_int, Core.t_float, Core.t_decimal), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_number_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_number_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      output = Core.f_number_from_func();
      return output;
    }

    @Override
    public Core.Type_number vx_number_from_func() {
      Core.Type_number output = Core.f_number_from_func();
      return output;
    }

  }

  public static final Core.Func_number_from_func e_number_from_func = new Core.Class_number_from_func();
  public static final Core.Func_number_from_func t_number_from_func = new Core.Class_number_from_func();

  public static Core.Type_number f_number_from_func() {
    Core.Type_number output = Core.e_number;
    return output;
  }

  /**
   * @function or
   * Returns true if any value is true
   * @param  {boolean} val1
   * @param  {boolean} val2
   * @return {boolean}
   * (func or)
   */
  public interface Func_or extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_boolean vx_or(final Core.Type_boolean val1, final Core.Type_boolean val2);
  }

  public static class Class_or extends Core.Class_base implements Func_or {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_or output = new Core.Class_or();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_or output = new Core.Class_or();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_or;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_or;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_boolean val1 = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_boolean val2 = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_or(val1, val2);
      return output;
    }

    @Override
    public Core.Type_boolean vx_or(final Core.Type_boolean val1, final Core.Type_boolean val2) {
      Core.Type_boolean output = Core.f_or(val1, val2);
      return output;
    }

  }

  public static final Core.Func_or e_or = new Core.Class_or();
  public static final Core.Func_or t_or = new Core.Class_or();

  public static Core.Type_boolean f_or(final Core.Type_boolean val1, final Core.Type_boolean val2) {
    Core.Type_boolean output = Core.e_boolean;
    if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    };
    return output;
  }

  /**
   * @function or 1
   * Returns true if any value is true
   * @param  {booleanlist} values
   * @return {boolean}
   * (func or)
   */
  public interface Func_or_1 extends Core.Func_any_from_any {
    public Core.Type_boolean vx_or_1(final Core.Type_booleanlist values);
  }

  public static class Class_or_1 extends Core.Class_base implements Func_or_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_or_1 output = new Core.Class_or_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_or_1 output = new Core.Class_or_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_or_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_or_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_booleanlist inputval = (Core.Type_booleanlist)value;
      Core.Type_any outputval = Core.f_or_1(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_booleanlist values = Core.f_any_from_any(Core.t_booleanlist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_or_1(values);
      return output;
    }

    @Override
    public Core.Type_boolean vx_or_1(final Core.Type_booleanlist values) {
      Core.Type_boolean output = Core.f_or_1(values);
      return output;
    }

  }

  public static final Core.Func_or_1 e_or_1 = new Core.Class_or_1();
  public static final Core.Func_or_1 t_or_1 = new Core.Class_or_1();

  public static Core.Type_boolean f_or_1(final Core.Type_booleanlist values) {
    Core.Type_boolean output = Core.e_boolean;
    output = Core.f_any_from_list_start_reduce_next(
      Core.t_boolean,
      values,
      Core.vx_new_boolean(false),
      Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) -> {
        Core.Type_boolean reduce = Core.f_any_from_any(Core.t_boolean, reduce_any);
        Core.Type_boolean current = Core.f_any_from_any(Core.t_boolean, current_any);
        Core.Type_boolean next = Core.f_any_from_any(Core.t_boolean, next_any);
        Core.Type_any output_1 = Core.f_or(
          reduce,
          Core.f_or(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function package_global_from_name
   * Returns a package from global with the given name.
   * @param  {string} name
   * @return {package}
   * (func package-global<-name)
   */
  public interface Func_package_global_from_name extends Core.Func_any_from_any {
    public Core.Type_package vx_package_global_from_name(final Core.Type_string name);
  }

  public static class Class_package_global_from_name extends Core.Class_base implements Func_package_global_from_name {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_package_global_from_name output = new Core.Class_package_global_from_name();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_package_global_from_name output = new Core.Class_package_global_from_name();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "package-global<-name", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "package", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_package_global_from_name;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_package_global_from_name;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_package_global_from_name(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string name = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_package_global_from_name(name);
      return output;
    }

    @Override
    public Core.Type_package vx_package_global_from_name(final Core.Type_string name) {
      Core.Type_package output = Core.f_package_global_from_name(name);
      return output;
    }

  }

  public static final Core.Func_package_global_from_name e_package_global_from_name = new Core.Class_package_global_from_name();
  public static final Core.Func_package_global_from_name t_package_global_from_name = new Core.Class_package_global_from_name();

  public static Core.Type_package f_package_global_from_name(final Core.Type_string name) {
    Core.Type_package output = Core.e_package;
    output = Core.f_any_from_map(
      Core.t_package,
      Core.c_global.packagemap(),
      name
    );
    return output;
  }

  /**
   * @function packagename_from_typedef
   * Returns the package name from a typedef.
   * @param  {typedef} vtypedef
   * @return {string}
   * (func packagename<-typedef)
   */
  public interface Func_packagename_from_typedef extends Core.Func_any_from_any {
    public Core.Type_string vx_packagename_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_packagename_from_typedef extends Core.Class_base implements Func_packagename_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_packagename_from_typedef output = new Core.Class_packagename_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_packagename_from_typedef output = new Core.Class_packagename_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "packagename<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_packagename_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_packagename_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_packagename_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_packagename_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_string vx_packagename_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_string output = Core.f_packagename_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_packagename_from_typedef e_packagename_from_typedef = new Core.Class_packagename_from_typedef();
  public static final Core.Func_packagename_from_typedef t_packagename_from_typedef = new Core.Class_packagename_from_typedef();

  public static Core.Type_string f_packagename_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_string output = Core.e_string;
    output = vtypedef.pkgname();
    return output;
  }

  /**
   * @function path_from_context_path
   * Returns a path from a context
   * @param  {string} path
   * @return {string}
   * (func path<-context-path)
   */
  public interface Func_path_from_context_path extends Core.Func_any_from_any_context {
    public Core.Type_string vx_path_from_context_path(final Core.Type_context context, final Core.Type_string path);
  }

  public static class Class_path_from_context_path extends Core.Class_base implements Func_path_from_context_path {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_path_from_context_path output = new Core.Class_path_from_context_path();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_path_from_context_path output = new Core.Class_path_from_context_path();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "path<-context-path", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_path_from_context_path;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_path_from_context_path;
      return output;
    }

    @Override
    public Core.Func_any_from_any_context vx_fn_new(Core.Class_any_from_any_context.IFn fn) {
      return Core.e_any_from_any_context;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_path_from_context_path(context, inputval);
      output = Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string path = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_path_from_context_path(context, path);
      return output;
    }

    @Override
    public Core.Type_string vx_path_from_context_path(final Core.Type_context context, final Core.Type_string path) {
      Core.Type_string output = Core.f_path_from_context_path(context, path);
      return output;
    }

  }

  public static final Core.Func_path_from_context_path e_path_from_context_path = new Core.Class_path_from_context_path();
  public static final Core.Func_path_from_context_path t_path_from_context_path = new Core.Class_path_from_context_path();

  public static Core.Type_string f_path_from_context_path(final Core.Type_context context, final Core.Type_string path) {
    Core.Type_string output = Core.e_string;
    output = Core.f_path_from_setting_path(
      Core.f_setting_from_context(
        context
      ),
      path
    );
    return output;
  }

  /**
   * @function path_from_setting_path
   * Returns a path from a setting
   * @param  {setting} session
   * @param  {string} path
   * @return {string}
   * (func path<-setting-path)
   */
  public interface Func_path_from_setting_path extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_string vx_path_from_setting_path(final Core.Type_setting session, final Core.Type_string path);
  }

  public static class Class_path_from_setting_path extends Core.Class_base implements Func_path_from_setting_path {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_path_from_setting_path output = new Core.Class_path_from_setting_path();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_path_from_setting_path output = new Core.Class_path_from_setting_path();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "path<-setting-path", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_path_from_setting_path;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_path_from_setting_path;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_setting session = Core.f_any_from_any(Core.t_setting, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string path = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_path_from_setting_path(session, path);
      return output;
    }

    @Override
    public Core.Type_string vx_path_from_setting_path(final Core.Type_setting session, final Core.Type_string path) {
      Core.Type_string output = Core.f_path_from_setting_path(session, path);
      return output;
    }

  }

  public static final Core.Func_path_from_setting_path e_path_from_setting_path = new Core.Class_path_from_setting_path();
  public static final Core.Func_path_from_setting_path t_path_from_setting_path = new Core.Class_path_from_setting_path();

  public static Core.Type_string f_path_from_setting_path(final Core.Type_setting session, final Core.Type_string path) {
    Core.Type_string output = Core.e_string;
    return output;
  }

  /**
   * @function permission_from_id_context
   * Return a permission from context by id
   * @param  {string} id
   * @return {permission}
   * (func permission<-id-context)
   */
  public interface Func_permission_from_id_context extends Core.Func_any_from_any_context {
    public Core.Type_permission vx_permission_from_id_context(final Core.Type_context context, final Core.Type_string id);
  }

  public static class Class_permission_from_id_context extends Core.Class_base implements Func_permission_from_id_context {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_permission_from_id_context output = new Core.Class_permission_from_id_context();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_permission_from_id_context output = new Core.Class_permission_from_id_context();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "permission<-id-context", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "permission", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_permission_from_id_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_permission_from_id_context;
      return output;
    }

    @Override
    public Core.Func_any_from_any_context vx_fn_new(Core.Class_any_from_any_context.IFn fn) {
      return Core.e_any_from_any_context;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any_context(final T generic_any_1, final Core.Type_context context, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_string inputval = (Core.Type_string)value;
      Core.Type_any outputval = Core.f_permission_from_id_context(context, inputval);
      output = Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string id = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_permission_from_id_context(context, id);
      return output;
    }

    @Override
    public Core.Type_permission vx_permission_from_id_context(final Core.Type_context context, final Core.Type_string id) {
      Core.Type_permission output = Core.f_permission_from_id_context(context, id);
      return output;
    }

  }

  public static final Core.Func_permission_from_id_context e_permission_from_id_context = new Core.Class_permission_from_id_context();
  public static final Core.Func_permission_from_id_context t_permission_from_id_context = new Core.Class_permission_from_id_context();

  public static Core.Type_permission f_permission_from_id_context(final Core.Type_context context, final Core.Type_string id) {
    Core.Type_permission output = Core.e_permission;
    output = Core.f_let(
      Core.t_permission,
      Core.t_any_from_func.vx_fn_new(() -> {
        Core.Type_user user = Core.f_user_from_context(
          context
        );
        Core.Type_security security = user.security();
        Core.Type_permissionmap permissionmap = security.permissionmap();
        Core.Type_any output_1 = Core.f_any_from_map(
          Core.t_permission,
          permissionmap,
          Core.vx_new_string(":id")
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function properties_from_typedef
   * Return property map from typedef
   * @param  {typedef} vtypedef
   * @return {argmap}
   * (func properties<-typedef)
   */
  public interface Func_properties_from_typedef extends Core.Func_any_from_any {
    public Core.Type_argmap vx_properties_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_properties_from_typedef extends Core.Class_base implements Func_properties_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_properties_from_typedef output = new Core.Class_properties_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_properties_from_typedef output = new Core.Class_properties_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "properties<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "argmap", // name
          ":map", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_arg), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_properties_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_properties_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_properties_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_properties_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_argmap vx_properties_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_argmap output = Core.f_properties_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_properties_from_typedef e_properties_from_typedef = new Core.Class_properties_from_typedef();
  public static final Core.Func_properties_from_typedef t_properties_from_typedef = new Core.Class_properties_from_typedef();

  public static Core.Type_argmap f_properties_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_argmap output = Core.e_argmap;
    output = vtypedef.properties();
    return output;
  }

  /**
   * @function proplast_from_typedef
   * Return last property from typedef
   * @param  {typedef} vtypedef
   * @return {arg}
   * (func proplast<-typedef)
   */
  public interface Func_proplast_from_typedef extends Core.Func_any_from_any {
    public Core.Type_arg vx_proplast_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_proplast_from_typedef extends Core.Class_base implements Func_proplast_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_proplast_from_typedef output = new Core.Class_proplast_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_proplast_from_typedef output = new Core.Class_proplast_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "proplast<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "arg", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_proplast_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_proplast_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_proplast_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_proplast_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_arg vx_proplast_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_arg output = Core.f_proplast_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_proplast_from_typedef e_proplast_from_typedef = new Core.Class_proplast_from_typedef();
  public static final Core.Func_proplast_from_typedef t_proplast_from_typedef = new Core.Class_proplast_from_typedef();

  public static Core.Type_arg f_proplast_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_arg output = Core.e_arg;
    output = vtypedef.proplast();
    return output;
  }

  /**
   * @function resolve
   * @param  {any-1} value
   * @return {any-1}
   * (func resolve)
   */
  public interface Func_resolve extends Core.Func_any_from_any {
    public <T extends Core.Type_any> T vx_resolve(final T generic_any_1, final T value);
  }

  public static class Class_resolve extends Core.Class_base implements Func_resolve {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_resolve output = new Core.Class_resolve();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_resolve output = new Core.Class_resolve();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_resolve;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_resolve;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_resolve(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_resolve(generic_any_1, value);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_resolve(final T generic_any_1, final T value) {
      T output = Core.f_resolve(generic_any_1, value);
      return output;
    }

  }

  public static final Core.Func_resolve e_resolve = new Core.Class_resolve();
  public static final Core.Func_resolve t_resolve = new Core.Class_resolve();

  public static <T extends Core.Type_any> T f_resolve(final T generic_any_1, final T value) {
    T output = Core.f_empty(generic_any_1);
    output = value;
    return output;
  }

  /**
   * @function resolve 1
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func resolve)
   */
  public interface Func_resolve_1 extends Core.Func_any_from_any {
    public <T extends Core.Type_any> T vx_resolve_1(final T generic_any_1, final Core.Func_any_from_func fn_any);
  }

  public static class Class_resolve_1 extends Core.Class_base implements Func_resolve_1 {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_resolve_1 output = new Core.Class_resolve_1();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_resolve_1 output = new Core.Class_resolve_1();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        1, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_resolve_1;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_resolve_1;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Func_any_from_func inputval = (Core.Func_any_from_func)value;
      Core.Type_any outputval = Core.f_resolve_1(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_resolve_1(generic_any_1, fn_any);
      return output;
    }

    @Override
    public <T extends Core.Type_any> T vx_resolve_1(final T generic_any_1, final Core.Func_any_from_func fn_any) {
      T output = Core.f_resolve_1(generic_any_1, fn_any);
      return output;
    }

  }

  public static final Core.Func_resolve_1 e_resolve_1 = new Core.Class_resolve_1();
  public static final Core.Func_resolve_1 t_resolve_1 = new Core.Class_resolve_1();

  public static <T extends Core.Type_any> T f_resolve_1(final T generic_any_1, final Core.Func_any_from_func fn_any) {
    T output = Core.f_empty(generic_any_1);
    if (fn_any == null) {
    } else if (fn_any == Core.e_any_from_func) {
    } else {
      output = fn_any.vx_any_from_func(generic_any_1);
    };
    return output;
  }

  /**
   * 
   * @async
   * @function resolve_async
   * @param  {any<-func-async} fn-any
   * @return {any-1}
   * (func resolve-async)
   */
  public interface Func_resolve_async extends Core.Func_any_from_any_async {
    public <T extends Core.Type_any> CompletableFuture<T> vx_resolve_async(final T generic_any_1, final Core.Func_any_from_func_async fn_any);
  }

  public static class Class_resolve_async extends Core.Class_base implements Func_resolve_async {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_resolve_async output = new Core.Class_resolve_async();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_resolve_async output = new Core.Class_resolve_async();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "resolve-async", // name
        0, // idx
        true, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_resolve_async;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_resolve_async;
      return output;
    }

    @Override
    public Core.Func_any_from_any_async vx_fn_new(Core.Class_any_from_any_async.IFn fn) {
      return Core.e_any_from_any_async;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> CompletableFuture<T> vx_any_from_any_async(final T generic_any_1, final U value) {
      T inputval = Core.f_any_from_any(generic_any_1, value);
      CompletableFuture<T> output = Core.f_async(generic_any_1, inputval);
      return output;
    }

    @Override
    public CompletableFuture<Core.Type_any> vx_repl(Core.Type_anylist arglist) {
      CompletableFuture<Core.Type_any> output = Core.vx_async_new_from_value(Core.e_any);
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func_async fn_any = Core.f_any_from_any(Core.t_any_from_func_async, arglist.vx_any(Core.vx_new_int(0)));
      CompletableFuture<Core.Type_any> future = Core.f_resolve_async(generic_any_1, fn_any);
      output = Core.vx_async_from_async(Core.t_any, future);
      return output;
    }

    @Override
    public <T extends Core.Type_any> CompletableFuture<T> vx_resolve_async(final T generic_any_1, final Core.Func_any_from_func_async fn_any) {
      CompletableFuture<T> output = Core.f_resolve_async(generic_any_1, fn_any);
      return output;
    }

  }

  public static final Core.Func_resolve_async e_resolve_async = new Core.Class_resolve_async();
  public static final Core.Func_resolve_async t_resolve_async = new Core.Class_resolve_async();

  public static <T extends Core.Type_any> CompletableFuture<T> f_resolve_async(final T generic_any_1, final Core.Func_any_from_func_async fn_any) {
    CompletableFuture<T> output = Core.vx_async_new_from_value(Core.f_empty(generic_any_1));
    if (fn_any == null) {
    } else if (fn_any == Core.e_any_from_func_async) {
    } else {
      output = fn_any.vx_any_from_func_async(generic_any_1);
    };
    return output;
  }

  /**
   * @function resolve_first
   * Returns the first value that is not nothing
   * @param  {list-1} clauses
   * @return {any-1}
   * (func resolve-first)
   */
  public interface Func_resolve_first extends Core.Func_any_from_any {
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_resolve_first(final T generic_any_1, final X clauses);
  }

  public static class Class_resolve_first extends Core.Class_base implements Func_resolve_first {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_resolve_first output = new Core.Class_resolve_first();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_resolve_first output = new Core.Class_resolve_first();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "resolve-first", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_resolve_first;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_resolve_first;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_resolve_first(Core.t_any, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list clauses = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_resolve_first(generic_any_1, clauses);
      return output;
    }

    @Override
    public <T extends Core.Type_any, X extends Core.Type_list> T vx_resolve_first(final T generic_any_1, final X clauses) {
      T output = Core.f_resolve_first(generic_any_1, clauses);
      return output;
    }

  }

  public static final Core.Func_resolve_first e_resolve_first = new Core.Class_resolve_first();
  public static final Core.Func_resolve_first t_resolve_first = new Core.Class_resolve_first();

  public static <T extends Core.Type_any, X extends Core.Type_list> T f_resolve_first(final T generic_any_1, final X clauses) {
    T output = Core.f_empty(generic_any_1);
    output = Core.f_first_from_list_any_from_any(
      generic_any_1,
      clauses,
      Core.t_resolve
    );
    return output;
  }

  /**
   * @function resolve_list
   * @param  {list-1} clauses
   * @return {list-1}
   * (func resolve-list)
   */
  public interface Func_resolve_list extends Core.Func_any_from_any {
    public <X extends Core.Type_list> X vx_resolve_list(final X generic_list_1, final X clauses);
  }

  public static class Class_resolve_list extends Core.Class_base implements Func_resolve_list {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_resolve_list output = new Core.Class_resolve_list();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_resolve_list output = new Core.Class_resolve_list();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "resolve-list", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_resolve_list;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_resolve_list;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_list inputval = (Core.Type_list)value;
      Core.Type_any outputval = Core.f_resolve_list(Core.t_list, inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_list generic_list_1 = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_list clauses = Core.f_any_from_any(Core.t_list, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_resolve_list(generic_list_1, clauses);
      return output;
    }

    @Override
    public <X extends Core.Type_list> X vx_resolve_list(final X generic_list_1, final X clauses) {
      X output = Core.f_resolve_list(generic_list_1, clauses);
      return output;
    }

  }

  public static final Core.Func_resolve_list e_resolve_list = new Core.Class_resolve_list();
  public static final Core.Func_resolve_list t_resolve_list = new Core.Class_resolve_list();

  public static <X extends Core.Type_list> X f_resolve_list(final X generic_list_1, final X clauses) {
    X output = Core.f_empty(generic_list_1);
    output = Core.f_list_from_list_1(
      generic_list_1,
      clauses,
      Core.t_resolve
    );
    return output;
  }

  /**
   * @function security_from_context
   * Return security from the given context.
   * @return {security}
   * (func security<-context)
   */
  public interface Func_security_from_context extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_security vx_security_from_context(final Core.Type_context context);
  }

  public static class Class_security_from_context extends Core.Class_base implements Func_security_from_context {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_security_from_context output = new Core.Class_security_from_context();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_security_from_context output = new Core.Class_security_from_context();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "security<-context", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_security_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_security_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_security_from_context(context);
      return output;
    }

    @Override
    public Core.Type_security vx_security_from_context(final Core.Type_context context) {
      Core.Type_security output = Core.f_security_from_context(context);
      return output;
    }

  }

  public static final Core.Func_security_from_context e_security_from_context = new Core.Class_security_from_context();
  public static final Core.Func_security_from_context t_security_from_context = new Core.Class_security_from_context();

  public static Core.Type_security f_security_from_context(final Core.Type_context context) {
    Core.Type_security output = Core.e_security;
    output = Core.f_security_from_user(
      Core.f_user_from_context(
        context
      )
    );
    return output;
  }

  /**
   * @function security_from_user
   * Return security from the given user.
   * @param  {user} user
   * @return {security}
   * (func security<-user)
   */
  public interface Func_security_from_user extends Core.Func_any_from_any {
    public Core.Type_security vx_security_from_user(final Core.Type_user user);
  }

  public static class Class_security_from_user extends Core.Class_base implements Func_security_from_user {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_security_from_user output = new Core.Class_security_from_user();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_security_from_user output = new Core.Class_security_from_user();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "security<-user", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_security_from_user;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_security_from_user;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_user inputval = (Core.Type_user)value;
      Core.Type_any outputval = Core.f_security_from_user(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_user user = Core.f_any_from_any(Core.t_user, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_security_from_user(user);
      return output;
    }

    @Override
    public Core.Type_security vx_security_from_user(final Core.Type_user user) {
      Core.Type_security output = Core.f_security_from_user(user);
      return output;
    }

  }

  public static final Core.Func_security_from_user e_security_from_user = new Core.Class_security_from_user();
  public static final Core.Func_security_from_user t_security_from_user = new Core.Class_security_from_user();

  public static Core.Type_security f_security_from_user(final Core.Type_user user) {
    Core.Type_security output = Core.e_security;
    output = user.security();
    return output;
  }

  /**
   * @function session_from_context
   * Returns session from a context
   * @return {session}
   * (func session<-context)
   */
  public interface Func_session_from_context extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_session vx_session_from_context(final Core.Type_context context);
  }

  public static class Class_session_from_context extends Core.Class_base implements Func_session_from_context {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_session_from_context output = new Core.Class_session_from_context();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_session_from_context output = new Core.Class_session_from_context();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "session<-context", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "session", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_session_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_session_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_session_from_context(context);
      return output;
    }

    @Override
    public Core.Type_session vx_session_from_context(final Core.Type_context context) {
      Core.Type_session output = Core.f_session_from_context(context);
      return output;
    }

  }

  public static final Core.Func_session_from_context e_session_from_context = new Core.Class_session_from_context();
  public static final Core.Func_session_from_context t_session_from_context = new Core.Class_session_from_context();

  public static Core.Type_session f_session_from_context(final Core.Type_context context) {
    Core.Type_session output = Core.e_session;
    output = context.session();
    return output;
  }

  /**
   * @function setting_from_context
   * Returns setting from a context
   * @return {setting}
   * (func setting<-context)
   */
  public interface Func_setting_from_context extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_setting vx_setting_from_context(final Core.Type_context context);
  }

  public static class Class_setting_from_context extends Core.Class_base implements Func_setting_from_context {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_setting_from_context output = new Core.Class_setting_from_context();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_setting_from_context output = new Core.Class_setting_from_context();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "setting<-context", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "setting", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_setting_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_setting_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_setting_from_context(context);
      return output;
    }

    @Override
    public Core.Type_setting vx_setting_from_context(final Core.Type_context context) {
      Core.Type_setting output = Core.f_setting_from_context(context);
      return output;
    }

  }

  public static final Core.Func_setting_from_context e_setting_from_context = new Core.Class_setting_from_context();
  public static final Core.Func_setting_from_context t_setting_from_context = new Core.Class_setting_from_context();

  public static Core.Type_setting f_setting_from_context(final Core.Type_context context) {
    Core.Type_setting output = Core.e_setting;
    output = context.setting();
    return output;
  }

  /**
   * @function string_repeat
   * @param  {string} text
   * @param  {int} repeat
   * @return {string}
   * (func string-repeat)
   */
  public interface Func_string_repeat extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_string vx_string_repeat(final Core.Type_string text, final Core.Type_int repeat);
  }

  public static class Class_string_repeat extends Core.Class_base implements Func_string_repeat {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_string_repeat output = new Core.Class_string_repeat();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_string_repeat output = new Core.Class_string_repeat();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "string-repeat", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_string_repeat;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_string_repeat;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int repeat = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_string_repeat(text, repeat);
      return output;
    }

    @Override
    public Core.Type_string vx_string_repeat(final Core.Type_string text, final Core.Type_int repeat) {
      Core.Type_string output = Core.f_string_repeat(text, repeat);
      return output;
    }

  }

  public static final Core.Func_string_repeat e_string_repeat = new Core.Class_string_repeat();
  public static final Core.Func_string_repeat t_string_repeat = new Core.Class_string_repeat();

  public static Core.Type_string f_string_repeat(final Core.Type_string text, final Core.Type_int repeat) {
    Core.Type_string output = Core.e_string;
    String stringtext = text.vx_string();
    int intrepeat = repeat.vx_int();
    String stringresult = stringtext.repeat(intrepeat);
    output = Core.vx_new_string(stringresult);
    return output;
  }

  /**
   * @function string_from_any
   * Return a string representation of a value
   * @param  {any} value
   * @return {string}
   * (func string<-any)
   */
  public interface Func_string_from_any extends Core.Func_any_from_any {
    public Core.Type_string vx_string_from_any(final Core.Type_any value);
  }

  public static class Class_string_from_any extends Core.Class_base implements Func_string_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_string_from_any output = new Core.Class_string_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_string_from_any output = new Core.Class_string_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "string<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_string_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_string_from_any;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_string_from_any(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_string_from_any(value);
      return output;
    }

    @Override
    public Core.Type_string vx_string_from_any(final Core.Type_any value) {
      Core.Type_string output = Core.f_string_from_any(value);
      return output;
    }

  }

  public static final Core.Func_string_from_any e_string_from_any = new Core.Class_string_from_any();
  public static final Core.Func_string_from_any t_string_from_any = new Core.Class_string_from_any();

  public static Core.Type_string f_string_from_any(final Core.Type_any value) {
    Core.Type_string output = Core.e_string;
    output = Core.f_string_from_any_indent(
      value,
      Core.vx_new_int(0),
      Core.vx_new_boolean(true)
    );
    return output;
  }

  /**
   * @function string_from_any_indent
   * Return a string representation of a value
   * @param  {any} value
   * @param  {int} indent
   * @param  {boolean} linefeed
   * @return {string}
   * (func string<-any-indent)
   */
  public interface Func_string_from_any_indent extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_string vx_string_from_any_indent(final Core.Type_any value, final Core.Type_int indent, final Core.Type_boolean linefeed);
  }

  public static class Class_string_from_any_indent extends Core.Class_base implements Func_string_from_any_indent {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_string_from_any_indent output = new Core.Class_string_from_any_indent();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_string_from_any_indent output = new Core.Class_string_from_any_indent();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "string<-any-indent", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_string_from_any_indent;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_string_from_any_indent;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_int indent = Core.f_any_from_any(Core.t_int, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_boolean linefeed = Core.f_any_from_any(Core.t_boolean, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_string_from_any_indent(value, indent, linefeed);
      return output;
    }

    @Override
    public Core.Type_string vx_string_from_any_indent(final Core.Type_any value, final Core.Type_int indent, final Core.Type_boolean linefeed) {
      Core.Type_string output = Core.f_string_from_any_indent(value, indent, linefeed);
      return output;
    }

  }

  public static final Core.Func_string_from_any_indent e_string_from_any_indent = new Core.Class_string_from_any_indent();
  public static final Core.Func_string_from_any_indent t_string_from_any_indent = new Core.Class_string_from_any_indent();

  public static Core.Type_string f_string_from_any_indent(final Core.Type_any value, final Core.Type_int indent, final Core.Type_boolean linefeed) {
    Core.Type_string output = Core.e_string;
    output = Core.vx_string_from_any_indent(value, indent, linefeed);
    return output;
  }

  /**
   * @function string_from_func
   * Function Type returning string with any parameters
   * @return {string}
   * (func string<-func)
   */
  public interface Func_string_from_func extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_string vx_string_from_func();
    public Core.Func_string_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public static class Class_string_from_func extends Core.Class_base implements Func_string_from_func {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_string_from_func output = new Core.Class_string_from_func();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_string_from_func output = new Core.Class_string_from_func();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "string<-func", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_string_from_func;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_string_from_func;
      return output;
    }

    public Class_any_from_func.IFn fn = null;

    @Override
    public Core.Func_string_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Core.Class_string_from_func output = new Core.Class_string_from_func();
      output.fn = fn;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      output = Core.f_string_from_func();
      return output;
    }

    @Override
    public Core.Type_string vx_string_from_func() {
      Core.Type_string output = Core.f_string_from_func();
      return output;
    }

  }

  public static final Core.Func_string_from_func e_string_from_func = new Core.Class_string_from_func();
  public static final Core.Func_string_from_func t_string_from_func = new Core.Class_string_from_func();

  public static Core.Type_string f_string_from_func() {
    Core.Type_string output = Core.e_string;
    return output;
  }

  /**
   * @function string_from_string_find_replace
   * Returns a string with all instances of find replaced by replace.
   * @param  {string} text
   * @param  {string} find
   * @param  {string} replace
   * @return {string}
   * (func string<-string-find-replace)
   */
  public interface Func_string_from_string_find_replace extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_string vx_string_from_string_find_replace(final Core.Type_string text, final Core.Type_string find, final Core.Type_string replace);
  }

  public static class Class_string_from_string_find_replace extends Core.Class_base implements Func_string_from_string_find_replace {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_string_from_string_find_replace output = new Core.Class_string_from_string_find_replace();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_string_from_string_find_replace output = new Core.Class_string_from_string_find_replace();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "string<-string-find-replace", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_string_from_string_find_replace;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_string_from_string_find_replace;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_string text = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_string find = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(1)));
      Core.Type_string replace = Core.f_any_from_any(Core.t_string, arglist.vx_any(Core.vx_new_int(2)));
      output = Core.f_string_from_string_find_replace(text, find, replace);
      return output;
    }

    @Override
    public Core.Type_string vx_string_from_string_find_replace(final Core.Type_string text, final Core.Type_string find, final Core.Type_string replace) {
      Core.Type_string output = Core.f_string_from_string_find_replace(text, find, replace);
      return output;
    }

  }

  public static final Core.Func_string_from_string_find_replace e_string_from_string_find_replace = new Core.Class_string_from_string_find_replace();
  public static final Core.Func_string_from_string_find_replace t_string_from_string_find_replace = new Core.Class_string_from_string_find_replace();

  public static Core.Type_string f_string_from_string_find_replace(final Core.Type_string text, final Core.Type_string find, final Core.Type_string replace) {
    Core.Type_string output = Core.e_string;
    output = Core.vx_string_from_string_find_replace(text, find, replace);
    return output;
  }

  /**
   * @function stringlist_from_map
   * Returns a stringlist of keys from any map in entry order.
   * @param  {map-1} map
   * @return {stringlist}
   * (func stringlist<-map)
   */
  public interface Func_stringlist_from_map extends Core.Func_any_from_any {
    public Core.Type_stringlist vx_stringlist_from_map(final Core.Type_map map);
  }

  public static class Class_stringlist_from_map extends Core.Class_base implements Func_stringlist_from_map {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_stringlist_from_map output = new Core.Class_stringlist_from_map();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_stringlist_from_map output = new Core.Class_stringlist_from_map();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "stringlist<-map", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_string), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_stringlist_from_map;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_stringlist_from_map;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_map inputval = (Core.Type_map)value;
      Core.Type_any outputval = Core.f_stringlist_from_map(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_map map = Core.f_any_from_any(Core.t_map, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_stringlist_from_map(map);
      return output;
    }

    @Override
    public Core.Type_stringlist vx_stringlist_from_map(final Core.Type_map map) {
      Core.Type_stringlist output = Core.f_stringlist_from_map(map);
      return output;
    }

  }

  public static final Core.Func_stringlist_from_map e_stringlist_from_map = new Core.Class_stringlist_from_map();
  public static final Core.Func_stringlist_from_map t_stringlist_from_map = new Core.Class_stringlist_from_map();

  public static Core.Type_stringlist f_stringlist_from_map(final Core.Type_map map) {
    Core.Type_stringlist output = Core.e_stringlist;
    output = Core.f_list_from_map_1(
      Core.t_stringlist,
      map,
      Core.t_any_from_key_value.vx_fn_new((key_any, value_any) -> {
        Core.Type_string key = Core.f_any_from_any(Core.t_string, key_any);
        Core.Type_any value = Core.f_any_from_any(Core.t_any, value_any);
        Core.Type_any output_1 = key;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function switch
   * Returns a value based on a logical switch
   * @param  {any-2} value
   * @param  {thenelselist} thenelselist
   * @return {any-1}
   * (func switch)
   */
  public interface Func_switch extends Core.Type_func, Core.Type_replfunc {
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_switch(final T generic_any_1, final U value, final Core.Type_thenelselist thenelselist);
  }

  public static class Class_switch extends Core.Class_base implements Func_switch {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_switch output = new Core.Class_switch();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_switch output = new Core.Class_switch();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "switch", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_switch;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_switch;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any generic_any_1 = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      Core.Type_thenelselist thenelselist = Core.f_any_from_any(Core.t_thenelselist, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_switch(generic_any_1, value, thenelselist);
      return output;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_switch(final T generic_any_1, final U value, final Core.Type_thenelselist thenelselist) {
      T output = Core.f_switch(generic_any_1, value, thenelselist);
      return output;
    }

  }

  public static final Core.Func_switch e_switch = new Core.Class_switch();
  public static final Core.Func_switch t_switch = new Core.Class_switch();

  public static <T extends Core.Type_any, U extends Core.Type_any> T f_switch(final T generic_any_1, final U value, final Core.Type_thenelselist thenelselist) {
    T output = Core.f_empty(generic_any_1);
    Core.Func_any_from_func fn_any = null;
    List<Core.Type_thenelse> listthenelse = thenelselist.vx_listthenelse();
    for (Core.Type_thenelse thenelse : listthenelse) {
      Core.Type_string code = thenelse.code();
      switch (code.vx_string()) {
      case ":case":
        Core.Type_any value2 = thenelse.value();
        Core.Type_boolean iseq = Core.f_eq(value, value2);
        if (iseq.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case ":casemany":
        Core.Type_list values = thenelse.values();
        Core.Type_boolean iscontain = Core.f_contains_1(values, value);
        if (iscontain.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case ":else":
        fn_any = thenelse.fn_any();
        break;
      }
      if (fn_any != null) {
        break;
      }
    }
    if (fn_any != null) {
      output = fn_any.vx_any_from_func(generic_any_1);
    };
    return output;
  }

  /**
   * @function then
   * Returns a thenelse struct from a given condition function and value function
   * @param  {boolean<-func} fn-cond
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func then)
   */
  public interface Func_then extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_thenelse vx_then(final Core.Func_boolean_from_func fn_cond, final Core.Func_any_from_func fn_any);
  }

  public static class Class_then extends Core.Class_base implements Func_then {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_then output = new Core.Class_then();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_then output = new Core.Class_then();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "then", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_then;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_then;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Func_boolean_from_func fn_cond = Core.f_any_from_any(Core.t_boolean_from_func, arglist.vx_any(Core.vx_new_int(0)));
      Core.Func_any_from_func fn_any = Core.f_any_from_any(Core.t_any_from_func, arglist.vx_any(Core.vx_new_int(1)));
      output = Core.f_then(fn_cond, fn_any);
      return output;
    }

    @Override
    public Core.Type_thenelse vx_then(final Core.Func_boolean_from_func fn_cond, final Core.Func_any_from_func fn_any) {
      Core.Type_thenelse output = Core.f_then(fn_cond, fn_any);
      return output;
    }

  }

  public static final Core.Func_then e_then = new Core.Class_then();
  public static final Core.Func_then t_then = new Core.Class_then();

  public static Core.Type_thenelse f_then(final Core.Func_boolean_from_func fn_cond, final Core.Func_any_from_func fn_any) {
    Core.Type_thenelse output = Core.e_thenelse;
    output = Core.f_new(
      Core.t_thenelse,
      Core.vx_new(
        Core.t_anylist,
        Core.vx_new_string(":code"),
        Core.vx_new_string(":then"),
        Core.vx_new_string(":fn-cond"),
        fn_cond,
        Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function traits_from_typedef
   * Return trait list from type
   * @param  {typedef} vtypedef
   * @return {typelist}
   * (func traits<-typedef)
   */
  public interface Func_traits_from_typedef extends Core.Func_any_from_any {
    public Core.Type_typelist vx_traits_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_traits_from_typedef extends Core.Class_base implements Func_traits_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_traits_from_typedef output = new Core.Class_traits_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_traits_from_typedef output = new Core.Class_traits_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "traits<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_any), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_traits_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_traits_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_traits_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_traits_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_typelist vx_traits_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_typelist output = Core.f_traits_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_traits_from_typedef e_traits_from_typedef = new Core.Class_traits_from_typedef();
  public static final Core.Func_traits_from_typedef t_traits_from_typedef = new Core.Class_traits_from_typedef();

  public static Core.Type_typelist f_traits_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_typelist output = Core.e_typelist;
    output = vtypedef.traits();
    return output;
  }

  /**
   * @function type_from_any
   * Gets the Type of a given Value
   * @param  {any-1} value
   * @return {any}
   * (func type<-any)
   */
  public interface Func_type_from_any extends Core.Func_any_from_any {
    public Core.Type_any vx_type_from_any(final Core.Type_any value);
  }

  public static class Class_type_from_any extends Core.Class_base implements Func_type_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_type_from_any output = new Core.Class_type_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_type_from_any output = new Core.Class_type_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "type<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_type_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_type_from_any;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_type_from_any(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_type_from_any(value);
      return output;
    }

    @Override
    public Core.Type_any vx_type_from_any(final Core.Type_any value) {
      Core.Type_any output = Core.f_type_from_any(value);
      return output;
    }

  }

  public static final Core.Func_type_from_any e_type_from_any = new Core.Class_type_from_any();
  public static final Core.Func_type_from_any t_type_from_any = new Core.Class_type_from_any();

  public static Core.Type_any f_type_from_any(final Core.Type_any value) {
    Core.Type_any output = Core.e_any;
    output = value.vx_type();
    return output;
  }

  /**
   * @function typedef_from_any
   * Gets the typedef of a given value
   * @param  {any} value
   * @return {typedef}
   * (func typedef<-any)
   */
  public interface Func_typedef_from_any extends Core.Func_any_from_any {
    public Core.Type_typedef vx_typedef_from_any(final Core.Type_any value);
  }

  public static class Class_typedef_from_any extends Core.Class_base implements Func_typedef_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_typedef_from_any output = new Core.Class_typedef_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_typedef_from_any output = new Core.Class_typedef_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typedef_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typedef_from_any;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_typedef_from_any(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_typedef_from_any(value);
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef_from_any(final Core.Type_any value) {
      Core.Type_typedef output = Core.f_typedef_from_any(value);
      return output;
    }

  }

  public static final Core.Func_typedef_from_any e_typedef_from_any = new Core.Class_typedef_from_any();
  public static final Core.Func_typedef_from_any t_typedef_from_any = new Core.Class_typedef_from_any();

  public static Core.Type_typedef f_typedef_from_any(final Core.Type_any value) {
    Core.Type_typedef output = Core.e_typedef;
    output = Core.f_typedef_from_type(
      Core.f_type_from_any(
        value
      )
    );
    return output;
  }

  /**
   * @function typedef_from_type
   * Gets the typedef of a given type
   * @param  {any} value
   * @return {typedef}
   * (func typedef<-type)
   */
  public interface Func_typedef_from_type extends Core.Func_any_from_any {
    public Core.Type_typedef vx_typedef_from_type(final Core.Type_any value);
  }

  public static class Class_typedef_from_type extends Core.Class_base implements Func_typedef_from_type {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_typedef_from_type output = new Core.Class_typedef_from_type();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_typedef_from_type output = new Core.Class_typedef_from_type();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-type", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typedef_from_type;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typedef_from_type;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_typedef_from_type(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_typedef_from_type(value);
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef_from_type(final Core.Type_any value) {
      Core.Type_typedef output = Core.f_typedef_from_type(value);
      return output;
    }

  }

  public static final Core.Func_typedef_from_type e_typedef_from_type = new Core.Class_typedef_from_type();
  public static final Core.Func_typedef_from_type t_typedef_from_type = new Core.Class_typedef_from_type();

  public static Core.Type_typedef f_typedef_from_type(final Core.Type_any value) {
    Core.Type_typedef output = Core.e_typedef;
    output = value.vx_typedef();
    return output;
  }

  /**
   * @function typename_from_any
   * Gets the typename of a given value
   * @param  {any-2} value
   * @return {string}
   * (func typename<-any)
   */
  public interface Func_typename_from_any extends Core.Func_any_from_any {
    public Core.Type_string vx_typename_from_any(final Core.Type_any value);
  }

  public static class Class_typename_from_any extends Core.Class_base implements Func_typename_from_any {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_typename_from_any output = new Core.Class_typename_from_any();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_typename_from_any output = new Core.Class_typename_from_any();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "typename<-any", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typename_from_any;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typename_from_any;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_typename_from_any(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any value = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_typename_from_any(value);
      return output;
    }

    @Override
    public Core.Type_string vx_typename_from_any(final Core.Type_any value) {
      Core.Type_string output = Core.f_typename_from_any(value);
      return output;
    }

  }

  public static final Core.Func_typename_from_any e_typename_from_any = new Core.Class_typename_from_any();
  public static final Core.Func_typename_from_any t_typename_from_any = new Core.Class_typename_from_any();

  public static Core.Type_string f_typename_from_any(final Core.Type_any value) {
    Core.Type_string output = Core.e_string;
    output = Core.f_typename_from_type(
      Core.f_type_from_any(
        value
      )
    );
    return output;
  }

  /**
   * @function typename_from_type
   * Get the name of a given type
   * @param  {any} type
   * @return {string}
   * (func typename<-type)
   */
  public interface Func_typename_from_type extends Core.Func_any_from_any {
    public Core.Type_string vx_typename_from_type(final Core.Type_any type);
  }

  public static class Class_typename_from_type extends Core.Class_base implements Func_typename_from_type {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_typename_from_type output = new Core.Class_typename_from_type();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_typename_from_type output = new Core.Class_typename_from_type();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "typename<-type", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typename_from_type;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typename_from_type;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_any inputval = (Core.Type_any)value;
      Core.Type_any outputval = Core.f_typename_from_type(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_any type = Core.f_any_from_any(Core.t_any, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_typename_from_type(type);
      return output;
    }

    @Override
    public Core.Type_string vx_typename_from_type(final Core.Type_any type) {
      Core.Type_string output = Core.f_typename_from_type(type);
      return output;
    }

  }

  public static final Core.Func_typename_from_type e_typename_from_type = new Core.Class_typename_from_type();
  public static final Core.Func_typename_from_type t_typename_from_type = new Core.Class_typename_from_type();

  public static Core.Type_string f_typename_from_type(final Core.Type_any type) {
    Core.Type_string output = Core.e_string;
    output = Core.f_typename_from_typedef(
      Core.f_typedef_from_type(
        type
      )
    );
    return output;
  }

  /**
   * @function typename_from_typedef
   * Get the name of a given type
   * @param  {typedef} vtypedef
   * @return {string}
   * (func typename<-typedef)
   */
  public interface Func_typename_from_typedef extends Core.Func_any_from_any {
    public Core.Type_string vx_typename_from_typedef(final Core.Type_typedef vtypedef);
  }

  public static class Class_typename_from_typedef extends Core.Class_base implements Func_typename_from_typedef {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_typename_from_typedef output = new Core.Class_typename_from_typedef();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_typename_from_typedef output = new Core.Class_typename_from_typedef();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "typename<-typedef", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typename_from_typedef;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typename_from_typedef;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typedef inputval = (Core.Type_typedef)value;
      Core.Type_any outputval = Core.f_typename_from_typedef(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typedef vtypedef = Core.f_any_from_any(Core.t_typedef, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_typename_from_typedef(vtypedef);
      return output;
    }

    @Override
    public Core.Type_string vx_typename_from_typedef(final Core.Type_typedef vtypedef) {
      Core.Type_string output = Core.f_typename_from_typedef(vtypedef);
      return output;
    }

  }

  public static final Core.Func_typename_from_typedef e_typename_from_typedef = new Core.Class_typename_from_typedef();
  public static final Core.Func_typename_from_typedef t_typename_from_typedef = new Core.Class_typename_from_typedef();

  public static Core.Type_string f_typename_from_typedef(final Core.Type_typedef vtypedef) {
    Core.Type_string output = Core.e_string;
    output = Core.f_new(
      Core.t_string,
      Core.vx_new(
        Core.t_anylist,
        vtypedef.pkgname(),
        Core.vx_new_string("/"),
        vtypedef.name()
      )
    );
    return output;
  }

  /**
   * @function typenames_from_typelist
   * Get the names from a type list
   * @param  {typelist} typelist
   * @return {stringlist}
   * (func typenames<-typelist)
   */
  public interface Func_typenames_from_typelist extends Core.Func_any_from_any {
    public Core.Type_stringlist vx_typenames_from_typelist(final Core.Type_typelist typelist);
  }

  public static class Class_typenames_from_typelist extends Core.Class_base implements Func_typenames_from_typelist {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_typenames_from_typelist output = new Core.Class_typenames_from_typelist();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_typenames_from_typelist output = new Core.Class_typenames_from_typelist();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "typenames<-typelist", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          Core.e_typelist, // traits
          Core.vx_new(Core.t_typelist, Core.t_string), // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_typenames_from_typelist;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_typenames_from_typelist;
      return output;
    }

    @Override
    public Core.Func_any_from_any vx_fn_new(Core.Class_any_from_any.IFn fn) {
      return Core.e_any_from_any;
    }

    @Override
    public <T extends Core.Type_any, U extends Core.Type_any> T vx_any_from_any(final T generic_any_1, final U value) {
      T output = Core.f_empty(generic_any_1);
      Core.Type_typelist inputval = (Core.Type_typelist)value;
      Core.Type_any outputval = Core.f_typenames_from_typelist(inputval);
      output = Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_typelist typelist = Core.f_any_from_any(Core.t_typelist, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_typenames_from_typelist(typelist);
      return output;
    }

    @Override
    public Core.Type_stringlist vx_typenames_from_typelist(final Core.Type_typelist typelist) {
      Core.Type_stringlist output = Core.f_typenames_from_typelist(typelist);
      return output;
    }

  }

  public static final Core.Func_typenames_from_typelist e_typenames_from_typelist = new Core.Class_typenames_from_typelist();
  public static final Core.Func_typenames_from_typelist t_typenames_from_typelist = new Core.Class_typenames_from_typelist();

  public static Core.Type_stringlist f_typenames_from_typelist(final Core.Type_typelist typelist) {
    Core.Type_stringlist output = Core.e_stringlist;
    output = Core.f_list_from_list_1(
      Core.t_stringlist,
      typelist,
      Core.t_any_from_any.vx_fn_new((type_any) -> {
        Core.Type_any type = Core.f_any_from_any(Core.t_any, type_any);
        Core.Type_any output_1 = Core.f_typename_from_type(
          type
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function user_from_context
   * Returns the current user from context.
   * @return {user}
   * (func user<-context)
   */
  public interface Func_user_from_context extends Core.Type_func, Core.Type_replfunc {
    public Core.Type_user vx_user_from_context(final Core.Type_context context);
  }

  public static class Class_user_from_context extends Core.Class_base implements Func_user_from_context {

    @Override
    public Core.Type_any vx_new(final Object... vals) {
      Core.Class_user_from_context output = new Core.Class_user_from_context();
      return output;
    }

    @Override
    public Core.Type_any vx_copy(final Object... vals) {
      Core.Class_user_from_context output = new Core.Class_user_from_context();
      return output;
    }

    @Override
    public Core.Type_typedef vx_typedef() {
      Core.Type_typedef output = Core.t_func.vx_typedef();
      return output;
    }

    @Override
    public Core.Type_funcdef vx_funcdef() {
      Core.Type_funcdef output = Core.funcdef_new(
        "vx/core", // pkgname
        "user<-context", // name
        0, // idx
        false, // async
        Core.typedef_new(
          "vx/core", // pkgname
          "user", // name
          ":struct", // extends
          Core.e_typelist, // traits
          Core.e_typelist, // allowtypes
          Core.e_typelist, // disallowtypes
          Core.e_funclist, // allowfuncs
          Core.e_funclist, // disallowfuncs
          Core.e_anylist, // allowvalues
          Core.e_anylist, // disallowvalues
          Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    @Override
    public Core.Type_any vx_empty() {
      Core.Type_any output = Core.e_user_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_type() {
      Core.Type_any output = Core.t_user_from_context;
      return output;
    }

    @Override
    public Core.Type_any vx_repl(Core.Type_anylist arglist) {
      Core.Type_any output = Core.e_any;
      Core.Type_context context = Core.f_any_from_any(Core.t_context, arglist.vx_any(Core.vx_new_int(0)));
      output = Core.f_user_from_context(context);
      return output;
    }

    @Override
    public Core.Type_user vx_user_from_context(final Core.Type_context context) {
      Core.Type_user output = Core.f_user_from_context(context);
      return output;
    }

  }

  public static final Core.Func_user_from_context e_user_from_context = new Core.Class_user_from_context();
  public static final Core.Func_user_from_context t_user_from_context = new Core.Class_user_from_context();

  public static Core.Type_user f_user_from_context(final Core.Type_context context) {
    Core.Type_user output = Core.e_user;
    output = Core.f_session_from_context(
      context
    ).user();
    return output;
  }


  static {
    Const_false.const_new(c_false);
    Const_global.const_new(c_global);
    Const_infinity.const_new(c_infinity);
    Const_mempool_active.const_new(c_mempool_active);
    Const_msg_error.const_new(c_msg_error);
    Const_msg_info.const_new(c_msg_info);
    Const_msg_severe.const_new(c_msg_severe);
    Const_msg_warning.const_new(c_msg_warning);
    Const_neginfinity.const_new(c_neginfinity);
    Const_newline.const_new(c_newline);
    Const_notanumber.const_new(c_notanumber);
    Const_nothing.const_new(c_nothing);
    Const_path_test_resources.const_new(c_path_test_resources);
    Const_quote.const_new(c_quote);
    Const_true.const_new(c_true);
    Map<String, Core.Type_any> maptype = new LinkedHashMap<String, Core.Type_any>();
    Map<String, Core.Type_any> mapconst = new LinkedHashMap<String, Core.Type_any>();
    Map<String, Core.Type_func> mapfunc = new LinkedHashMap<String, Core.Type_func>();
    maptype.put("any", Core.t_any);
    maptype.put("any-async<-func", Core.t_any_async_from_func);
    maptype.put("any<-anylist", Core.t_any_from_anylist);
    maptype.put("anylist", Core.t_anylist);
    maptype.put("anymap", Core.t_anymap);
    maptype.put("anytype", Core.t_anytype);
    maptype.put("arg", Core.t_arg);
    maptype.put("arglist", Core.t_arglist);
    maptype.put("argmap", Core.t_argmap);
    maptype.put("boolean", Core.t_boolean);
    maptype.put("booleanlist", Core.t_booleanlist);
    maptype.put("collection", Core.t_collection);
    maptype.put("compilelanguages", Core.t_compilelanguages);
    maptype.put("connect", Core.t_connect);
    maptype.put("connectlist", Core.t_connectlist);
    maptype.put("connectmap", Core.t_connectmap);
    maptype.put("const", Core.t_const);
    maptype.put("constdef", Core.t_constdef);
    maptype.put("constlist", Core.t_constlist);
    maptype.put("constmap", Core.t_constmap);
    maptype.put("context", Core.t_context);
    maptype.put("date", Core.t_date);
    maptype.put("decimal", Core.t_decimal);
    maptype.put("error", Core.t_error);
    maptype.put("float", Core.t_float);
    maptype.put("func", Core.t_func);
    maptype.put("funcdef", Core.t_funcdef);
    maptype.put("funclist", Core.t_funclist);
    maptype.put("funcmap", Core.t_funcmap);
    maptype.put("int", Core.t_int);
    maptype.put("intlist", Core.t_intlist);
    maptype.put("intmap", Core.t_intmap);
    maptype.put("list", Core.t_list);
    maptype.put("listtype", Core.t_listtype);
    maptype.put("locale", Core.t_locale);
    maptype.put("map", Core.t_map);
    maptype.put("maptype", Core.t_maptype);
    maptype.put("mempool", Core.t_mempool);
    maptype.put("msg", Core.t_msg);
    maptype.put("msgblock", Core.t_msgblock);
    maptype.put("msgblocklist", Core.t_msgblocklist);
    maptype.put("msglist", Core.t_msglist);
    maptype.put("none", Core.t_none);
    maptype.put("notype", Core.t_notype);
    maptype.put("number", Core.t_number);
    maptype.put("numberlist", Core.t_numberlist);
    maptype.put("numbermap", Core.t_numbermap);
    maptype.put("package", Core.t_package);
    maptype.put("packagemap", Core.t_packagemap);
    maptype.put("permission", Core.t_permission);
    maptype.put("permissionlist", Core.t_permissionlist);
    maptype.put("permissionmap", Core.t_permissionmap);
    maptype.put("project", Core.t_project);
    maptype.put("security", Core.t_security);
    maptype.put("session", Core.t_session);
    maptype.put("setting", Core.t_setting);
    maptype.put("state", Core.t_state);
    maptype.put("statelistener", Core.t_statelistener);
    maptype.put("statelistenermap", Core.t_statelistenermap);
    maptype.put("string", Core.t_string);
    maptype.put("stringlist", Core.t_stringlist);
    maptype.put("stringlistlist", Core.t_stringlistlist);
    maptype.put("stringmap", Core.t_stringmap);
    maptype.put("stringmutablemap", Core.t_stringmutablemap);
    maptype.put("struct", Core.t_struct);
    maptype.put("thenelse", Core.t_thenelse);
    maptype.put("thenelselist", Core.t_thenelselist);
    maptype.put("translation", Core.t_translation);
    maptype.put("translationlist", Core.t_translationlist);
    maptype.put("translationmap", Core.t_translationmap);
    maptype.put("type", Core.t_type);
    maptype.put("typedef", Core.t_typedef);
    maptype.put("typelist", Core.t_typelist);
    maptype.put("typemap", Core.t_typemap);
    maptype.put("user", Core.t_user);
    maptype.put("value", Core.t_value);
    mapconst.put("false", Core.c_false);
    mapconst.put("global", Core.c_global);
    mapconst.put("infinity", Core.c_infinity);
    mapconst.put("mempool-active", Core.c_mempool_active);
    mapconst.put("msg-error", Core.c_msg_error);
    mapconst.put("msg-info", Core.c_msg_info);
    mapconst.put("msg-severe", Core.c_msg_severe);
    mapconst.put("msg-warning", Core.c_msg_warning);
    mapconst.put("neginfinity", Core.c_neginfinity);
    mapconst.put("newline", Core.c_newline);
    mapconst.put("notanumber", Core.c_notanumber);
    mapconst.put("nothing", Core.c_nothing);
    mapconst.put("path-test-resources", Core.c_path_test_resources);
    mapconst.put("quote", Core.c_quote);
    mapconst.put("true", Core.c_true);
    mapfunc.put("!", Core.t_not);
    mapfunc.put("!-empty", Core.t_notempty);
    mapfunc.put("!-empty_1", Core.t_notempty_1);
    mapfunc.put("!=", Core.t_ne);
    mapfunc.put("!==", Core.t_neqeq);
    mapfunc.put("*", Core.t_multiply);
    mapfunc.put("*_1", Core.t_multiply_1);
    mapfunc.put("*_2", Core.t_multiply_2);
    mapfunc.put("*_3", Core.t_multiply_3);
    mapfunc.put("+", Core.t_plus);
    mapfunc.put("+_1", Core.t_plus_1);
    mapfunc.put("+_2", Core.t_plus_2);
    mapfunc.put("+_3", Core.t_plus_3);
    mapfunc.put("+1", Core.t_plus1);
    mapfunc.put("-", Core.t_minus);
    mapfunc.put("-_1", Core.t_minus_1);
    mapfunc.put("-_2", Core.t_minus_2);
    mapfunc.put("-_3", Core.t_minus_3);
    mapfunc.put("-1", Core.t_minus1);
    mapfunc.put(".", Core.t_dotmethod);
    mapfunc.put("/", Core.t_divide);
    mapfunc.put("<", Core.t_lt);
    mapfunc.put("<_1", Core.t_lt_1);
    mapfunc.put("<-", Core.t_chainfirst);
    mapfunc.put("<<-", Core.t_chainlast);
    mapfunc.put("<=", Core.t_le);
    mapfunc.put("<=_1", Core.t_le_1);
    mapfunc.put("=", Core.t_eq);
    mapfunc.put("=_1", Core.t_eq_1);
    mapfunc.put("==", Core.t_eqeq);
    mapfunc.put(">", Core.t_gt);
    mapfunc.put(">_1", Core.t_gt_1);
    mapfunc.put(">=", Core.t_ge);
    mapfunc.put(">=_1", Core.t_ge_1);
    mapfunc.put("allowfuncs<-security", Core.t_allowfuncs_from_security);
    mapfunc.put("allowtypenames<-typedef", Core.t_allowtypenames_from_typedef);
    mapfunc.put("allowtypes<-typedef", Core.t_allowtypes_from_typedef);
    mapfunc.put("and", Core.t_and);
    mapfunc.put("and_1", Core.t_and_1);
    mapfunc.put("any<-any", Core.t_any_from_any);
    mapfunc.put("any<-any-async", Core.t_any_from_any_async);
    mapfunc.put("any<-any-context", Core.t_any_from_any_context);
    mapfunc.put("any<-any-context-async", Core.t_any_from_any_context_async);
    mapfunc.put("any<-any-key-value", Core.t_any_from_any_key_value);
    mapfunc.put("any<-func", Core.t_any_from_func);
    mapfunc.put("any<-func-async", Core.t_any_from_func_async);
    mapfunc.put("any<-int", Core.t_any_from_int);
    mapfunc.put("any<-int-any", Core.t_any_from_int_any);
    mapfunc.put("any<-key-value", Core.t_any_from_key_value);
    mapfunc.put("any<-key-value-async", Core.t_any_from_key_value_async);
    mapfunc.put("any<-list", Core.t_any_from_list);
    mapfunc.put("any<-list-start-reduce", Core.t_any_from_list_start_reduce);
    mapfunc.put("any<-list-start-reduce-next", Core.t_any_from_list_start_reduce_next);
    mapfunc.put("any<-map", Core.t_any_from_map);
    mapfunc.put("any<-map-start-reduce", Core.t_any_from_map_start_reduce);
    mapfunc.put("any<-none", Core.t_any_from_none);
    mapfunc.put("any<-none-async", Core.t_any_from_none_async);
    mapfunc.put("any<-reduce", Core.t_any_from_reduce);
    mapfunc.put("any<-reduce-async", Core.t_any_from_reduce_async);
    mapfunc.put("any<-reduce-next", Core.t_any_from_reduce_next);
    mapfunc.put("any<-reduce-next-async", Core.t_any_from_reduce_next_async);
    mapfunc.put("any<-struct", Core.t_any_from_struct);
    mapfunc.put("async", Core.t_async);
    mapfunc.put("boolean-permission<-func", Core.t_boolean_permission_from_func);
    mapfunc.put("boolean-write<-map-name-value", Core.t_boolean_write_from_map_name_value);
    mapfunc.put("boolean<-any", Core.t_boolean_from_any);
    mapfunc.put("boolean<-func", Core.t_boolean_from_func);
    mapfunc.put("boolean<-none", Core.t_boolean_from_none);
    mapfunc.put("case", Core.t_case);
    mapfunc.put("case_1", Core.t_case_1);
    mapfunc.put("compare", Core.t_compare);
    mapfunc.put("contains", Core.t_contains);
    mapfunc.put("contains_1", Core.t_contains_1);
    mapfunc.put("context-main", Core.t_context_main);
    mapfunc.put("copy", Core.t_copy);
    mapfunc.put("else", Core.t_else);
    mapfunc.put("empty", Core.t_empty);
    mapfunc.put("extends<-any", Core.t_extends_from_any);
    mapfunc.put("extends<-typedef", Core.t_extends_from_typedef);
    mapfunc.put("first<-list", Core.t_first_from_list);
    mapfunc.put("first<-list-any<-any", Core.t_first_from_list_any_from_any);
    mapfunc.put("float<-string", Core.t_float_from_string);
    mapfunc.put("fn", Core.t_fn);
    mapfunc.put("funcdef<-func", Core.t_funcdef_from_func);
    mapfunc.put("funcname<-funcdef", Core.t_funcname_from_funcdef);
    mapfunc.put("if", Core.t_if);
    mapfunc.put("if_1", Core.t_if_1);
    mapfunc.put("if_2", Core.t_if_2);
    mapfunc.put("int<-func", Core.t_int_from_func);
    mapfunc.put("int<-string", Core.t_int_from_string);
    mapfunc.put("is-empty", Core.t_is_empty);
    mapfunc.put("is-empty_1", Core.t_is_empty_1);
    mapfunc.put("is-endswith", Core.t_is_endswith);
    mapfunc.put("is-float", Core.t_is_float);
    mapfunc.put("is-func", Core.t_is_func);
    mapfunc.put("is-int", Core.t_is_int);
    mapfunc.put("is-number", Core.t_is_number);
    mapfunc.put("is-pass<-permission", Core.t_is_pass_from_permission);
    mapfunc.put("last<-list", Core.t_last_from_list);
    mapfunc.put("length", Core.t_length);
    mapfunc.put("length_1", Core.t_length_1);
    mapfunc.put("length_2", Core.t_length_2);
    mapfunc.put("let", Core.t_let);
    mapfunc.put("let-async", Core.t_let_async);
    mapfunc.put("list-join<-list", Core.t_list_join_from_list);
    mapfunc.put("list-join<-list_1", Core.t_list_join_from_list_1);
    mapfunc.put("list<-list", Core.t_list_from_list);
    mapfunc.put("list<-list_1", Core.t_list_from_list_1);
    mapfunc.put("list<-list-async", Core.t_list_from_list_async);
    mapfunc.put("list<-list-intany", Core.t_list_from_list_intany);
    mapfunc.put("list<-map", Core.t_list_from_map);
    mapfunc.put("list<-map_1", Core.t_list_from_map_1);
    mapfunc.put("list<-map-async", Core.t_list_from_map_async);
    mapfunc.put("list<-type", Core.t_list_from_type);
    mapfunc.put("log", Core.t_log);
    mapfunc.put("log_1", Core.t_log_1);
    mapfunc.put("main", Core.t_main);
    mapfunc.put("map<-list", Core.t_map_from_list);
    mapfunc.put("map<-map", Core.t_map_from_map);
    mapfunc.put("map<-map_1", Core.t_map_from_map_1);
    mapfunc.put("msg<-error", Core.t_msg_from_error);
    mapfunc.put("msg<-error_1", Core.t_msg_from_error_1);
    mapfunc.put("msg<-error_2", Core.t_msg_from_error_2);
    mapfunc.put("msg<-warning", Core.t_msg_from_warning);
    mapfunc.put("msgblock<-msgblock-msg", Core.t_msgblock_from_msgblock_msg);
    mapfunc.put("msgblock<-msgblock-msgblock", Core.t_msgblock_from_msgblock_msgblock);
    mapfunc.put("name<-typedef", Core.t_name_from_typedef);
    mapfunc.put("native", Core.t_native);
    mapfunc.put("native<-any", Core.t_native_from_any);
    mapfunc.put("new", Core.t_new);
    mapfunc.put("number<-func", Core.t_number_from_func);
    mapfunc.put("or", Core.t_or);
    mapfunc.put("or_1", Core.t_or_1);
    mapfunc.put("package-global<-name", Core.t_package_global_from_name);
    mapfunc.put("packagename<-typedef", Core.t_packagename_from_typedef);
    mapfunc.put("path<-context-path", Core.t_path_from_context_path);
    mapfunc.put("path<-setting-path", Core.t_path_from_setting_path);
    mapfunc.put("permission<-id-context", Core.t_permission_from_id_context);
    mapfunc.put("properties<-typedef", Core.t_properties_from_typedef);
    mapfunc.put("proplast<-typedef", Core.t_proplast_from_typedef);
    mapfunc.put("resolve", Core.t_resolve);
    mapfunc.put("resolve_1", Core.t_resolve_1);
    mapfunc.put("resolve-async", Core.t_resolve_async);
    mapfunc.put("resolve-first", Core.t_resolve_first);
    mapfunc.put("resolve-list", Core.t_resolve_list);
    mapfunc.put("security<-context", Core.t_security_from_context);
    mapfunc.put("security<-user", Core.t_security_from_user);
    mapfunc.put("session<-context", Core.t_session_from_context);
    mapfunc.put("setting<-context", Core.t_setting_from_context);
    mapfunc.put("string-repeat", Core.t_string_repeat);
    mapfunc.put("string<-any", Core.t_string_from_any);
    mapfunc.put("string<-any-indent", Core.t_string_from_any_indent);
    mapfunc.put("string<-func", Core.t_string_from_func);
    mapfunc.put("string<-string-find-replace", Core.t_string_from_string_find_replace);
    mapfunc.put("stringlist<-map", Core.t_stringlist_from_map);
    mapfunc.put("switch", Core.t_switch);
    mapfunc.put("then", Core.t_then);
    mapfunc.put("traits<-typedef", Core.t_traits_from_typedef);
    mapfunc.put("type<-any", Core.t_type_from_any);
    mapfunc.put("typedef<-any", Core.t_typedef_from_any);
    mapfunc.put("typedef<-type", Core.t_typedef_from_type);
    mapfunc.put("typename<-any", Core.t_typename_from_any);
    mapfunc.put("typename<-type", Core.t_typename_from_type);
    mapfunc.put("typename<-typedef", Core.t_typename_from_typedef);
    mapfunc.put("typenames<-typelist", Core.t_typenames_from_typelist);
    mapfunc.put("user<-context", Core.t_user_from_context);
    Core.vx_global_package_set("vx/core", maptype, mapconst, mapfunc);
  }

}
