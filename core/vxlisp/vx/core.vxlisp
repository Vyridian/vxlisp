(package vx/core
 :libs (lib javafunction)
       (lib javacollectors)
       (lib javafuture)
 :doc "Core vxlisp Library. Unfortunately large because of interdependencies.")

(type any
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_any vx_type_from_any(vx_core::Type_any value) const;")
 :doc "Any Value for Variant Type")

(type any-async<-func : func
 :allowfuncs [any<-func any<-func-async]
 :doc        "A sync or async function that returns one value.")

(type any<-anylist : list
 :allowfuncs [any<-any]
 :doc        "List of any<-any")

(type anylist : list
 :allowtypes [any]
 :doc        "A list of any")

(type anymap : map
 :allowtypes [any]
 :doc        "A map of any")

(type anytype : type
 :doc     "Any Type that allows any Type as a Value")

(type arg : struct
 :properties [name    : string
              argtype : any
              fn-any  : any<-func
              doc     : string]
 :doc        "A function argument")

(type arglist : list
 :allowtypes [arg]
 :doc        "A list of arg")

(type argmap : map
 :allowtypes [arg]
 :doc        "A map of arg")

(type boolean
 :default     false
 :allowvalues [true false]
 :create
  (native
   :cpp
    "// :header
     bool vx_p_boolean = false;
     bool vx_boolean() const;"
   :csharp
    "internal bool vxboolean = false;

     // :implements
     public bool vx_boolean() {return vxboolean;}"
   :java
    "protected boolean vxboolean = false;

     @Override
     public boolean vx_boolean() {return vxboolean;}")
 :test (test-true true)
       (test-false false)
       (test-true (boolean true))
       (test-false (boolean false))
 :doc "Standard Boolean Type")

(type booleanlist : list
 :allowtypes [boolean])

(type collection
 :allowtypes [list map])

(type compilelanguages
 :default     :unknown
 :allowvalues [:unknown :cpp :csharp :java :js :kotlin :swift])

(type connect
 :doc "General connect trait")

(type connectlist : list
 :allowtypes [connect]
 :doc        "List of connect")

(type connectmap : map
 :allowtypes [connect]
 :doc        "Map of connect")

(type const : const
 :doc     "Original Constant Class.")

(type constdef : struct
 :properties [pkgname : string
              name    : string
              type    : any]
 :doc "Const Definition Class for inspecting properties.")

(type constlist : list
 :allowtypes [any]
 :doc        "List of Const.")

(type constmap : map
 :allowtypes [any]
 :doc        "Map of Const.")

(type context : struct
 :properties [code    : string
              session : session
              setting : setting
              state   : state]
 :doc "Context")

(type date : string
 :doc "A simple UTC date.")

(type decimal
 :traits  [number]
 :default 0
 :create
  (native
   :cpp
    "// :header
     std::string vx_p_decimal = “0.0”;
     float vx_float() const;
     std::string vx_string() const;"
   :csharp
    "internal string vxdecimal = “0.0”;

     // :implements
     public float vx_float() {
       return float.Parse(vxdecimal);
     }

     // :implements
     public string vx_string() {return vxdecimal;}

     // :implements
     public Type_decimal vx_new_from_string(string sval) {
       Class_decimal output = new Class_decimal();
       output.vxdecimal = sval;
       return output;
     }"
   :java
    "protected String vxdecimal = “0.0”;

     @Override
     public float vx_float() {
       return Float.parseFloat(vxdecimal);
     }

     @Override
     public String vx_string() {return vxdecimal;}

     @Override
     public Type_decimal vx_new_from_string(final String sval) {
       Class_decimal output = new Class_decimal();
       output.vxdecimal = sval;
       return output;
     }")
 :doc "A clean version of float like Java BigDecimal.")

(type error
 :doc "Error Type")

(type float
 :default 0.0
 :traits  [number]
 :create
  (native
   :cpp
    "// :header
     float vx_p_float = 0;
     float vx_float() const;"
   :csharp
    "internal float vxfloat = 0;

     // :implements
     public float vx_float() {return vxfloat;}"
   :java
    "protected float vxfloat = 0;

     @Override
     public float vx_float() {return vxfloat;}")
 :test (test 4.5 (float 4.5))
 :doc  "Standard Floating Point Number")

(type func : func
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_funcdef vx_funcdef() const;")
 :test (test
        5
        (let
         [funcvar : + := +]
         (funcvar 2 3)))
 :doc "Original Function Class.")

(type funcdef : struct
 :properties
  [pkgname : string
   name    : string
   idx     : int
   type    : any
   async   : boolean]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_funcdef vx_funcdef_new(
       std::string pkgname,
       std::string name,
       long idx,
       bool async,
       vx_core::Type_any typ
     );")
 :doc "Func Definition Class for inspecting properties.")

(type funclist : list
 :allowtypes [func]
 :doc        "List of Func.")

(type funcmap : map
 :allowtypes [func]
 :doc        "Map of Func.")

(type int
 :default     0
 :allowvalues [infinity neginfinity]
 :traits      [number]
 :create
  (native
   :cpp
    "// :header
     long vx_p_int = 0;
     long vx_int() const;"
   :csharp
    "internal int vxint = 0;

     // :implements
     public int vx_int() {return vxint;}"
   :java
    "protected int vxint = 0;

     @Override
     public int vx_int() {return vxint;}")
 :test (test-true  (is-int 4))
       (test-true  (is-int "4"))
       (test-true  (is-int infinity))
       (test-true  (is-int neginfinity))
       (test-true  (is-int notanumber))
       (test-false (is-int "a"))
       (test-false (is-int 5.5))
 :doc  "A simple integer.")

(type intlist : list
 :allowtypes [int]
 :doc        "A list of int.")

(type intmap : map
 :allowtypes [int]
 :doc        "A map of int.")

(type list : list
 :allowtypes [any]
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_listany vx_p_list;
     vx_core::vx_Type_listany vx_list() const;
     vx_core::Type_any vx_get_any(vx_core::Type_int index) const;
     vx_core::Type_any vx_new_from_list(vx_core::vx_Type_listany listval) const;")
 :doc "A simple untyped list.")

(type listtype : type
 :doc "A generic type that extends :list.")

(type locale : struct
 :doc "Localization data.")

(type map : map
 :allowtypes [any]
 :create
  (native
   :cpp
    "// :header
     std::vector<std::string> vx_p_keys;
     vx_core::vx_Type_mapany vx_p_map;
     vx_core::vx_Type_mapany vx_map() const;
     vx_core::Type_any vx_get_any(vx_core::Type_string key) const;
     vx_core::Type_boolean vx_set(vx_core::Type_string name, vx_core::Type_any value);
     vx_core::Type_any vx_new_from_map(vx_core::vx_Type_mapany mapval) const;")
 :doc "A simple untyped map.")

(type maptype : type
 :doc "A generic type that extends :map.")

(type mempool : struct
 :properties [valuepool : value]
 :create
  (native
   :java
    "private int vx_max = 20;

     private Map<String, Deque<Core.Type_any>> vx_maplistany = new ConcurrentHashMap<>();

     @Override
     public <T extends Core.Type_any> T vx_restore(final T generic_any_1) {
       T output = null;
       String typename = Core.f_typename_from_any(generic_any_1).vx_string();
       Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
       if (listany == null) {
       } else if (!listany.isEmpty()) {
         Core.Type_any any = listany.remove();
         if (any != null) {
           output = Core.f_any_from_any(generic_any_1, any);
         }
       }
       return output;
     }

     @Override
     public void vx_recycle(final Core.Type_any addany) {
       String typename = Core.f_typename_from_any(addany).vx_string();
       Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
       boolean isdestroy = true;
       int imax = this.vx_max;
       if (imax == 0) {
       } else if (listany == null) {
        isdestroy = false;
        listany = new ConcurrentLinkedDeque<Core.Type_any>();
        listany.add(addany);
        this.vx_maplistany.put(typename, listany);
       } else {
        int ilen = listany.size();
        if (ilen < imax) {
          listany.add(addany);
        }
       }
       if (isdestroy) {
         // destroy
       }
     }

     @Override
     public void vx_recyclelist(final List<Core.Type_any> addlistany) {
       for (Core.Type_any addany : addlistany) {
         this.vx_recycle(addany);
       }
     }")
 :doc "Memory Pool")

(type msg : struct
 :properties
  [code     : string  :doc "Message Code"
   detail   : any     :doc "Message Detail"
   path     : string  :doc "Message Path"
   severity : int     :doc "Message Severity"
   text     : string  :doc "Message Text"]
 :create
  (native
   :cpp
    "// :header
     std::exception err;"
   :csharp
    "public Exception? err = null;"
   :java
    "public Exception err = null;")
 :doc "Message Type for error handling")

(type msgblock : struct
 :properties
  [msgs      : msglist
   msgblocks : msgblocklist]
 :doc "Block of Messages")

(type msgblocklist : list
 :allowtypes [msgblock]
 :doc        "List of Message Blocks")

(type msglist : list
 :allowtypes [msg]
 :doc        "List of Messages")

(type none
 :doc "No Type. No type is returned at all. e.g. Void")

(type notype
 :doc "No Type that allows no Types as a Value")

(type number
 :default    0
 :allowtypes [int float decimal]
 :doc        "A generic number that could be int, float, or decimal.")

(type numberlist : list
 :allowtypes [number]
 :doc "A list of number.")

(type numbermap : map
 :allowtypes [number]
 :doc "A map of number.")

(type package : struct
 :properties [pkgname  : string
              constmap : constmap
              funcmap  : funcmap
              typemap  : typemap
              emptymap : map]
 :doc "A package that store types, consts and funcs.")

(type packagemap : map
 :allowtypes [package])

(type permission : struct
 :properties [id : string]
 :doc "Permission")

(type permissionlist : list
 :allowtypes [permission]
 :doc "List of Permission")

(type permissionmap : map
 :allowtypes [permission]
 :doc "Map of Permission")

(type project : struct
 :properties [packagemap : packagemap]
 :doc "A project.")

(type security : struct
 :properties [allowfuncs    : funclist
              permissions   : permissionlist
              permissionmap : permissionmap]
 :doc        "Security rules")

(type session : struct
 :properties
  [user           : user
   connectlist    : connectlist
   connectmap     : connectmap
   locale         : locale
   translation    : translation
   translationmap : translationmap]
 :doc        "Session")

(type setting : struct
 :properties [pathmap : stringmap]
 :doc        "Settings")

(type state : struct
 :properties [statelistenermap : statelistenermap]
 :doc "State. Note that this type is has mutable values.")

(type statelistener : struct
 :properties
  [name       : string
   value      : any
   fn-boolean : boolean<-none])

(type statelistenermap : map
 :allowtypes [statelistener]
 :mutable
 :doc "Mutable map of statelisteners")

(type string : string
 :default ""
 :create
  (native
   :cpp
    "// :header
     std::string vx_p_string = “”;
     std::string vx_string() const;"
   :csharp
    "internal string vxstring = “”;

     // :implements
     public string vx_string() {
       return vxstring;
     }"
   :java
    "protected String vxstring = “”;

     @Override
     public String vx_string() {
       return vxstring;
     }")
 :test (test "a" (string "a"))
       (test "ab" (string "a" "b"))
 :doc  "A simple string.")

(type stringlist : list
 :allowtypes [string]
 :doc "A list of string.")

(type stringlistlist : list
 :allowtypes [stringlist]
 :doc "A list of stringlist.")

(type stringmap : map
 :allowtypes [string]
 :doc "A map of string.")

(type stringmutablemap : map
 :allowtypes [string]
 :mutable
 :doc "A mutable map of string. Note: Mutables are dangerous.")

(type struct : struct
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_mapany vx_map() const;
     vx_core::Type_any vx_get_any(vx_core::Type_string key) const;")
 :doc "Struct is the type of all structures/objects with properties.")

(type thenelse : struct
 :properties [code    : string
              value   : any
              values  : list
              fn-cond : boolean<-func
              fn-any  : any<-func])

(type thenelselist : list
 :allowtypes [thenelse])

(type translation : struct
 :properties [name    : string
              wordmap : stringmap]
 :doc "i18 language translation.")

(type translationlist : list
 :allowtypes [translation]
 :doc "i18 language translation list.")

(type translationmap : map
 :allowtypes [translation]
 :doc "i18 language translation map.")

(type type : type
 :doc     "Original Type Class")

(type typedef : struct
 :properties [pkgname        : string
              name           : string
              extends        : string
              allowfuncs     : funclist
              allowtypes     : typelist
              allowvalues    : anylist
              disallowfuncs  : funclist
              disallowtypes  : typelist
              disallowvalues : anylist
              properties     : argmap
              proplast       : arg
              traits         : typelist]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_typedef vx_typedef_new(
       std::string pkgname,
       std::string name,
       std::string extend,
       vx_core::Type_typelist traits,
       vx_core::Type_typelist allowtypes,
       vx_core::Type_typelist disallowtypes,
       vx_core::Type_funclist allowfuncs,
       vx_core::Type_funclist disallowfuncs,
       vx_core::Type_anylist allowvalues,
       vx_core::Type_anylist disallowvalues,
       vx_core::Type_argmap properties
     );")
 :doc "Type Definition Class for inspecting Type properties.")

(type typelist : list
 :allowtypes [any]
 :doc        "List of Types")

(type typemap : map
 :allowtypes [any]
 :doc        "Map of Any Type Class")

(type user : struct
 :properties [security : security
              username : string
              token    : string]
 :doc        "User Type")

(type value : struct
 :properties [next : any
              refs : int])

(const false : boolean
 :test (test-false false))

(const global : project
 :doc "Global variable for project data.")

(const infinity : int
 (native
  :js "Infinity")
 :doc "Infinity. Returned during unusual calculations.")

(const mempool-active : mempool
 :doc "Active Value Memory Pool")

(const msg-info : int
 0
 :doc "Message is just information")

(const msg-warning : int
 1
 :doc "Message is a Warning")

(const msg-error : int
 2
 :doc "Message is an Error")

(const msg-severe : int
 3
 :doc "Message is a Severe Error")

(const neginfinity : int
 (native
  :js "-Infinity")
 :doc "Negative Infinity. Returned during unusual calculations.")

(const newline : string
 "\n"
 :doc "New line constant")

(const notanumber : int
 (native
  :js "NaN")
 :doc "Not a number. Returned during invalid calculations.")

(const nothing : string
 "nothing"
 :doc "Nothing Value. Opposite of every other value. e.g. Nil, Null")

(const quote : string
 `"`
 :doc "Quotation mark constant")

(const true : boolean
 (native
  :cpp    "true"
  :csharp "true"
  :java   "true"
  :js     "true")
 :test (test-true true))

(func . : any
 [target     : any
  method     : string
  parameters : anylist :...]
 (native
  :js "target[method].apply(parameters)")
 :alias       "dotmethod"
 :sideeffects "Depends on object"
 :doc "Not Recommened: Support for Object Oriented dot notation. e.g. (this.foo 'a') = this.foo('a')")

(func + : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() + num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :csharp
   "int result = num1.vx_int() + num2.vx_int();
    output = Vx.Core.vx_new_int(result);"
  :java
   "int result = num1.vx_int() + num2.vx_int();
    output = Core.vx_new_int(result);"
  :js
   "num1 + num2")
 :alias "plus"
 :test (test 5 (+ 2 3))
       (test 3 (+ 5 -2))
 :doc "Math int plus")

(func + : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float result = vx_core::vx_float_from_number(num1) + vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);"
  :csharp
   "float result = Vx.Core.vx_float_from_number(num1) + Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);"
  :java
   "float result = Core.vx_float_from_number(num1) + Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);"
  :js
   "num1 + num2")
 :alias "plus"
 :test (test 5 (+ 2  3))
       (test 3 (+ 5 -2))
 :doc "Math number plus")

(func + : int
 [nums : intlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : int
   [total : int
    num   : int]
   (+ total num)))
 :alias "plus"
 :doc   "Math int plus")

(func + : number
 [nums : numberlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : number
   [total : number
    num   : number]
   (+ total num)))
 :alias "plus"
 :doc   "Math number plus")

(func +1 : int
 [num : int]
 (+ num 1)
 :alias "plus1"
 :test (test  3 (+1  2))
       (test -1 (+1 -2))
 :doc "Math int plus 1")

(func - : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() - num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :csharp
   "int result = num1.vx_int() - num2.vx_int();
    output = Vx.Core.vx_new_int(result);"
  :java
   "int result = num1.vx_int() - num2.vx_int();
    output = Core.vx_new_int(result);"
  :js
   "num1 - num2")
 :alias "minus"
 :test (test 1 (- 3 2))
       (test 7 (- 5 -2))
 :doc "Math int minus")

(func - : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float result = vx_core::vx_float_from_number(num1) - vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);"
  :csharp
   "float result = Vx.Core.vx_float_from_number(num1) - Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);"
  :java
   "float result = Core.vx_float_from_number(num1) - Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);"
  :js
   "num1 - num2")
 :alias "minus"
 :test (test 5 (+ 2 3))
       (test 3 (+ 5 -2))
 :doc "Math number minus")

(func - : int
 [nums : intlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : int
   [total : int
    num   : int]
   (- total num)))
 :alias "minus"
 :doc   "Math integer minus")

(func - : number
 [nums : numberlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : number
   [total : number
    num   : number]
   (- total num))
 )
 :alias "minus"
 :doc   "Math number minus")

(func -1 : int
 [num : int]
 (- num 1)
 :alias "minus1"
 :test (test  1 (-1  2))
       (test -3 (-1 -2))
 :doc "Math int minus 1")

(func * : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() * num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :csharp
   "int result = num1.vx_int() * num2.vx_int();
    output = Vx.Core.vx_new_int(result);"
  :java
   "int result = num1.vx_int() * num2.vx_int();
    output = Core.vx_new_int(result);"
  :js
   "num1 * num2")
 :alias "multiply"
 :test (test 6 (* 3 2))
       (test -10 (* 5 -2))
 :doc "Math int multiply")

(func * : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float result = vx_core::vx_float_from_number(num1) * vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);"
  :csharp
   "float result = Vx.Core.vx_float_from_number(num1) * Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);"
  :java
   "float result = Core.vx_float_from_number(num1) * Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);"
  :js
   "num1 * num2")
 :alias "multiply"
 :test (test 6.4 (* 3.2 2))
       (test -10.2 (* 5.1 -2))
 :doc "Math multipy")

(func * : int
 [nums : intlist :...]
 (any<-list-start-reduce
  nums
  1
  (fn : int
   [total : int
    num   : int]
   (* total num))
 )
 :alias "multiply"
 :test (test 24 (* 3 2 4))
       (test -20 (* 5 -2 2))
 :doc "Math multiply")

(func * : number
 [nums : numberlist :...]
 (any<-list-start-reduce
  nums
  1
  (fn : number
   [total : number
    num   : number]
   (* total num))
 )
 :alias "multiply"
 :test (test 24 (* 3 2 4))
       (test -20 (* 5 -2 2))
 :doc "Math multiply")

(func / : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float float1 = vx_core::vx_float_from_number(num1);
    float float2 = vx_core::vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = vx_core::c_notanumber;
    } else {
      float result = float1 / float2;
      output = vx_core::vx_new_float(result);
    }"
  :csharp
   "float float1 = Vx.Core.vx_float_from_number(num1);
    float float2 = Vx.Core.vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = Vx.Core.c_notanumber;
    } else {
      float result = float1 / float2;
      output = Vx.Core.vx_new_float(result);
    }"
  :java
   "float float1 = Core.vx_float_from_number(num1);
    float float2 = Core.vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = Core.c_notanumber;
    } else {
      float result = float1 / float2;
      output = Core.vx_new_float(result);
    }"
  :js
   "num1 / num2")
 :alias "divide"
 :test (test 3 (/ 6 2))
       (test -5 (/ 10 -2))
 :doc "Math divide")

(func = : boolean
 [val1 : any
  val2 : any]
 (native
  :cpp
   "bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      std::string str1 = vx_core::vx_string_from_any(val1);
      std::string str2 = vx_core::vx_string_from_any(val2);
      if (str1 == str2) {
        isequal = true;
      }
    }
    output = vx_core::vx_new_boolean(isequal);"
  :csharp
   "bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Vx.Core.Type_string strval1 = Vx.Core.f_string_from_any(val1);
      Vx.Core.Type_string strval2 = Vx.Core.f_string_from_any(val2);
      if (strval1.vx_string() == (strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Vx.Core.vx_new_boolean(isequal);"
  :java
   "boolean isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Core.Type_string strval1 = Core.f_string_from_any(val1);
      Core.Type_string strval2 = Core.f_string_from_any(val2);
      if (strval1.vx_string().equals(strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Core.vx_new_boolean(isequal);"
  :js
   "vx_core.vx_eq(val1, val2)")
 :alias "eq"
 :test (test-true (= true true))
       (test-true (= 2 2))
       (test-true (= "a" "a"))
       (test-true
        (=
         (stringlist "a" "b" "c")
         (new stringlist "a" "b" "c")))
       (test-true
        (=
         (stringmap :a "1" :b "2")
         (new stringmap :a "1" :b "2")))
 :doc "Boolean equal/equivalent")

(func = : boolean
 [values : anylist :...]
 (any<-list-start-reduce-next : boolean
  values
  false
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (= current next)))
 )
 :alias "eq"
 :test (test-false (= 2 2 3))
 :doc "Boolean equal/equivalent")

(func == : boolean
 [val1 : any
  val2 : any]
 (native
  :cpp
   "bool isequal = vx_core::vx_eqeq(val1, val2);
    output = vx_core::vx_new_boolean(isequal);"
  :csharp
   "bool isequal = Vx.Core.vx_eqeq(val1, val2);
    output = Vx.Core.vx_new_boolean(isequal);"
  :java
   "boolean isequal = Core.vx_eqeq(val1, val2);
    output = Core.vx_new_boolean(isequal);"
  :js
   "output = val1 == val2")
 :alias "eqeq"
 :test (test-true (== 0 0))
       (test-true (== "" ""))
 :doc "Strict equality check. Note that all non-empty, non-constants will not be equal.")

(func ! : boolean
 [val : boolean :doc "Thing to not"]
 (native
  :cpp    "vx_core::vx_new_boolean(!val->vx_boolean());"
  :csharp "Vx.Core.vx_new_boolean(!val.vx_boolean());"
  :java   "Core.vx_new_boolean(!val.vx_boolean());"
  :js     "!val")
 :alias "not"
 :test (test-false false)
       (test-false (! true))
 :doc "Boolean not")

(func != : boolean
 [val1 : any
  val2 : any]
 (! (= val1 val2))
 :alias "ne"
 :test (test-ne true false)
       (test-ne "a" "b")
 :doc "Returns true if the first arg is not equal to any of the other arg.")

(func !== : boolean
 [val1 : any
  val2 : any]
 (! (== val1 val2))
 :alias "neqeq"
 :doc   "Returns true if the first arg is not strictly equal to any of the other arg.")

(func !-empty : boolean
 [text : string]
 (! (is-empty text))
 :alias "notempty"
 :doc   "Returns true if text is not empty.")

(func !-empty : boolean
 [val : any]
 (! (is-empty val))
 :alias "notempty"
 :doc "Returns true if val is not empty.")

(func < : boolean
 [val1 : any
  val2 : any]
 (switch
  (compare val1 val2)
  (case -1 true)
  (else    false))
 :alias "lt"
 :test (test-true (< 2 3))
 :doc "Returns true if the first arg is less than all of the other args")

(func < : boolean
 [values : anylist :...]
 (any<-list-start-reduce-next : boolean
  values
  true
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (< current next))))
 :alias "lt"
 :test (test-true
        (< 2 3))
       (test-true
        (< "b" "d" "z"))
 :doc "Returns true if the first arg is less than all of the other args")

(func <= : boolean
 [val1 : any
  val2 : any]
 (! (> val1 val2))
 :alias "le"
 :test  (test-true (<= 2 3))
 :doc   "Returns true if the first arg is less or equal than all of the other args")

(func <= : boolean
 [args : anylist :...]
 (! (> args))
 :alias "le"
 :test  (test-true (<= "b" "d" "z"))
 :doc   "Returns true if the first arg is less or equal than all of the other args")

(func <- : any-1
 [value  : any-1
  fnlist : any<-anylist :...]
 :alias chainfirst
 :test  (test
         (*
          (+
           (- 5 3)
           3)
          2)
         (<-
          5
          (- 3)
          (+ 3)
          (* 2)))
 :doc "This is a special function that applies a value as the first argument for the first function.
       The result is then used as the first argument on the next function, etc. Sometimes this
       improves readability.")

(func <<- : any-1
 [value  : any-1
  fnlist : any<-anylist :...]
 :alias chainlast
 :test  (test
         (* (+ (- 3 5) 3) 2)
         (<<-
          5
          (- 3)
          (+ 3)
          (* 2)))
 :doc "This is a special function that applies a value as the last argument for the first function.
       The result is then used as the last argument on the next function, etc. Sometimes this
       improves readability.")

(func > : boolean
 [val1 : any
  val2 : any]
 (switch
  (compare val1 val2)
  (case 1 true)
  (else   false))
 :alias "gt"
 :test  (test-true (> 3 2))
 :doc   "Returns true if the first arg is greater than all of the other args")

(func > : boolean
 [values : anylist :...]
 (any<-list-start-reduce-next : boolean
  values
  true
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and
    reduce
    (> current next))))
 :alias "gt"
 :test  (test-true (> "z" "y" "b"))
 :doc   "Returns true if the first arg is greater than all of the other args")

(func >= : boolean
 [val1 : any
  val2 : any]
 (! (< val1 val2))
 :alias "ge"
 :test  (test-true (>= 3 2))
 :doc   "Returns true if val1 is greater or equal to val2")

(func >= : boolean
 [args : anylist :...]
 (! (< args))
 :alias "ge"
 :test  (test-true (>= "z" "b" "b"))
 :doc   "Returns true if the first arg is greater or equal than all of the other args")

(func allowfuncs<-security : funclist
 [security : security]
 (:allowfuncs security)
 :doc "Returns allowfuncs from a given security.")

(func allowtypenames<-typedef : stringlist
 [vtypedef : typedef]
 (typenames<-typelist (allowtypes<-typedef vtypedef))
 :doc "Return allow name list from type")

(func allowtypes<-typedef : typelist
 [vtypedef : typedef]
 (native
  :cpp
   "vtypedef->allowtypes();"
  :csharp
   "vtypedef.allowtypes();"
  :java
   "vtypedef.allowtypes();"
  :js
   "vtypedef['vx_value']['allowtypes']")
 :doc "Return allow type list from type")

(func and : boolean
 [val1 : boolean
  val2 : boolean]
 (native
  :cpp
   "if (val1->vx_boolean() && val2->vx_boolean()) {
      output = vx_core::c_true;
    } else {
      output = vx_core::c_false;
    }"
  :csharp
   "if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :java
   "if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :js
   "if (val1 && val2) {
      output = true
    } else {
      output = false
    }")
 :test (test-true
        (and true true))
       (test-false
        (and true false))
 :doc "Returns true if all values are true")

(func and : boolean
 [values : booleanlist :...]
 (switch : boolean
  (length values)
  (case 0 true)
  (case 1 (:1 values))
  (else
   (any<-list-start-reduce-next : boolean
    values
    true
    (fn : boolean
     [reduce  : boolean
      current : boolean
      next    : boolean]
     (and reduce (and current next)))
   )))
 :test (test-true
        (and true true true))
       (test-false
        (and true true false))
 :doc "Returns true if all values are true")

(func any<-any : any-1
 [value : any-2]
 (native
  :cpp
   "output = vx_core::vx_any_from_any(generic_any_1, value);"
  :csharp
   "if (value is T tval) {
      output = tval;
    }"
  :java
   "@SuppressWarnings(“unchecked”)
    output = (T)value;"
  :js
   "value")
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-any-async : any-1
 [value : any-2]
 :async
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-any-context : any-1
 [value : any-2]
 (native
  :csharp
   "if (value is T tval) {
      output = tval;
    }"
  :java
   "@SuppressWarnings(“unchecked”)
    output = (T)value;")
 :context
 :doc "Function Type taking any value any-2 and returning generic any-1 using context")

(func any<-any-context-async : any-1
 [value : any-2]
 :async
 :context
 :doc "Generic Function taking any value any-2 and returning generic any-1")

(func any<-any-key-value : any-1
 [current : any-1
  key     : string
  value   : any-2]
 :doc "Generic Function returning Generic any-1 from a any-1, a key, and a value.")

(func any<-int : any-1
 [value : int]
 :doc "Generic Function returning Generic any-1 from an int")

(func any<-func : any-1
 []
 :doc "Generic Function returning Generic any-1 with any parameters")

(func any<-func-async : any-1
 []
 :async
 :doc "Generic Function returning Generic any-1 with any parameters")

(func any<-int-any : any-1
 [num : int
  val : any-2]
 :doc "Generic Function returning Generic any-1 from an int and a value")

(func any<-key-value : any-1
 [key : string
  val : any-2]
 :doc "Generic Function returning Generic any-1 from a key and a value")

(func any<-key-value-async : any-1
 [key : string
  val : any-2]
 :async
 :doc "Generic Function returning Asynchronous Generic any-1 from a key and a value")

(func any<-list : any-1
 [values : list-1
  index  : int]
 (native
  :cpp
   "long intindex = index->vx_int();
    vx_core::vx_Type_listany listvalue = values->vx_list();
    long intsize = vx_core::vx_int_from_sizet(listvalue.size());
    if (intindex <= intsize) {
      vx_core::Type_any value = listvalue[intindex - 1];
      output = vx_core::vx_any_from_any(generic_any_1, value);
    }"
  :csharp
   "int intindex = index.vx_int();
    int intsize = values.vx_list().Count;
    if (intindex <= intsize) {
      List<Vx.Core.Type_any> listvalue = values.vx_list();
      Vx.Core.Type_any value = listvalue[intindex - 1];
      output = Vx.Core.f_any_from_any(generic_any_1, value);
    }"
  :java
   "int intindex = index.vx_int();
    int intsize = values.vx_list().size();
    if (intindex <= intsize) {
      List<Core.Type_any> listvalue = values.vx_list();
      Core.Type_any value = listvalue.get(intindex - 1);
      output = Core.f_any_from_any(generic_any_1, value);
    }"
  :js
   "if (index <= values.length) {
      output = values[index - 1]
    }")
 :test (test
        "b"
        (any<-list
         (list "a" "b" "c")
         2))
       (test
        "b"
        (:2 (stringlist "a" "b" "c")))
 :doc "Returns nth value from a list or none if out of bounds")

(func any<-list-start-reduce : any-1
 [list      : list-2
  valstart  : any-1
  fn-reduce : any<-reduce]
 (native
  :cpp
   "vx_core::Type_any work = valstart;
    std::vector<vx_core::Type_any> listval = list->vx_list();
    for (vx_core::Type_any item : listval) {
      work = fn_reduce->vx_any_from_reduce(work, item);
    };
    output = vx_core::vx_any_from_any(generic_any_1, work);"
  :csharp :auto
  :java :auto
  :js
   "output = valstart
    const fn = fn_reduce['vx_value']
    if (fn) {
      for (const item of list) {
        output = fn(output, item)
      }
    }")
 :test (test
        24
        (any<-list-start-reduce : int
         (intlist 3 2 4)
         1
         (fn : int
          [total : int
           num   : int]
          (* total num))))
 :doc "Returns a val from a list reduce operation")

(func any<-list-start-reduce-next : any-1
 [list           : list-2
  valstart       : any-1
  fn-reduce-next : any<-reduce-next]
 (native
  :cpp
   "vx_core::Type_any result = vx_core::vx_any_from_list_result_next(generic_any_1, list, valstart, fn_reduce_next);
    output = vx_core::vx_any_from_any(generic_any_1, result);"
  :csharp :auto
  :java
   "output = valstart;
    final List<Core.Type_any> listval = list.vx_list();
    Core.Type_any current = Core.e_any;
    boolean first = true;
    for (final Core.Type_any next : listval) {
      if (first) {
        first = false;
      } else {
        output = fn_reduce_next.vx_any_from_reduce_next(generic_any_1, output, current, next);
      }
      current = next;
    }"
  :js
   "output = valstart
    const fn = fn_reduce_next['vx_value']
    if (fn) {
      let current = vx_core.e_any
      let first = true
      for (const next of list) {
        if (first) {
          first = false
        } else {
          output = fn(output, current, next)
        }
        current = next
      }
    }")
 :doc "Returns a val from a list reduce operation")

(func any<-map : any-1
 [valuemap : map-1
  key      : string]
 (native
  :cpp
   "vx_core::Type_any val = valuemap->vx_get_any(key);
    output = vx_core::vx_any_from_any(generic_any_1, val);"
  :csharp
   "Vx.Core.vx_any_from_map(generic_any_1, valuemap, key);"
  :java
   "Core.vx_any_from_map(generic_any_1, valuemap, key);"
  :js
   "if (key.startsWith(':')) {
      key = key.substring(1)
    }
    const mapval = valuemap['vx_value']
    let val = mapval[key]
    if (val != undefined) {
      output = val
    }")
 :test (test
        "v2"
        (any<-map
         (stringmap
          :a "v1"
          :b "v2"
          :c "v3")
         :b))
 :doc "Returns value from a map or empty if not found")

/*
(func any<-map-else : any-1
 [valuemap  : map-1
  key       : string
  valueelse : any-1]
 (let : any-1
  [value : any-1 := (any<-map
                     valuemap
                     key)]
  (if : any-1
   (then
    (!-empty value)
    value)
   (else
    valueelse)))
 :test (test
        "v2"
        (any<-map-else : string
         (stringmap
          :a "v1"
          :c "v3")
         :b
         "v2"))
 :doc "Returns value from a map or valueelse if not found")
*/

(func any<-map-start-reduce : any-1
 [map       : map-1
  start     : any-1
  fn-reduce : any<-any-key-value :: any-1 :: any-1]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto)
 :test (test
        "xayb"
        (any<-map-start-reduce
         (stringmap
          :a "x"
          :b "y")
         ""
         (fn : string
          [current : string
           key     : string
           value   : any]
          (copy current
           value
           key))))
 :doc "Returns a value by reducing each element of a map.")

(func any<-none : any-1
 []
 :doc "Function Type returning Generic any-1 with no parameters")

(func any<-none-async : any-1 :async
 []
 :doc "Function Type returning Generic any-1 with no parameters")

(func any<-reduce : any-1
 [result : any-1
  item   : any-2])

(func any<-reduce-async : any-1 :async
 [result : any-1
  item   : any-2])

(func any<-reduce-next : any-1
 [result  : any-1
  current : any-2
  next    : any-2])

(func any<-reduce-next-async : any-1 :async
 [result  : any-1
  current : any-2
  next    : any-2])

(func any<-struct : any-1
 [vstruct : struct-2
  key     : string]
 (native
  :cpp
   "vx_core::Type_any val = vstruct->vx_get_any(key);
    output = vx_core::vx_any_from_any(generic_any_1, val);"
  :csharp
   "Vx.Core.Type_any val = vstruct.vx_any(key);
    output = Vx.Core.f_any_from_any(generic_any_1, val);"
  :java
   "Core.Type_any val = vstruct.vx_any(key);
    output = Core.f_any_from_any(generic_any_1, val);"
  :js
   "const subvalmap = vstruct['vx_value']
    if (subvalmap != undefined) {
      if (key.startsWith(':')) {
        key = key.substring(1)
      }
      const val = subvalmap[key]
      if (val != undefined) {
        output = val
      }
    }")
 :doc "Returns value from a struct")

(func async : any-1 :async
 [value : any-1]
 (native
  :csharp
   "output = Vx.Core.vx_async_new_completed(value);"
  :java
   "output = Core.vx_async_new_completed(value);"
  :js
   "value")
 :doc "Returns an asynchonous version value. This exists mostly for type-casting.")

(func boolean<-any : boolean
 [value : any-1]
 :doc "Function Type taking generic any-1 and returning boolean")

(func boolean<-func : boolean
 []
 :doc "Function Type returning boolean with any parameters")

(func boolean<-none : boolean
 []
 :doc "Function Type returning boolean with no parameters")

(func boolean-permission<-func : boolean
 [func : func]
 (contains
  (allowfuncs<-security
   (security<-context))
  func)
 :context
 :doc "Returns true if the given func has permission.")

(func boolean-write<-map-name-value : boolean
 [valuemap : map-1
  name     : string
  value    : any-1]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto)
 :test (test
        (stringmutablemap
         :b "y"
         :a "x")
        (let : stringmutablemap
         [smap : stringmutablemap :=
           (stringmutablemap
            :b "y")
          iswrite : boolean :=
           (boolean-write<-map-name-value
            smap :a "x")]
         smap))
       (test
        (stringmutablemap
         :a "x")
        (let : stringmutablemap
         [smap : stringmutablemap :=
           (stringmutablemap
            :b "y"
            :a "x")
          iswrite : boolean :=
           (boolean-write<-map-name-value
            smap :b "")]
         smap))
 :sideeffects
  "Alters a mutable map. Warning: vxlisp is immutable by design, so this function can produce unexpected results."
 :doc "Returns true if it alters a mutable map false if it fails.")

(func case : thenelse
 [values : list-1
  fn-any : any<-func]
 (thenelse
  :code   :casemany
  :values values
  :fn-any fn-any))

(func case : thenelse
 [value  : any-1
  fn-any : any<-func]
 (thenelse
  :code   :case
  :value  value
  :fn-any fn-any))

(func compare : int
 [val1 : any
  val2 : any]
 (native
  :cpp
   "long intresult = vx_core::vx_compare(val1, val2);
    output = vx_core::vx_new_int(intresult);"
  :csharp :auto
  :java
   "int intresult = 0;
    if ((val1 instanceof Core.Type_number) && (val2 instanceof Core.Type_number)) {
      Core.Type_number num1 = (Core.Type_number)val1;
      Core.Type_number num2 = (Core.Type_number)val2;
      float float1 = Core.vx_new(Core.t_float, num1).vx_float();
      float float2 = Core.vx_new(Core.t_float, num2).vx_float();
      if (float1 < float2) {
        intresult = -1;
      } else if (float1 > float2) {
        intresult = 1;
      }
    } else {
      String stringval1 = Core.f_string_from_any(val1).vx_string();
      String stringval2 = Core.f_string_from_any(val2).vx_string();
      int compare = stringval1.compareTo(stringval2);
      if (compare > 0) {
        intresult = 1;
      } else if (compare < 0) {
        intresult = -1;
      }
    }
    output = Core.vx_new_int(intresult);"
  :js
   "if (val1 == val2) {
      output = 0
    } else if (val1 < val2) {
      output = -1
    } else {
      output = 1
    }")
 :test (test 1 (compare 3 2))
       (test 1 (compare "z" "a"))
 :doc "Returns 0 if vals are equal, 1 if val1 > val2, -1 if val1 < val2")

(func contains : boolean
 [text : string
  find : string]
 (native
  :cpp
   "bool check = vx_boolean_from_string_find(text->vx_string(), find->vx_string());
    output = vx_core::vx_new_boolean(check);"
  :csharp
   "bool check = vx_boolean_from_string_find(text.vx_string(), find.vx_string());
    output = Vx.Core.vx_new_boolean(check);"
  :java
   "boolean check = vx_boolean_from_string_find(text.vx_string(), find.vx_string());
    output = Core.vx_new_boolean(check);"
  :js
   "vx_core.vx_boolean_from_string_find(text, find)")
 :test (test-true  (contains "abcde" "cd"))
       (test-false (contains "abcde" "dc"))
 :doc  "Returns true if the given list contains the given value.")

(func contains : boolean
 [values : list-2 :doc "Any list"
  find   : any    :doc "Any value"]
 (native
  :cpp
   "bool booleanresult = false;
    vx_core::vx_Type_listany listvalues = values->vx_list();
    for (vx_core::Type_any item : listvalues) {
      vx_core::Type_boolean iseq = vx_core::f_eq(item, find);
      if (iseq->vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = vx_core::vx_new_boolean(booleanresult);"
  :csharp :auto
  :java
   "boolean booleanresult = false;
    List<Core.Type_any> listvalues = values.vx_list();
    for (Core.Type_any item : listvalues) {
      Core.Type_boolean iseq = Core.f_eq(item, find);
      if (iseq.vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = Core.vx_new_boolean(booleanresult);"
  :js
   "values.includes(find)")
 :test (test-true
        (contains (stringlist "1" "2" "3") "2"))
       (test-true
        (contains (intlist 1 2 3) 2))
       (test-false
        (contains (list 1 "2" 3) 2))
 :doc  "Returns true if the given list contains the given value.")

(func context-main : context
 [args : anylist :...]
 (context)
 :doc "Returns the default context for app main execution. Arguments come from the command line.")

(func copy : any-1
 [value  : any-1
  values : anylist :...]
 (native
  :cpp
   "T* output = vx_core::vx_copy(generic_any_1, value, values->vx_list());"
  :csharp
   "Vx.Core.Type_any[] arrayany = Vx.Core.arrayany_from_anylist(values);
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    T tvalue = (T)value;
    Vx.Core.Type_any anyvalue = tvalue.vx_copy(arrayobj);
    T output = (T)anyvalue;"
  :java
   "@SuppressWarnings(“unchecked”)
    Core.Type_any[] arrayany = Core.arrayany_from_anylist(values);
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(value.vx_copy(arrayobj));"
  :js
   "vx_core.f_new(value, ...values)")
 :bigospace :n
 :bigotime :n
 :test (test
        (stringmap
         :a "1"
         :b "2")
        (copy
         (stringmap :a "1")
         :b "2"))
 :doc "Returns a copy of a given value with the given values added or updated.")

(func else : thenelse
 [fn-any : any<-func]
 (thenelse
  :code   :else
  :fn-any fn-any))

(func empty : any-1
 [type : any-1]
 (native
  :cpp
   "T* output = vx_core::vx_any_from_any(type, type->vx_empty());"
  :csharp
   "T output = Vx.Core.vx_empty(type);"
  :java
   "T output = Core.vx_empty(type);"
  :js
   "vx_core.vx_empty(type)")
 :test (test false  (empty boolean))
       (test ""     (empty string))
       (test (list) (empty list))
       (test (map)  (empty map))
 :doc "Returns the empty value for a given type. Can be called using (empty type) or simply (type)")

(func extends<-any : string
 [val : any-1]
 (extends<-typedef (typedef<-any val)))

(func extends<-typedef : string
 [vtypedef : typedef]
 (:extends vtypedef)
 :doc "Get the basetype of a given type")

(func first<-list : any-1
 [values : list-1]
 (any<-list values 1)
 :doc "Returns first value"
 :test (test
        "b"
        (first<-list
         (stringlist
          "b"
          "c"))))

(func first<-list-any<-any : any-1
 [values      : list-1
  fn-any<-any : any<-any]
 (native
  :cpp
   "std::vector<vx_core::Type_any> listvalue = values->vx_list();
    for (vx_core::Type_any value : listvalue) {
      if (value != vx_core::c_nothing) {
        vx_core::Type_any any = fn_any_from_any->vx_any_from_any(value);
        output = vx_core::vx_any_from_any(generic_any_1, any);
        break;
      }
    }"
  :csharp
   "List<Vx.Core.Type_any> listvalue = values.vx_list();
    foreach (Vx.Core.Type_any value in listvalue) {
      if (value != Vx.Core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value);
        break;
      }
    }"
  :java
   "List<Core.Type_any> listvalue = values.vx_list();
    for (Core.Type_any value : listvalue) {
      if (value != Core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value);
        break;
      }
    }"
  :js
   "output = " nothing "
    const fn = fn_any_from_any['vx_value']
    if (fn) {
      for (let index=0;index < values.length;index++) {
        output = fn(generic, values[index])
        if (output != " nothing ") {
          break
        }
      }
    }")
 :doc "Returns first value that is not nothing"
 :test (test
        "b"
        (first<-list-any<-any : string
         (list nothing "b" "c")
         resolve)))

(func float<-string : float
 [text : string]
 (native
  :cpp
   "float num = vx_core::vx_float_from_string(text->vx_string());
    output = vx_core::vx_new_float(num);"
  :csharp
   "float num = Vx.Core.vx_float_from_string(text.vx_string());
    output = Vx.Core.vx_new_float(num);"
  :java
   "float num = Core.vx_float_from_string(text.vx_string());
    output = Core.vx_new_float(num);"
  :js
   "vx_core.vx_float_from_string(text);")
 :test (test
        (float 2.3)
        (float<-string
         "2.3"))
 :doc "Returns float from a given string.")

(func fn : any-1
 [parameters : arglist
  fn-any : any<-func]
 :doc "Shell for lambda function calls")

(func funcdef<-func : funcdef
 [val : func]
 (native
  :cpp
   "val->vx_funcdef();"
  :csharp
   "val.vx_funcdef();"
  :java
   "val.vx_funcdef();")
 :doc "Returns the definition of a function")

(func funcname<-funcdef : string
 [funcdef : funcdef]
 (string (:pkgname funcdef) "/" (:name funcdef))
 :doc "Get the name of a given funcdef")

(func if : any-1
 [clause : boolean
  then   : any-1]
 (native
  :cpp
   "if (clause->vx_boolean()) {
      output = then;
    }"
  :csharp
   "if (clause.vx_boolean()) {
      output = then;
    }"
  :java
   "if (clause.vx_boolean()) {
      output = then;
    }"
  :js
   "if (clause) {
      output = then
    }")
 :test (test
        "a"
        (if (= 2 2) "a"))
       (test
        ""
        (if : string
         (= 1 2)
         "a"))
 :doc  "Logical If function")

(func if : any-1
 [clause  : boolean
  thenval : any-1
  elseval : any-1]
 (native
  :cpp
   "if (clause->vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :csharp
   "if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :java
   "if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :js
   "if (clause) {
      output = thenval
    } else {
      output = elseval
    }")
 :test (test
        "a"
        (if
         (= 2 2)
         "a"
         "b"))
       (test
        "b"
        (if
         (= 1 2)
         "a"
         "b"))
 :doc "Logical If function")

(func if : any-1
 [thenelselist : thenelselist :...]
 (native
  :cpp
   "vx_core::Type_any any = vx_core::vx_if_thenelselist(generic_any_1, thenelselist);
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :csharp :auto
  :java :auto
  :js
   "let fn_any = null
    for (const thenelseval of thenelselist) {
      const thenelse = thenelseval['vx_value']
      const code = thenelse['code']
      switch (code) {
      case ':then':
        const fn_cond = thenelse['fn-cond']
        const fn = fn_cond['vx_value']
        const cond = fn()
        if (cond == true) {
          fn_any = thenelse['fn-any']
        }
        break
      case ':else':
        fn_any = thenelse['fn-any']
        break
      }
      if (fn_any != null) {
        const fn = fn_any['vx_value']
        output = fn()
        break
      }
    }")
 :doc  "Logical If function"
 :test (test-true
        (if
         (then (= 2 3) false)
         (then (!= 3 3) false)
         (else (! false)))))

(func int<-func : int
 []
 :doc "Function Type returning int with any parameters")

(func int<-string : int
 [val : string]
 (switch : int
  val
  (case "notanumber"  notanumber)
  (case "infinity"    infinity)
  (case "neginfinity" neginfinity)
  (else
   (native
    :cpp
     "// :capture val
      vx_core::Type_int intresult = vx_core::e_int;
      try {
        std::string sval = val->vx_string();
        long ival = std::stoll(sval);
        intresult = vx_core::vx_new_int(ival);
      } catch (std::exception ex) {
        intresult = vx_core::c_notanumber;
      }
      return intresult;"
    :csharp
     "int intresult = 0;
      string strval = val.vx_string();
      try {
        float floatresult = float.Parse(strval);
        intresult = (int)floatresult;
        return Vx.Core.vx_new_int(intresult);
      } catch (Exception) {
        return Vx.Core.c_notanumber;
      }"
    :java
     "int intresult = 0;
      String strval = val.vx_string();
      try {
        float floatresult = Float.parseFloat(strval);
        intresult = (int)floatresult;
        return Core.vx_new_int(intresult);
      } catch (Exception ex) {
        return Core.c_notanumber;
      }"
    :js
     "parseInt(val)"
    )
  )
 )
 :test (test 4 (int<-string "4"))
       (test 5 (int<-string "5.4"))
       (test 5 (int<-string "5.9"))
       (test notanumber  (int<-string "notanumber"))
       (test infinity    (int<-string "infinity"))
       (test neginfinity (int<-string "neginfinity"))
 :doc  "Function Type converting string to int")

(func is-empty : boolean
 [text : string]
 (native
  :cpp
   "if (text->vx_p_iref == -2) {
      output = vx_core::c_true;
    }"
  :csharp
   "if (text.vx_string().Length == 0) {
      output = Vx.Core.c_true;
    }"
  :java
   "if (text.vx_string().length() == 0) {
      output = Core.c_true;
    }"
  :js
   "if (text.length == 0) {
      output = vx_core.c_true
    }")
 :doc "Returns true if text is empty.")

(func is-empty : boolean
 [value : any]
 (native
  :cpp
   "if (value == value->vx_empty()) {
      output = vx_core::c_true;
    }"
  :csharp
   "if (value == value.vx_empty()) {
      output = Vx.Core.c_true;
    } else {
      output = Vx.Core.c_false;
    }"
  :java
   "if (value == value.vx_empty()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :js
   "const type = vx_core.f_type_from_any(value)
    if (value == vx_core.f_empty(type)) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }")
 :test (test-true (is-empty false))
       (test-true (is-empty ""))
       (test-true (is-empty (list)))
       (test-true (is-empty (map)))
 :doc "Returns true if an value is empty")

(func is-endswith : boolean
 [text : string
  find : string]
 (native
  :cpp
   "std::string stext = text->vx_string();
    std::string sfind = find->vx_string();
    if (vx_core::vx_boolean_from_string_ends(stext, sfind)) {
      output = vx_core::c_true;
    }"
  :csharp
   "string stext = text.vx_string();
    string sfind = find.vx_string();
    if (stext.EndsWith(sfind)) {
      output = Vx.Core.c_true;
    }"
  :java
   "String stext = text.vx_string();
    String sfind = find.vx_string();
    if (stext.endsWith(sfind)) {
      output = Core.c_true;
    }"
  :js
   "if (text.endsWith(find)) {
      output = vx_core.c_true
    }")
 :doc "Returns true if text ends with find.")

(func is-func : boolean
 [val : any]
 (native
  :cpp
   "vx_core::Type_string extend = " (extends<-any val) ";
    std::string sextend = extend->vx_string();
    vx_core::vx_release(extend);
    if (sextend == “:func”) {
      output = vx_core::c_true;
    }"
  :csharp
   "if (val is Vx.Core.Type_func) {
      output = Vx.Core.c_true;
    }"
  :java
   "if (val instanceof Core.Type_func) {
      output = Core.c_true;
    }"
  :js
   "const extend = " (extends<-any val) "
    if (extend == ':func') {
      output = vx_core.c_true
    }")
 :doc "Returns true if val is a function.")

(func is-int : boolean
 [value : any]
 (native
  :cpp
   "bool result = vx_core::vx_is_int(value);
    output = vx_core::vx_new_boolean(result);"
  :csharp
   "bool result = Vx.Core.vx_is_int(value);
    output = Vx.Core.vx_new_boolean(result);"
  :java
   "boolean result = Core.vx_is_int(value);
    output = Core.vx_new_boolean(result);"
  :js "vx_core.vx_is_int(value)")
 :test (test-true
        (is-int 2))
       (test-true
        (is-int "2"))
       (test-true
        (is-int infinity))
       (test-true
        (is-int "infinity"))
 :doc "Returns true if the value is an integer.")

(func is-float : boolean
 [value : any]
 (native
  :cpp
   "bool result = vx_core::vx_is_float(value);
    output = vx_core::vx_new_boolean(result);"
  :csharp
   "bool result = Vx.Core.vx_is_float(value);
    output = Vx.Core.vx_new_boolean(result);"
  :java
   "boolean result = Core.vx_is_float(value);
    output = Core.vx_new_boolean(result);"
  :js "vx_core.vx_is_float(value)")
 :doc "Returns true if the value is a float.")

(func is-number : boolean
 [value : any]
 (switch : boolean
  (typename<-any value)
  (case (list
         "vx/core/decimal"
         "vx/core/float"
         "vx/core/int"
         "vx/core/number") true)
  (else false))
 :test (test-true  (is-number 5))
       (test-true  (is-number 5.5))
       (test-false (is-number "a"))
 :doc "Return true if val is a number")

(func is-pass<-permission : boolean
 [permission : permission]
 (let : boolean
  [id     : string     := (:id permission)
   lookup : permission := (permission<-id-context id)]
  (= lookup permission))
 :context
 :doc "Returns true if permission passes.")

(func last<-list : any-1
 [values : list-1]
 (let
  [len  : int := (length values)]
  (any<-list values len))
 :test (test
        "c"
        (last<-list
         (stringlist
          "b"
          "c")))
 :doc  "Returns last value")

(func length : int
 [text : string]
 (native
  :cpp
   "long len = text->vx_string().length();
    output = vx_core::vx_new_int(len);"
  :csharp
   "int len = text.vx_string().Length;
    output = Vx.Core.vx_new_int(len);"
  :java
   "int len = text.vx_string().length();
    output = Core.vx_new_int(len);"
  :js
   "text.length")
 :test (test
        4
        (length "abcd"))
       (test
        0
        (length ""))
 :doc "Returns length of a string.")

(func length : int
 [values : list-1]
 (native
  :cpp
   "long len = vx_core::vx_int_from_sizet(values->vx_list().size());
    if (len > 0) {
      output = vx_core::vx_new_int(len);
    }"
  :csharp
   "int intresult = values.vx_list().Count();
    output = Core.vx_new_int(intresult);"
  :java
   "int intresult = values.vx_list().size();
    output = Core.vx_new_int(intresult);"
  :js "values.length")
 :test (test
        3
        (length
         (stringlist "a" "b" "c")))
 :doc "Returns the currently used size/length of a list")

(func length : int
 [valuemap : map-1]
 (length
  (stringlist<-map valuemap))
 :doc "Returns the length of the given map.")

(func let : any-1
 [args   : arglist
  fn-any : any<-func :: any-1]
 (native
  :cpp
   "vx_core::Type_any any = fn_any->vx_any_from_func();
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :csharp
   "fn_any.vx_any_from_func(generic_any_1);"
  :java
   "fn_any.vx_any_from_func(generic_any_1);"
  :js
   "const fn = fn_any['vx_value']
    if (fn) {
      output = fn()
    }")
 :test (test
        7
        (let
         [v1 : int := 2
          v2 : int := (+ v1 3)]
         (+ v1 v2))))

(func let-async : any-1 :async
 [args         : arglist
  fn-any-async : any<-func-async]
 (native
  :cpp
   "fn_any_async->vx_any_from_func_async(generic_any_1);"
  :csharp
   "fn_any_async.vx_any_from_func_async(generic_any_1);"
  :java
   "fn_any_async.vx_any_from_func_async(generic_any_1);"
  :js
   "const fn = fn_any_async['vx_value']
    if (fn) {
      output = await fn()
    }")
 :doc "Same as normal let but returns async values.")

(func list<-list : list-1
 [values : list-2]
 (list<-list : list-1
  values
  (fn : any
   [value : any]
   value))
 :test (test
        (stringlist "10" "20")
        (list<-list : stringlist
         (anylist "10" "20")))
 :doc "Return a list with allowed values from another list")

(func list<-list : list-1
 [values      : list-2
  fn-any<-any : any<-any]
 (native
  :cpp
   "vx_core::vx_Type_listany list_value = values->vx_list();
    vx_core::vx_Type_listany list_result = vx_core::vx_listany_from_listany_fn(list_value, [fn_any_from_any](vx_core::Type_any val) {
      return fn_any_from_any->vx_any_from_any(val);
    });
    vx_core::Type_any anylist = generic_list_1->vx_new(list_result);
    output = vx_core::vx_any_from_any(generic_list_1, anylist);"
  :csharp :auto
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any.vx_any_from_any(generic_list_1, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));"
  :js
   "const fn = fn_any_from_any['vx_value']
    if (fn) {
      output = values.map(fn)
      output['vx_type'] = generic_list_1
    }")
 :doc "Returns a list of processed items from another list")

(func list<-list-async  : list-1 :async
 [values                : list-2
  fn-any<-any-async : any<-any-async]
 (native
  :cpp
   "vx_core::vx_Type_listany list_value = values->vx_list();
    vx_core::vx_Type_listasync list_async_result = vx_core::vx_listasync_from_listany_fn(list_value, [fn_any_from_any_async](vx_core::Type_any val) {
      return fn_any_from_any_async->vx_any_from_any_async(vx_core::vx_type(val), val);
    });
    output = vx_core::vx_async_new_from_listasync(generic_list_1, list_async_result);"
  :csharp :auto
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<CompletableFuture<Core.Type_any>> list_async_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any_async.vx_any_from_any_async(generic_list_1, val);
    });
    CompletableFuture<List<Core.Type_any>> async_list_result = Core.vx_async_arraylist_from_arraylist_async(list_async_result);
    output = Core.vx_async_from_async_fn(async_list_result, (list_result) -> {
      X work = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
      return work;
    });"
  :js
   "const fn = fn_any_from_any_async['vx_value']
    if (fn) {
      const listfuture = values.map(fn)
      const future = Promise.all(listfuture)
      output = await future
      output['vx_type'] = generic_list_1
    }")
 :doc "Returns an asynchronous list of the processed asynchronous items from another list")

(func list<-list-intany : list-1
 [values          : list-2
  fn-any<-int-any : any<-int-any]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto)
 :test (test
        (stringlist "a1" "b2")
        (list<-list-intany : stringlist
         (stringlist "a" "b")
         (fn : stringlist
          [index : int
           value : string]
          (string value index))))
 :doc "Returns a list of processed items from another list")

(func list<-map : list-1
 [valuemap : map-2]
 (list<-map : list-1
  valuemap
  (fn : any
   [key   : string
    value : any]
   value))
 :test (test
        (stringlist "a1" "b2")
        (list<-map : stringlist
         (stringmap
          :x "a1"
          :y "b2")))
 :doc "Returns a list of allowed values from a map.")

(func list<-map : list-1
 [valuemap          : map-2
  fn-any<-key-value : any<-key-value]
 (native
  :cpp :auto
  :csharp :auto
  :java
   "Map<String, Core.Type_any> map_value = valuemap.vx_map();
    List<Core.Type_any> listresult = Core.arraylist_from_linkedhashmap_fn(map_value, (key, val) -> {
      Core.Type_string valkey = Core.vx_new_string(key);
      return fn_any_from_key_value.vx_any_from_key_value(Core.t_any, valkey, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(listresult));"
  :js
   "vx_core.vx_list_from_map_fn(generic_list_1, valuemap, fn_any_from_key_value)")
 :test (test
        (stringlist "a1" "b2")
        (list<-map : stringlist
         (stringmap "a" "1" "b" "2")
         (fn : string
          [key : string
           val : string]
          (string key val))))
 :doc "Returns a list from a map by applying a function to each key value.")

(func list<-map-async : list-1 :async
 [valuemap                : map-2
  fn-any<-key-value-async : any<-key-value-async])

(func list<-type : any
 [type : any]
 (native
  :js
   "output = []
    output['vx_type'] = type")
 :doc "Create an empty list from a type. Used internally for default lists")

(func list-join<-list : list-1
 [values : list-2]
 (list-join<-list : list-1
  values
  (fn : any
   [value : any]
   value))
 :test (test
        (stringlist "a" "b" "c" "d")
        (list-join<-list : stringlist
         (stringlistlist
          (stringlist "a" "b")
          (stringlist "c" "d"))))
 :doc "Returns a list by joining the valid values in each value list")

(func list-join<-list : list-1
 [values      : list-2
  fn-any<-any : any<-any]
 (native
  :cpp
   "vx_core::Type_any list = vx_core::vx_list_join_from_list_fn(generic_list_1, values, fn_any_from_any);
    output = vx_core::vx_any_from_any(generic_list_1, list);"
  :csharp :auto
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = new ArrayList<>();
    for (Core.Type_any val : list_value) {
      Core.Type_any listoflist = fn_any_from_any.vx_any_from_any(generic_list_1, val);
      if (listoflist instanceof Core.Type_list) {
        Core.Type_list vallist = (Core.Type_list)listoflist;
        List<Core.Type_any> listval = vallist.vx_list();
        list_result.addAll(listval);
      }
    }
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));"
  :js
   "const fn = fn_any_from_any['vx_value']
    if (fn) {
      const listoflist = values.map(fn)
      output = listoflist.flat()
      output['vx_type'] = generic_list_1
    }")
 :test (test
        (stringlist "a" "b" "c" "d")
        (list-join<-list : stringlist
         (stringlistlist
          (stringlist "a" "b")
          (stringlist "c" "d"))
         (fn : stringlist
          [values : stringlist]
          values)))
 :doc "Returns a flattened list of processed items from another list")

(func log : any
 [value : any]
 (native
  :cpp
   "vx_core::vx_log(value);
    output = value;"
  :csharp
   "Vx.Core.vx_log(value);
    output = value;"
  :java
   "Core.Type_string stringtext = Core.f_string_from_any(value);
    String text = stringtext.vx_string();
    System.out.println(text);
    output = value;"
  :js
   "const text = vx_core.f_string_from_any(value)
    console.log(text)
    output = value")
 :doc "Writes a value to the console.")

(func log : any-1
 [text  : string
  value : any-1]
 (native
  :cpp
   "vx_core::vx_log(text);
    vx_core::vx_log(value);
    output = value;"
  :csharp
   "Vx.Core.vx_log(text);
    Vx.Core.vx_log(value);
    output = value;"
  :java
   "Core.vx_log(text);
    Core.vx_log(value);
    output = value;"
  :js
   "console.log(text)
    const svalue = vx_core.f_string_from_any(value)
    console.log(svalue)
    output = value")
 :doc "Writes a string and a value to the console.")

(func main : string
 [args : anylist :...]
 (string args)
 :doc "The default function for app main execution. Arguments come from the command line.")

(func map<-list : map-1
 [vallist     : list-2
  fn-any<-any : any<-any :: string]
 (native
  :cpp
   "vx_core::vx_Type_listany listany = vallist->vx_list();
    vx_core::vx_Type_mapany mapany = vx_core::vx_map_from_list(listany, fn_any_from_any);
    output = vx_core::vx_new_map(generic_map_1, mapany);"
  :csharp :auto
  :java
   "List<Core.Type_any> listval = vallist.vx_list();
    Map<String, Core.Type_any> mapresult = Core.vx_map_from_list_fn(listval, (val) -> {
      return fn_any_from_any.vx_any_from_any(Core.t_string, val);
    });
    output = Core.f_any_from_any(generic_map_1, output.vx_new_from_map(mapresult));"
  :js
   "const valmap = {}
    vallist.map(value => {
      const fn = fn_any_from_any['vx_value']
      if (fn) {
        const key = fn(value)
        valmap[key] = value
      }
    })
    output = {
      vx_type: generic_map_1,
      vx_value: valmap
    }")
 :test (test
        (stringmap
         "keya" "a"
         "keyb" "b")
        (map<-list : stringmap
         (stringlist "a" "b")
         (fn : string
          [val : string]
          (string "key" val))))
 :doc "Returns a map from a list by applying a function to generate a key for each value.")

(func map<-map : map-1
 [valuemap : map-2]
 (map<-map : map-1
  valuemap
  (fn : any
   [key   : string
    value : any]
   value))
 :test (test
        (stringmap :a "1")
        (map<-map : stringmap
         (anymap :a "1")))
 :doc "Return a map with allowed values from another map")

(func map<-map : map-1
 [valuemap          : map-2
  fn-any<-key-value : any<-key-value]
 (native
  :cpp
   "vx_core::Type_any map = vx_core::vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value);
    output = vx_core::vx_any_from_any(generic_map_1, map);"
  :csharp
   "Vx.Core.vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value);"
  :java
   "Core.vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value);"
  :js
   "vx_core.vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value)")
 :test (test
        (stringmap
         :a "a1"
         :b "b2")
        (map<-map : stringmap
         (stringmap
          :a "1"
          :b "2")
         (fn : string
          [key : string
           val : string]
          (string key val))))
 :doc "Returns a map from a map by applying a function to each key value.")

/*
(func mempool-addref : none
 [values : anylist :...]
 (native
  :js
   "for (const value of values) {
      const value = values[i]
      if (value.refs) {
        value.refs += 1
      }
    }")
 :doc "Add Value Reference")

(func mempool-reserve : value
 []
 (native
  :js
   "mempool = " mempool-active "
    output = mempool.valuepool
    if (output == null) {
      output = {
        refs: 0
      }
    } else {
      const next = output.next
      if (next == null) {
        mempool.valuepool = null
      } else {
        mempool.valuepool = next
        output.next = null
      }
    }")
 :doc "Returns a recycled Value or creates a new one.")

(func mempool-release : none
 [value : value]
 (native
  :js
   "const mempool = " mempool-active "
    value.length = 0
    for (const key in value) {
      delete value[key]
    }
    next = mempool.valuepool
    value.next = next
    mempool.valuepool = value")
 :doc "Recycles a Value and adds it to the valuepool.")

(func mempool-removeref : none
 [values : anylist :...]
 (native
  :js
   "for (const value of values) {
      const value = values[i]
      if (value.refs) {
        value.refs -= 1
        if (value.refs == 0) {
          vx_core.f_mempool_removerefchildren(value)
          vx_core.f_mempool_recyclevalue(value)
        }
      }
    }")
 :doc "Remove Value Reference")

(func mempool-removerefchildren : none
 [values : anylist :...]
 (native
  :js
   "for (const value of values) {
      const extend = " (extends<-any value) "
      switch (extend) {
      case ':list':
        vx_core.f_mempool_removeref(...value['vx_value'])
        break
      case ':map':
      case ':struct':
        vx_core.f_mempool_removeref(...Object.entities(value['vx_value']))
        break
      }
    }")
 :doc "Remove Value Child References")
*/

(func msg<-error : msg
 [error : string]
 (msg
  :severity msg-error
  :text error)
 :doc "Returns a msg from error string")

(func msg<-error : msg
 [code   : string
  detail : any]
 (msg
  :code code
  :detail detail
  :severity msg-error)
 :doc "Returns a msg from error code and detail")

(func msg<-error : msg
 [path   : string
  code   : string
  detail : any]
 (msg
  :code     code
  :path     path
  :severity msg-error
  :detail   detail)
 :doc "Returns a msg from error path code and detail")

(func msg<-warning : msg
 [warning : string]
 (msg
  :severity msg-warning
  :text warning)
 :doc "Returns a msg from a warning string")

(func msgblock<-msgblock-msg : msgblock
 [origblock : msgblock
  addmsg    : msg]
 (copy origblock addmsg)
 :doc "Return a new Msgblock with the added msg")

(func msgblock<-msgblock-msgblock : msgblock
 [origblock : msgblock
  addblock  : msgblock]
 (msgblock origblock addblock)
 :doc "Return a new Msgblock with the added block")

(func name<-typedef : string
 [vtypedef : typedef]
 (:name vtypedef)
 :doc "Returns the name from a typedef.")

(func native : any-1
 [clauses : anylist :...]
 :doc "Native Function Call")

(func native<-any : any
 [value : any-1]
 (native
  :js
   "output = value
    switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'string':
      break
    default:
      const extend = " (extends<-any value) "
      switch (extend) {
      case ':list':
        output = [...value]
        break
      case ':func':
      case ':map':
      case ':struct':
        output = value['vx_value']
        break
      }
      break
    }")
  :doc "Returns native value of value object")

(func new : any-1
 [type   : any-1
  values : anylist :...]
 (native
  :cpp
   "T* output = vx_core::vx_new(type, values->vx_list());"
  :csharp
   "Vx.Core.Type_any[] arrayany = Vx.Core.arrayany_from_anylist(values);
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));"
  :java
   "Core.Type_any[] arrayany = Core.arrayany_from_anylist(values);
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));"
  :js
   "vx_core.vx_new(type, values)")
 :doc "Create a new Value of Type A"
 :test (test true (new boolean true))
       (test 4 (new int 4))
       (test 5.4 (new float 5.4))
       (test "a" (new string "a"))
       (test
        (stringlist "a" "b" "c")
        (new stringlist "a" "b" "c"))
       (test
        (stringmap :a "1" :b "2")
        (new stringmap :a "1" :b "2")))

(func number<-func : number
 []
 :doc "Function Type returning number with any parameters")

(func or : boolean
 [val1 : boolean
  val2 : boolean]
 (native
  :cpp
   "if (val1->vx_boolean() || val2->vx_boolean()) {
      output = vx_core::c_true;
    } else {
      output = vx_core::c_false;
    }"
  :csharp
   "if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Vx.Core.c_true;
    } else {
      output = Vx.Core.c_false;
    }"
  :java
   "if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :js
   "if (val1 || val2) {
      output = true
    } else {
      output = false
    }")
 :doc  "Returns true if any value is true"
 :test (test-true (or true true))
       (test-true (or true false))
       (test-false (or false false)))

(func or : boolean
 [values : booleanlist :...]
 (any<-list-start-reduce-next : boolean
  values
  false
  (fn : boolean
   [reduce  : boolean
    current : boolean
    next    : boolean]
   (or reduce (or current next))))
 :doc  "Returns true if any value is true"
 :test (test-true (or false true false))
       (test-false (or false false false)))

(func package-global<-name : package
 [name : string]
 (any<-map
  (:packagemap global)
  name)
 :doc "Returns a package from global with the given name.")

(func packagename<-typedef : string
 [vtypedef : typedef]
 (:pkgname vtypedef)
 :doc "Returns the package name from a typedef.")

(func path<-context-path : string
 [path : string]
 (path<-setting-path
  (setting<-context)
  path)
 :context
 :doc "Returns a path from a context")

(func path<-setting-path : string
 [session : setting
  path    : string]
 :doc "Returns a path from a setting")

(func permission<-id-context : permission
 [id : string]
 (let
  [user          : user          := (user<-context)
   security      : security      := (:security user)
   permissionmap : permissionmap := (:permissionmap security)]
  (:id permissionmap))
 :context
 :doc "Return a permission from context by id")

(func properties<-typedef : argmap
 [vtypedef : typedef]
 (:properties vtypedef)
 :doc "Return property map from typedef")

(func proplast<-typedef : arg
 [vtypedef : typedef]
 (:proplast vtypedef)
 :doc "Return last property from typedef")

(func resolve : any-1
 [value : any-1]
 value
 :test (test "a" (resolve "a")))

(func resolve : any-1
 [fn-any : any<-func]
 (native
  :cpp
   "if (fn_any) {
      vx_core::Type_any any = fn_any->vx_any_from_func();
      output = vx_core::vx_any_from_any(generic_any_1, any);
    }"
  :csharp
   "if (fn_any != null) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }"
  :java
   "if (fn_any != null) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }"
  :js
   "const typedef = " (typedef<-any fn-any) "
    const extend = vx_core.f_extends_from_typedef(typedef)
    switch (extend) {
    case ':func':
      const fn = fn_any['vx_value']
      if (fn) {
        output = fn()
      }
      break
    default:
      output = fn_any
      break
    }")
 :test (test 4 (resolve (fn : int [] (+ 1 3)))))

(func resolve-async : any-1 :async
 [fn-any : any<-func-async]
 (native
  :cpp
   "if (fn_any) {
      output = fn_any->vx_any_from_func_async(generic_any_1);
    }"
  :csharp
   "if (fn_any != null) {
      output = fn_any.vx_any_from_func_async(generic_any_1);
    }"
  :java
   "if (fn_any != null) {
      output = fn_any.vx_any_from_func_async(generic_any_1);
    }"
  :js
   "const typedef = " (typedef<-any fn-any) "
    const extend = vx_core.f_extends_from_typedef(typedef)
    switch (extend) {
    case ':func':
      const fn = fn_any['vx_value']
      if (fn) {
        output = await fn()
      }
      break
    default:
      output = fn_any
      break
    }")
 :test (test 4 (resolve : int (fn : int [] (+ 1 3)))))

(func resolve-first : any-1
 [clauses : list-1 :...]
 (first<-list-any<-any
  clauses
  resolve)
 :doc "Returns the first value that is not nothing")

(func resolve-list : list-1
 [clauses : list-1]
 (list<-list clauses resolve))

(func security<-context : security
 (security<-user (user<-context))
 :context
 :doc "Return security from the given context.")

(func security<-user : security
 [user : user]
 (:security user)
 :doc "Return security from the given user.")

(func session<-context : session
 (:session context)
 :context
 :doc "Returns session from a context")

(func setting<-context : setting
 (:setting context)
 :context
 :doc "Returns setting from a context")

(func string-repeat : string
 [text   : string
  repeat : int]
 (native
  :cpp
   "std::string stringtext = vx_core::vx_string_from_string_repeat(text->vx_string(), repeat->vx_int());
    output = vx_core::vx_new_string(stringtext);"
  :csharp :auto
  :java
   "String stringtext = text.vx_string();
    int intrepeat = repeat.vx_int();
    String stringresult = stringtext.repeat(intrepeat);
    output = Core.vx_new_string(stringresult);"
  :js "text.repeat(repeat)")
 :test (test "abab" (string-repeat "ab" 2)))

(func string<-any : string
 [value : any]
 (string<-any-indent value 0 true)
 :test (test "true"  (string<-any true))
       (test "4"     (string<-any 4))
       (test "5.4"   (string<-any 5.4))
       (test "\"a\"" (string<-any "a"))
       (test
        "(stringlist
          \"a\"
          \"b\"
          \"c\")"
        (string<-any (stringlist "a" "b" "c")))
       (test
        "(stringmap
          :a \"1\"
          :b \"2\")"
        (string<-any (stringmap :a "1" :b "2")))
 :doc "Return a string representation of a value")

(func string<-any-indent : string
 [value    : any
  indent   : int
  linefeed : boolean]
 (native
  :cpp
   "std::string soutput = vx_core::vx_string_from_any_indent(value, indent->vx_int(), linefeed->vx_boolean(), false);
    output = vx_core::vx_new_string(soutput);"
  :csharp :auto
  :java :auto
  :js
   "output = vx_core.vx_string_from_any_indent(value, indent, linefeed)")
 :doc "Return a string representation of a value")

(func string<-func : string
 []
 :doc "Function Type returning string with any parameters")

(func string<-string-find-replace : string
 [text    : string
  find    : string
  replace : string]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto)
 :test (test
        "a!b!c"
        (string<-string-find-replace
         "axybxyc"
         "xy"
         "!"))
 :doc "Returns a string with all instances of find replaced by replace.")

(func stringlist<-map : stringlist
 [map : map-1]
 (list<-map : stringlist
  map
  (fn : string
   [key   : string
    value : any]
   key))
 :test (test
        (stringlist "b" "a")
        (stringlist<-map
         (intmap
          :b 1
          :a 2)))
 :doc "Returns a stringlist of keys from any map in entry order.")

(func switch : any-1
 [val          : any-2
  thenelselist : thenelselist :...]
 (native
  :cpp
   "vx_core::Type_any any = vx_core::vx_switch(generic_any_1, val, thenelselist);
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :csharp :auto
  :java
   "Core.Func_any_from_func fn_any = null;
    List<Core.Type_thenelse> listthenelse = thenelselist.vx_listthenelse();
    for (Core.Type_thenelse thenelse : listthenelse) {
      Core.Type_string code = thenelse.code();
      switch (code.vx_string()) {
      case “:case”:
        Core.Type_any value = thenelse.value();
        Core.Type_boolean iseq = Core.f_eq(val, value);
        if (iseq.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case “:casemany”:
        Core.Type_list values = thenelse.values();
        Core.Type_boolean iscontain = Core.f_contains_1(values, val);
        if (iscontain.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case “:else”:
        fn_any = thenelse.fn_any();
        break;
      }
      if (fn_any != null) {
        break;
      }
    }
    if (fn_any != null) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }"
  :js
   "let fn_any = null
    if (thenelselist.length > 0) {
      for (let valthenelse of thenelselist) {
        const thenelse = valthenelse['vx_value']
        const code = thenelse['code']
        switch (code) {
        case ':case':
          const value = thenelse['value']
          if (value == val) {
            fn_any = thenelse['fn-any']
          } else if (typeof value == 'number') {
            // special handling of notanumber
            if (isNaN(val) && isNaN(value)) {
              fn_any = thenelse['fn-any']
            }
          }
          break
        case ':casemany':
          const values = thenelse['values']
          if (values.includes(val)) {
            fn_any = thenelse['fn-any']
          }
          break
        case ':else':
          fn_any = thenelse['fn-any']
          break
        }
        if (fn_any != null) {
          break
        }
      }
      if (fn_any != null) {
        const fn = fn_any['vx_value']
        if (fn) {
          output = fn()
        }
      }
    }")
 :test (test 1
        (switch : int
         "d"
         (case (list "b" "c" "d") 1)
         (else 2)))
 :doc "Returns a value based on a logical switch")

(func then : thenelse
 [fn-cond : boolean<-func
  fn-any  : any<-func]
 (thenelse
  :code    :then
  :fn-cond fn-cond
  :fn-any  fn-any)
 :doc "Returns a thenelse struct from a given condition function and value function")

(func traits<-typedef : typelist
 [vtypedef : typedef]
 (native
  :cpp
   "vtypedef->traits();"
  :csharp
   "vtypedef.traits();"
  :java
   "vtypedef.traits();"
  :js
   "vtypedef['vx_value']['traits']")
 :doc "Return trait list from type")

(func type<-any : any
 [value : any-1]
 (native
  :cpp
   "value->vx_type();"
  :csharp
   "output = value.vx_type();"
  :java
   "output = value.vx_type();"
  :js
   "switch (typeof value) {
    case 'boolean':
      output = " boolean "
      break
    case 'number':
      switch (value) {
      case " infinity ":
      case " neginfinity ":
      case " notanumber ":
        output = " int "
        break
      default:
        const strval = '' + value
        if (strval.indexOf('.') < 0) {
          output = " int "
        } else {
          output = " float "
        }
        break
      }
      break
    case 'string':
      output = " string "
      break
    case 'function':
      output = " func "
      break
    default:
      output = value['vx_type']
      if (output == vx_core.t_type) {
        output = value
      }
      break
    }")
 :test (test
        boolean
        (type<-any false))
       (test
        int
        (type<-any 5))
       (test
        string
        (type<-any "a"))
 :doc  "Gets the Type of a given Value")

(func typedef<-any : typedef
 [val : any]
 (typedef<-type (type<-any val))
 :doc  "Gets the typedef of a given value")

(func typedef<-type : typedef
 [val : any]
 (native
  :cpp
   "val->vx_typedef();"
  :csharp
   "val.vx_typedef();"
  :java
   "val.vx_typedef();"
  :js
   "output = val")
 :doc  "Gets the typedef of a given type")

(func typename<-any : string
 [value : any-2]
 (typename<-type (type<-any value))
 :test (test "vx/core/boolean" (typename<-any false))
       (test "vx/core/int"     (typename<-any 5))
       (test "vx/core/string"  (typename<-any "a"))
 :doc  "Gets the typename of a given value")

(func typename<-type : string
 [type : any]
 (typename<-typedef (typedef<-type type))
 :doc "Get the name of a given type")

(func typename<-typedef : string
 [vtypedef : typedef]
 (string (:pkgname vtypedef) "/" (:name vtypedef))
 :doc "Get the name of a given type")

(func typenames<-typelist : stringlist
 [typelist : typelist]
 (list<-list : stringlist
  typelist
  (fn : string
   [type : any]
   (typename<-type type)))
 :doc "Get the names from a type list")

(func user<-context : user
 (:user (session<-context))
 :context
 :doc "Returns the current user from context.")
