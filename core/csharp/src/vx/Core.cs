namespace Vx;

public static class Core {

  public interface Map<TKey, TValue> where TKey : notnull {
    public Map<TKey, TValue> copy();
    public TValue get(TKey key);
    public TValue? getOrDefault(TKey key);
    public TValue getOrElse(TKey key, TValue elsevalue);
    public List<TKey> keys();
    public void put(TKey key, TValue value);
    public void remove(TKey key);
    public int size();
  }

  public class LinkedHashMap<TKey, TValue> : Map<TKey, TValue> where TKey : notnull {
    private Dictionary<TKey, TValue> dict = new Dictionary<TKey, TValue>();
    private List<TKey> listkey = new List<TKey>();
    public LinkedHashMap() {
    }
    public LinkedHashMap(Map<TKey, TValue> copy) {
      List<TKey> keys = new List<TKey>(copy.keys());
      foreach (TKey key in keys) {
        TValue? value = copy.getOrDefault(key);
        if (value != null) {
          this.put(key, value);
        }
      }
    }
    public Map<TKey, TValue> copy() {
      return new LinkedHashMap<TKey, TValue>(this);
    }
    public TValue get(TKey key) {
      return dict[key];
    }
    public TValue? getOrDefault(TKey key) {
      TValue? output = default(TValue);
      if (dict.ContainsKey(key)) {
        output = dict[key];
      }
      return output;
    }
    public TValue getOrElse(TKey key, TValue elsevalue) {
      TValue output = elsevalue;
      if (dict.ContainsKey(key)) {
        output = dict[key];
      }
      return output;
    }
    public List<TKey> keys() {
      return listkey;
    }
    public void put(TKey key, TValue value) {
      dict[key] = value;
      if (!dict.ContainsKey(key)) {
      } else if (listkey.Contains(key)) {
      } else {
        listkey.Add(key);
      }
    }
    public void remove(TKey key) {
      listkey.Remove(key);
      dict.Remove(key);
    }
    public int size() {
      return dict.Count;
    }
  }

  public interface Type_replfunc {
    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist);
  }

  public interface Type_replfunc_async {
    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist);
  }

  public static List<Vx.Core.Type_any> emptylistany = new List<Vx.Core.Type_any>();

  public static Map<string, Vx.Core.Type_any> emptymapany = new LinkedHashMap<string, Vx.Core.Type_any>();

  public class Class_base {
    protected int vx_iref = 0;
    public Vx.Core.Type_constdef? vx_p_constdef = null;
    protected Vx.Core.Type_msgblock? vxmsgblock = null;
    public virtual Vx.Core.Type_any vx_new(params object[] vals) {
      return e_any;
    }
    public virtual Vx.Core.Type_any vx_copy(params object[] vals) {
      return e_any;
    }
    public virtual Vx.Core.Type_any vx_empty() {
      return e_any;
    }
    public virtual Vx.Core.Type_any vx_type() {
      return Vx.Core.t_any;
    }
    public virtual Vx.Core.Type_typedef vx_typedef() {
      return Vx.Core.e_typedef;
    }
    public Vx.Core.Type_constdef vx_constdef() {
      if (this.vx_p_constdef == null) {
        return Vx.Core.e_constdef;
      } else {
        return this.vx_p_constdef;
      }
    }
    public List<Type_any> vx_dispose() {
      this.vx_iref = 0;
      this.vx_p_constdef = null;
      this.vxmsgblock = null;
      return emptylistany;
    }
    public Vx.Core.Type_msgblock vx_msgblock() {
      if (this.vxmsgblock == null) {
        return Vx.Core.e_msgblock;
      } else {
        return vxmsgblock;
      }
    }
    public bool vx_release() {
      bool output = false;
      if (this.vx_iref < 0) {
      } else if (vx_iref == 0) {
        vx_iref = -1;
        output = true;
      } else {
        vx_iref -= 1;
      }
      return output;
    }
    public void vx_reserve() {this.vx_iref += 1;}
  }

  public class KeyValue<T> {
    public string key = "";
    public T? value = default(T);
  }

  public static Vx.Core.Type_constdef constdef_new(
    string pkgname,
    string name,
    Vx.Core.Type_any typ
  ) {
    Vx.Core.Class_constdef output = new Vx.Core.Class_constdef();
    output.vx_p_pkgname = Vx.Core.vx_new_string(pkgname);
    output.vx_p_name = Vx.Core.vx_new_string(name);
    output.vx_p_type = typ;
    return output;
  }

  public static Vx.Core.Type_funcdef funcdef_new(
    string pkgname,
    string name,
    int idx,
    bool async,
    Vx.Core.Type_any typ
  ) {
    Vx.Core.Class_funcdef output = new Vx.Core.Class_funcdef();
    output.vx_p_pkgname = Vx.Core.vx_new_string(pkgname);
    output.vx_p_name = Vx.Core.vx_new_string(name);
    output.vx_p_idx = Vx.Core.vx_new_int(idx);
    output.vx_p_async = Vx.Core.vx_new_boolean(async);
    output.vx_p_type = typ;
    return output;
  }

  public static Vx.Core.Type_any[] arrayany_from_anylist(
    Vx.Core.Type_anylist list) {
    return list.vx_list().ToArray();
  }

  public static List<Vx.Core.Type_any> arraylist_from_array(
    params Vx.Core.Type_any[] items) {
    List<Vx.Core.Type_any> output = new List<Vx.Core.Type_any>(items);
    return output;
  }

  public static List<T> arraylist_from_arraylist<T, U>(
    T generic_any_1, List<U> listval)
    where T : Vx.Core.Type_any
    where U : Vx.Core.Type_any {
    List<T> output = new List<T>();
    foreach (Vx.Core.Type_any value in listval) {
      T t_val = Vx.Core.f_any_from_any(generic_any_1, value);
      output.Add(t_val);
    }
    return output;
  }

  public static List<T> arraylist_from_arraylist_fn<T, U>(
    List<U> listval,
    Func<U, T> fn_any_from_any) {
    List<T> output = new List<T>();
    foreach (U value_u in listval) {
      T t_val = fn_any_from_any.Invoke(value_u);
      output.Add(t_val);
    }
    return output;
  }

  public static List<T> arraylist_from_linkedhashmap<T, U>(
    T generic_any_1,
    LinkedHashMap<string, U> mapval)
    where T : Vx.Core.Type_any
    where U : Vx.Core.Type_any {
    List<T> output = new List<T>();
    List<string> keys = mapval.keys();
    foreach (string key in keys) {
      U u_val = mapval.get(key);
      T t_val = Vx.Core.f_any_from_any(generic_any_1, u_val);
      output.Add(t_val);
    }
    return output;
  }

  public static List<T> arraylist_from_linkedhashmap_fn<T, U>(Map<string, U> mapval, Func<string, U, T> fn_any_from_key_value) {
    List<T> output = new List<T>();
    List<string> keys = mapval.keys();
    foreach (string key in keys) {
      U u_val = mapval.get(key);
      T t_val = fn_any_from_key_value.Invoke(key, u_val);
      output.Add(t_val);
    }
    return output;
  }

  public static LinkedHashMap<string, T> hashmap_from_keyvalues<T>(params KeyValue<T>[] keyvalues) {
    LinkedHashMap<string, T> output = new LinkedHashMap<string, T>();
    foreach (KeyValue<T> keyvalue in keyvalues) {
      string key = keyvalue.key;
      T? value = keyvalue.value;
      if (value != null) {
        output.put(key, value);
      }
    }
    return output;
  }

  public static KeyValue<T> keyvalue_from_key_value<T>(string key, T value) {
    KeyValue<T> output = new KeyValue<T>();
    output.key = key;
    output.value = value;
    return output;
  }

  public static List<T> immutablelist<T>(List<T> listval) {
    return listval;
  }

  public static Map<T, U> immutablemap<T, U>(Map<T, U> mapval) where T : notnull {
    return mapval;
  }

  // vx_new(generic_any_1, args...)
  public static T vx_new<T>(T generic_any_1, params object[] vals) where T : Vx.Core.Type_any {
    Vx.Core.Type_any val = generic_any_1.vx_new(vals);
    T output = Vx.Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  // vx_copy(generic_any_1, args...)
  public static T vx_copy<T>(T copyval, params object[] vals) where T : Vx.Core.Type_any {
    Vx.Core.Type_any val = copyval.vx_copy(vals);
    T output = (T)val;
    return output;
  }

  // vx_empty(generic_any_1)
  public static T vx_empty<T>(T type) where T : Vx.Core.Type_any {
    T output = (T)(type.vx_empty());
    return output;
  }

  // vx_type(generic_any_1)
  public static T vx_type<T>(T type) where T : Vx.Core.Type_any {
    T output = (T)(type.vx_type());
    return output;
  }

  // vx_any_first_from_list_fn(generic_any_1, list, fn_any)
  public static T vx_any_first_from_list_fn<T>(
    T generic_any_1,
    Core.Type_list list,
    Func<Vx.Core.Type_any, T> fn_any)
    where T : Vx.Core.Type_any {
				T output = Vx.Core.f_empty(generic_any_1);
				List<Vx.Core.Type_any> listany = list.vx_list();
				foreach (Vx.Core.Type_any any in listany) {
				  T val = fn_any(any);
				  if (Vx.Core.f_notempty_1(val).vx_boolean()) {
				    output = val;
				    break;
				  }
				}
    return output;
  }

  // vx_any_from_func(generic_any_1, func, args...)
  public static T vx_any_from_func<T>(T generic_any_1, Vx.Core.Type_replfunc func, params Vx.Core.Type_any[] args) where T : Vx.Core.Type_any {
    Vx.Core.Type_anylist anylist = Vx.Core.vx_new_anylist(args);
    Vx.Core.Type_any val = func.vx_repl(anylist);
    T output = Vx.Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  // vx_any_from_list_start_reduce(any-1, list-2, any-1, any<-reduce)
  public static T vx_any_from_list_start_reduce<T, N>(
    T generic_any_1,
    N list,
    T valstart,
    Vx.Core.Func_any_from_reduce fn_reduce)
    where T : Vx.Core.Type_any
    where N : Vx.Core.Type_list {
    T output = valstart;
    List<Vx.Core.Type_any> listval = list.vx_list();
    foreach (Vx.Core.Type_any item in listval) {
      output = fn_reduce.vx_any_from_reduce(generic_any_1, output, item);
    }
    return output;
  }

  // vx_any_from_list_start_reduce_next(any-1, list-2, any-1, any<-reduce-next)
  public static T vx_any_from_list_start_reduce_next<T, N>(
    T generic_any_1,
    N list,
    T valstart,
    Vx.Core.Func_any_from_reduce_next fn_reduce_next)
    where T : Vx.Core.Type_any
    where N : Vx.Core.Type_list {
    T output = valstart;
    List<Vx.Core.Type_any> listval = list.vx_list();
    Vx.Core.Type_any current = Core.e_any;
    bool first = true;
    foreach (Core.Type_any next in listval) {
      if (first) {
        first = false;
      } else {
        output = fn_reduce_next.vx_any_from_reduce_next(generic_any_1, output, current, next);
      }
      current = next;
    }
    return output;
  }

  // vx_any_from_map_start_reduce(any-1, map-2, any-1, any<-any-key-value)
  public static T vx_any_from_map_start_reduce<T, N>(
    T generic_any_1,
    N map,
    T start,
    Vx.Core.Func_any_from_any_key_value fn_reduce)
    where T : Core.Type_any
    where N : Core.Type_map {
    T output = start;
    Vx.Core.Map<string, Core.Type_any> mapval = map.vx_map();
    List<string> keys = mapval.keys();
    foreach (string skey in keys) {
      Vx.Core.Type_string key = Vx.Core.vx_new_string(skey);
      Vx.Core.Type_any value = mapval.get(skey);
      output = fn_reduce.vx_any_from_any_key_value(generic_any_1, output, key, value);
    }
    return output;
  }

  // vx_any_from_map(generic_any_1, map, string)
  public static T vx_any_from_map<T>(
    T generic_any_1,
    Vx.Core.Type_map valuemap,
    Vx.Core.Type_string key)
    where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    string skey = key.vx_string();
    if (skey.StartsWith(":")) {
      skey = skey.Substring(1);
    }
    Vx.Core.Type_any val = valuemap.vx_map().getOrElse(skey, output);
    output = Vx.Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  public static Task<T> vx_async_from_async<T, U>(T generic_any_1, Task<U> future) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    Task<T> output = future.ContinueWith(tasku => {
      U tval = tasku.Result;
      T result = Vx.Core.f_any_from_any(generic_any_1, tval);
      return result;
    });
    return output;
  }

  public static Task<T> vx_async_from_async_fn<T, U>(Task<U> future, Func<U, T> fn) {
    Task<T> output = future.ContinueWith(tasku => {
      U uval = tasku.Result;
      T tval = fn(uval);
      return tval;
    });
    return output;
  }

  public static Task<T> vx_async_new_from_value<T>(T value) {
    Task<T> output = Task.FromResult<T>(value);
    return output;
  }

  public static Task<List<T>> vx_async_arraylist_from_arraylist_async<T>(List<Task<T>> list_future) {
    Task<T[]> future = Task.WhenAll(list_future);
    Task<List<T>> output = future.ContinueWith(taskarrayt => {
     T[] arrayt = taskarrayt.Result;
     List<T> listt = arrayt.ToList();
     return listt;
    });
    return output;
  }

  // vx_boolean_from_string_ends(string, string)
  public static bool vx_boolean_from_string_ends(string text, string ends) {
    return text.EndsWith(ends);
  }

  // vx_boolean_from_string_find(string, string)
  public static bool vx_boolean_from_string_find(string text, string find) {
    return text.Contains(find);
  }

  // vx_boolean_from_string_starts(string, string)
  public static bool vx_boolean_from_string_starts(string text, string starts) {
    return text.StartsWith(starts);
  }

  // vx_boolean_write_from_map_name_value(map, string, any)
  public static Vx.Core.Type_boolean vx_boolean_write_from_map_name_value(Vx.Core.Type_map valuemap, Vx.Core.Type_string name, Vx.Core.Type_any value) {
    return valuemap.vx_set(name, value);
  }

  // vx_compare(any, any)
  public static Vx.Core.Type_int vx_compare(
    Vx.Core.Type_any val1,
    Vx.Core.Type_any val2) {
    int intresult = 0;
    if ((val1 is Core.Type_number num1) && (val2 is Core.Type_number num2)) {
      float float1 = Vx.Core.vx_new(Core.t_float, num1).vx_float();
      float float2 = Vx.Core.vx_new(Core.t_float, num2).vx_float();
      if (float1 < float2) {
        intresult = -1;
      } else if (float1 > float2) {
        intresult = 1;
      }
    } else {
      string stringval1 = Vx.Core.f_string_from_any(val1).vx_string();
      string stringval2 = Vx.Core.f_string_from_any(val2).vx_string();
      int compare = stringval1.CompareTo(stringval2);
      if (compare > 0) {
        intresult = 1;
      } else if (compare < 0) {
        intresult = -1;
      }
    }
    Vx.Core.Type_int output = Vx.Core.vx_new_int(intresult);
    return output;
  }

  // vx_contains(list-1, any)
  public static Vx.Core.Type_boolean vx_contains_1<T>(
    T values,
    Vx.Core.Type_any find)
    where T : Vx.Core.Type_list {
    bool booleanresult = false;
    List<Vx.Core.Type_any> listvalues = values.vx_list();
    foreach (Vx.Core.Type_any item in listvalues) {
      Vx.Core.Type_boolean iseq = Vx.Core.f_eq(item, find);
      if (iseq.vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    Vx.Core.Type_boolean output = Core.vx_new_boolean(booleanresult);
    return output;
  }

  // vx_eqeq(any, any)
  public static bool vx_eqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    bool output = false;
    if (val1 == val2) {
      output = true;
    } else if (val1.vx_msgblock() != Vx.Core.e_msgblock) {
    } else if (val2.vx_msgblock() != Vx.Core.e_msgblock) {
    } else {
      Vx.Core.Type_any type1 = val1.vx_type();
      Vx.Core.Type_any type2 = val2.vx_type();
      if (type1 != type2) {
      } else if (type1 == Vx.Core.t_int) {
        Vx.Core.Type_int valint1 = (Vx.Core.Type_int)val1;
        Vx.Core.Type_int valint2 = (Vx.Core.Type_int)val2;
        if (valint1.vx_int() == valint2.vx_int()) {
          output = true;
        }
      } else if (type1 == Vx.Core.t_float) {
        Vx.Core.Type_float valfloat1 = (Vx.Core.Type_float)val1;
        Vx.Core.Type_float valfloat2 = (Vx.Core.Type_float)val2;
        if (valfloat1.vx_float() == valfloat2.vx_float()) {
          output = true;
        }
      } else if (type1 == Vx.Core.t_decimal) {
        Vx.Core.Type_decimal valdecimal1 = (Vx.Core.Type_decimal)val1;
        Vx.Core.Type_decimal valdecimal2 = (Vx.Core.Type_decimal)val2;
        if (valdecimal1.vx_string() == valdecimal2.vx_string()) {
          output = true;
        }
      } else if (type1 == Vx.Core.t_string) {
        Vx.Core.Type_string valstring1 = (Vx.Core.Type_string)val1;
        Vx.Core.Type_string valstring2 = (Vx.Core.Type_string)val2;
        if (valstring1.vx_string() == valstring2.vx_string()) {
          output = true;
        }
      }
    }
    return output;
  }

  // vx_float_from_number(number)
  public static float vx_float_from_number(Vx.Core.Type_number num) {
    float output = 0;
    Vx.Core.Type_any type = num.vx_type();
    if (type == Vx.Core.t_float) {
      Vx.Core.Type_float floatval = Vx.Core.f_any_from_any(Vx.Core.t_float, num);
      output = floatval.vx_float();
    } else if (type == Vx.Core.t_int) {
      Vx.Core.Type_int intval = Vx.Core.f_any_from_any(Vx.Core.t_int, num);
      output = intval.vx_int();
    } else if (type == Core.t_decimal) {
      Vx.Core.Type_decimal decval = Core.f_any_from_any(Vx.Core.t_decimal, num);
      output = decval.vx_float();
    }
    return output;
  }

  // vx_float_from_string(string)
  public static float vx_float_from_string(string text) {
    float output = 0;
    try {
      output = float.Parse(text);
    } catch (Exception) {
    }
    return output;
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  public static void vx_global_package_set(string pkgname, Map<string, Vx.Core.Type_any> maptype, Map<string, Vx.Core.Type_any> mapconst, Map<string, Vx.Core.Type_func> mapfunc) {
    Vx.Core.Class_typemap typemap = new Vx.Core.Class_typemap();
		  typemap.vx_p_map = maptype;
	   Vx.Core.Class_constmap constmap = new Vx.Core.Class_constmap();
		  constmap.vx_p_map = mapconst;
		  Vx.Core.Class_funcmap funcmap = new Vx.Core.Class_funcmap();
		  funcmap.vx_p_map = mapfunc;
    Vx.Core.Class_project global = (Vx.Core.Class_project)Vx.Core.c_global;
    Vx.Core.Class_packagemap packagemap = (Vx.Core.Class_packagemap)global.packagemap();
    if (packagemap != Vx.Core.e_packagemap) {
      packagemap = new Vx.Core.Class_packagemap();
      global.vx_p_packagemap = packagemap;
    }
    Map<string, Vx.Core.Type_package> mappackage = new LinkedHashMap<string, Vx.Core.Type_package>(packagemap.vx_p_map);
		  Vx.Core.Class_package pkg = new Vx.Core.Class_package();
		  pkg.vx_p_constmap = constmap;
		  pkg.vx_p_typemap = typemap;
		  pkg.vx_p_funcmap = funcmap;
    mappackage.put(pkgname, pkg);
    packagemap.vx_p_map = mappackage;
  }

  public static T vx_if_2<T>(
    T generic_any_1,
    Vx.Core.Type_thenelselist thenelselist)
    where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    Func<Vx.Core.Type_any, Vx.Core.Func_any_from_func> fnc = (any) => {
      Vx.Core.Func_any_from_func fnany = Vx.Core.e_any_from_func;
      if (any is Vx.Core.Type_thenelse thenelse) {
        Vx.Core.Type_string code = thenelse.code();
        switch (code.vx_string()) {
        case ":then":
          Vx.Core.Func_boolean_from_func fn_cond = thenelse.fn_cond();
          Vx.Core.Type_boolean cond = fn_cond.vx_boolean_from_func();
          if (cond.vx_boolean() == true) {
            fnany = thenelse.fn_any();
          }
          break;
        case ":else":
          fnany = thenelse.fn_any();
          break;
        }
      }
      return fnany;
    };
    Vx.Core.Func_any_from_func fn_any = Vx.Core.vx_any_first_from_list_fn(
      Vx.Core.t_any_from_func,
      thenelselist,
      fnc
    );
    if (fn_any != Vx.Core.e_any_from_func) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }
    return output;
  }

  // vx_int_from_string(string)
  public static int vx_int_from_string(string text) {
    int output = 0;
    try {
      output = int.Parse(text);
    } catch (Exception) {
    }
    return output;
  }

  // vx_int_from_string_find(string, string)
  public static int vx_int_from_string_find(string text, string find) {
    return text.IndexOf(find);
  }

  // vx_int_from_string_findlast(string, string)
  public static int vx_int_from_string_findlast(string text, string findlast) {
    return text.LastIndexOf(findlast);
  }

  // vx_is_float(string)
  public static bool vx_is_float(string text) {
    bool output = false;
    try {
      float.Parse(text);
      output = true;
    } catch (Exception) {
    }
    return output;
  }

  // vx_is_float(any)
  public static bool vx_is_float(Vx.Core.Type_any value) {
    bool output = false;
    if (value is Vx.Core.Type_number) {
      output = true;
    } else if (value is Vx.Core.Type_string) {
      Vx.Core.Type_string valuestring = (Vx.Core.Type_string)value;
      output = Vx.Core.vx_is_float(valuestring.vx_string());
    }
    return output;
  }

  // vx_is_int(string)
  public static bool vx_is_int(string text) {
    bool output = false;
    switch (text) {
    case "notanumber":
    case "infinity":
    case "neginfinity":
      output = true;
      break;
    default:
      try {
        int.Parse(text);
        output = true;
      } catch (Exception) {
      }
      break;
    }
    return output;
  }

  // vx_is_int(any)
  public static bool vx_is_int(Vx.Core.Type_any value) {
    bool result = false;
    if (value == Vx.Core.c_infinity) {
      result = true;
    } else if (value == Vx.Core.c_neginfinity) {
      result = true;
    } else if (value == Vx.Core.c_notanumber) {
      result = true;
    } else if (value is Vx.Core.Type_int) {
      result = true;
    } else if (value is Vx.Core.Type_float) {
      Vx.Core.Type_float valfloat = (Vx.Core.Type_float)value;
      float floatval = valfloat.vx_float();
      if ((int)floatval == floatval) {
        result = true;
      }
    } else if (value is Vx.Core.Type_decimal) {
      Vx.Core.Type_decimal valdec = (Vx.Core.Type_decimal)value;
      string strval = valdec.vx_string();
      try {
        if (int.Parse(strval) == float.Parse(strval)) {
          result = true;
        }
      } catch (Exception) {
      }
    } else if (value is Vx.Core.Type_string) {
      Vx.Core.Type_string valstr = (Vx.Core.Type_string)value;
      string strval = valstr.vx_string();
      result = vx_is_int(strval);
    }
    return result;
  }

  public static X vx_list_from_list_1<X, Y>(
    X generic_list_1,
    Y values,
    Vx.Core.Func_any_from_any fn_any_from_any)
    where X : Vx.Core.Type_list
    where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    List<Vx.Core.Type_any> list_value = values.vx_list();
    Func<Vx.Core.Type_any, Vx.Core.Type_any> fn = (val) => {
      return fn_any_from_any.vx_any_from_any(Vx.Core.t_any, val);
    };
    List<Vx.Core.Type_any> list_result = Vx.Core.arraylist_from_arraylist_fn<Vx.Core.Type_any, Vx.Core.Type_any>(list_value, fn);
    output = Vx.Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
    return output;
  }

  public static Task<X> vx_list_from_list_async<X, Y>(
    X generic_list_1,
    Y values,
    Vx.Core.Func_any_from_any_async fn_any_from_any_async)
    where X : Vx.Core.Type_list
    where Y : Vx.Core.Type_list {
     Func<Vx.Core.Type_any, Task<Vx.Core.Type_any>> fn_future_from_any = (val) => {
      Task<Vx.Core.Type_any> future_any = fn_any_from_any_async.vx_any_from_any_async(
        Vx.Core.t_any, val
      );
      return future_any;
    };
    Func<List<Vx.Core.Type_any>, X> fn_any_from_list = (list_result) => {
      object[] array_result = [.. list_result];
      Vx.Core.Type_any anylist = generic_list_1.vx_new(array_result);
      X work = Core.f_any_from_any(
        generic_list_1,
        anylist
      );
      return work;
    };
    List<Vx.Core.Type_any> list_value = values.vx_list();
    List<Task<Vx.Core.Type_any>> list_async_result = Vx.Core.arraylist_from_arraylist_fn(
      list_value, fn_future_from_any
    );
    Task<List<Vx.Core.Type_any>> async_list_result = Vx.Core.vx_async_arraylist_from_arraylist_async(list_async_result);
    Task<X> output = Vx.Core.vx_async_from_async_fn(
      async_list_result, fn_any_from_list
    );
    return output;
  }

  // vx_list_from_list_intany(generic_list_1, list-2, any<-int-any)
  public static T vx_list_from_list_intany<T, U>(
    T generic_list_1,
    U valuelist,
    Vx.Core.Func_any_from_int_any fn_any_from_int_any)
    where T : Core.Type_list
    where U : Core.Type_list {
    T output = Vx.Core.f_empty(generic_list_1);
    List<Vx.Core.Type_any> listany = valuelist.vx_list();
    if (listany.Count > 0) {
      List<Vx.Core.Type_any> listout = new List<Vx.Core.Type_any>();
      for (int i = 0; i < listany.Count; i++) {
        Vx.Core.Type_int vali = Vx.Core.vx_new_int(i+1);
        Vx.Core.Type_any value = listany[i];
        Vx.Core.Type_any outval = fn_any_from_int_any.vx_any_from_int_any(Core.t_any, vali, value);
        listout.Add(outval);
      }
      output = Vx.Core.vx_new_list(generic_list_1, listout);
    }
    return output;
  }

  public static X vx_list_from_map_1<O, X>(
    X generic_list_1,
    O valuemap,
    Vx.Core.Func_any_from_key_value fn_any_from_key_value)
    where O : Vx.Core.Type_map
    where X : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    Vx.Core.Map<string, Vx.Core.Type_any> map_value = valuemap.vx_map();
    Func<string, Vx.Core.Type_any, Vx.Core.Type_any> fn_key_value = (key, val) => {
      Vx.Core.Type_string valkey = Vx.Core.vx_new_string(key);
      return fn_any_from_key_value.vx_any_from_key_value(Vx.Core.t_any, valkey, val);
    };
    List<Vx.Core.Type_any> listresult = Vx.Core.arraylist_from_linkedhashmap_fn(map_value, fn_key_value);
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(listresult));
    return output;
  }

  public static X vx_list_join_from_list_1<X, Y>(
    X generic_list_1,
    Y values,
    Vx.Core.Func_any_from_any fn_any_from_any)
    where X : Vx.Core.Type_list
    where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    List<Vx.Core.Type_any> list_value = values.vx_list();
    List<Vx.Core.Type_any> list_result = new List<Vx.Core.Type_any>();
    foreach (Vx.Core.Type_any val in list_value) {
      Vx.Core.Type_any listoflist = fn_any_from_any.vx_any_from_any(generic_list_1, val);
      if (listoflist is Core.Type_list vallist) {
        List<Vx.Core.Type_any> listval = vallist.vx_list();
        list_result.AddRange(listval);
      }
    }
    output = Vx.Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
    return output;
  }

  // vx_log(object...)
  public static void vx_log(params object[] values) {
    foreach (object value in values) {
      string text = "";
      if (value is Vx.Core.Type_string valstring) {
        text = valstring.vx_string();
      } else if (value is Vx.Core.Type_any valany) {
        Vx.Core.Type_string valstring2 = Vx.Core.f_string_from_any(valany);
        text = valstring2.vx_string();
      } else {
        text = Vx.Core.vx_string_from_object(value);
      }
      System.Console.WriteLine(text);
    }
  }

  public static N vx_map_from_list<N, Y>(
    N generic_map_1,
    Y vallist,
    Vx.Core.Func_any_from_any fn_any_from_any)
    where N : Vx.Core.Type_map
    where Y : Vx.Core.Type_list {
    N output = Vx.Core.f_empty(generic_map_1);
    List<Vx.Core.Type_any> listval = vallist.vx_list();
    Func<Vx.Core.Type_any, Vx.Core.Type_string> fn_string_from_any = (val) => {
      Vx.Core.Type_string output_string = fn_any_from_any.vx_any_from_any(Vx.Core.t_string, val);
      return output_string;
    };
    Map<string, Vx.Core.Type_any> mapresult = Vx.Core.vx_map_from_list_fn(listval, fn_string_from_any);
    output = Vx.Core.f_any_from_any(generic_map_1, output.vx_new_from_map(mapresult));
    return output;
  }

  public static Map<string, T> vx_map_from_list_fn<T>(List<T> listval, Func<T, Vx.Core.Type_string> fn_any_from_any) {
    Map<string, T> output = new LinkedHashMap<string, T>();
    foreach (T val in listval) {
      Vx.Core.Type_string valkey = fn_any_from_any.Invoke(val);
      string key = valkey.vx_string();
      output.put(key, val);
    }
    return output;
  }

  public static Map<string, T> vx_map_from_map<T, U>(
    Map<string, U> mapval)
    where U : T {
    Map<string, T> output = new LinkedHashMap<string, T>();
    List<string> keys = mapval.keys();
    foreach (string key in keys) {
      U? value = mapval.getOrDefault(key);
      if (value != null) {
        try {
          T castval = (T)value;
          output.put(key, castval);
        } catch (Exception ex) {
          Vx.Core.vx_log("map<-map", ex);
        }
      }
    }
    return output;
  }

  // vx_map_from_map_fn(generic_map, map, fn_any_from_key_value)
  public static T vx_map_from_map_fn<T>(
    T generic_map_1,
    Vx.Core.Type_map valuemap,
    Vx.Core.Func_any_from_key_value fn_any_from_key_value)
    where T : Vx.Core.Type_map {
    T output = Vx.Core.f_empty(generic_map_1);
    Vx.Core.Map<string, Vx.Core.Type_any> mapvalue = valuemap.vx_map();
    if (mapvalue.size() > 0) {
      List<string> keys = mapvalue.keys();
      Vx.Core.Map<string, Vx.Core.Type_any> mapnew = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapvalue.get(key);
        Vx.Core.Type_string stringkey = Vx.Core.vx_new_string(key);
        Vx.Core.Type_any chgvalue = fn_any_from_key_value.vx_any_from_key_value(Vx.Core.t_any, stringkey, value);
        mapnew.put(key, chgvalue);
      }
      Vx.Core.Type_map anymap = generic_map_1.vx_new_from_map(mapnew);
      output = Vx.Core.f_any_from_any(generic_map_1, anymap);
    }
    return output;
  }

  // vx_msg_from_error
  public static Type_msg vx_msg_from_error(string text) {
    Class_msg output = new Class_msg();
    output.vx_p_text = Vx.Core.vx_new_string(text);
    output.vx_p_severity = Vx.Core.c_msg_severe;
    return output;
  }

  // vx_msg_from_error
  public static Type_msg vx_msg_from_error(string path, string code, Vx.Core.Type_any detail) {
    Class_msg output = new Class_msg();
    output.vx_p_path = Vx.Core.vx_new_string(path);
    output.vx_p_code = Vx.Core.vx_new_string(code);
    output.vx_p_detail = detail;
    output.vx_p_severity = Vx.Core.c_msg_severe;
    return output;
  }

  // vx_msg_from_exception
  public static Type_msg vx_msg_from_exception(string text, Exception err) {
    Class_msg output = new Class_msg();
    output.vx_p_text = Vx.Core.vx_new_string(text);
    output.vx_p_severity = Vx.Core.c_msg_severe;
    output.err = err;
    Vx.Core.vx_log(output);
    return output;
  }

  // vx_msgblock_from_copy_arrayval(msgblock, any...)
  public static Vx.Core.Type_msgblock vx_msgblock_from_copy_arrayval(
    Vx.Core.Type_any copy,
    params object[] vals) {
    Vx.Core.Type_msgblock output = Vx.Core.e_msgblock;
    Vx.Core.Type_msgblock copymsgblock = copy.vx_msgblock();
    if (copymsgblock != Vx.Core.e_msgblock) {
      output = copymsgblock;
    }
    return output;
  }

  public static Vx.Core.Type_anylist vx_new_anylist(params Vx.Core.Type_any[] anys) {
    List<Core.Type_any> listany = new List<Vx.Core.Type_any>(anys);
    return vx_new_anylist(listany);
  }

  public static Vx.Core.Type_anylist vx_new_anylist(List<Vx.Core.Type_any> listany) {
    Vx.Core.Class_anylist output = new Vx.Core.Class_anylist();
    output.vx_p_list = immutablelist(listany);
    return output;
  }

  public static Type_boolean vx_new_boolean(bool isval) {
    Type_boolean output = Vx.Core.c_false;
    if (isval) {
      output = Vx.Core.c_true;
    }
    return output;
  }

  public static Type_float vx_new_float(float fval) {
    Class_float output = new Vx.Core.Class_float();
    output.vxfloat = fval;
    return output;
  }

  public static Type_int vx_new_int(int ival) {
    Type_int output;
    if ((ival == 0) && Vx.Core.e_int != null) {
      output = Vx.Core.e_int;
    } else {
      Class_int work = new Vx.Core.Class_int();
      work.vxint = ival;
      output = work;
    }
    return output;
  }

  // vx_new_list(T, List<any>)
  public static T vx_new_list<T>(
    T generic_list_1,
    List<Core.Type_any> listval)
    where T : Core.Type_list {
    Vx.Core.Type_any anylist = generic_list_1.vx_new(listval);
    T output = Vx.Core.f_any_from_any(generic_list_1, anylist);
    return output;
  }

  // vx_new_map(T, Map<string, any>)
  public static T vx_new_map<T>(
    T generic_map_1,
    Map<string, Vx.Core.Type_any> mapval)
    where T : Vx.Core.Type_map {
    Vx.Core.Type_any anymap = generic_map_1.vx_new(mapval);
    T output = Vx.Core.f_any_from_any(generic_map_1, anymap);
    return output;
  }

  public static Type_string vx_new_string(string text) {
    Type_string output;
    if ((text == "") && Vx.Core.e_string != null) {
      output = Vx.Core.e_string;
    } else {
      Class_string work = new Vx.Core.Class_string();
      work.vxstring = text;
      output = work;
    }
    return output;
  }

  public static string vx_string_from_any(Vx.Core.Type_any value) {
    return Vx.Core.vx_string_from_any_indent(value, 0, false);
  }

  public static string vx_string_from_any_indent(
    Vx.Core.Type_any value,
    int indent,
    bool linefeed) {
    string indenttext = Vx.Core.vx_string_repeat(" ", indent);
    string output = "";
    if (indent > 50) {
      output = "Error: Max Depth Exceeded";
    } else if (value == value.vx_type()) {
      if (value is Vx.Core.Type_func valuefunc) {
        Vx.Core.Type_funcdef funcdef = valuefunc.vx_funcdef();
        output = funcdef.pkgname().vx_string() + "/" + funcdef.name().vx_string();
      } else {
        Vx.Core.Type_typedef typedef = value.vx_typedef();
        output = typedef.pkgname().vx_string() + "/" + typedef.name().vx_string();
      }
    } else if (value is Vx.Core.Type_boolean valbool) {
      if (valbool.vx_boolean() == true) {
        output = "true";
      } else {
        output = "false";
      }
    } else if (value is Vx.Core.Type_decimal valdec) {
      output = valdec.vx_string();
    } else if (value is Vx.Core.Type_float valfloat) {
      output = valfloat.vx_float().ToString();
      if (output.EndsWith(".0")) {
        output = output.Substring(0, output.Length - 2);
      }
    } else if (value is Vx.Core.Type_int valint) {
      if (value == Vx.Core.c_notanumber) {
        output = "notanumber";
      } else if (value == Vx.Core.c_infinity) {
        output = "infinity";
      } else if (value == Vx.Core.c_neginfinity) {
        output = "neginfinity";
      } else {
        output = valint.vx_int().ToString();
      }
    } else if (value is Vx.Core.Type_string valstring) {
      string sval = valstring.vx_string();
      if (sval.IndexOf("\"") < 0) {
        sval = "\"" + sval + "\"";
      } else {
        sval = "`" + sval + "`";
      }
      if (valstring.vx_msgblock() != Vx.Core.e_msgblock) {
        string msgtext = Vx.Core.vx_string_from_any_indent(
          valstring.vx_msgblock(), indent, linefeed);
        output  = "\n" + indenttext + "(string";
        output += "\n" + indenttext + " " + sval;
        output += "\n" + indenttext + " " + msgtext + ")";
      } else {
        output = sval;
      }
    } else if (value.vx_constdef() != Vx.Core.e_constdef) {
      Vx.Core.Type_constdef constdef = value.vx_constdef();
      string constpkg = constdef.pkgname().vx_string();
      string constname = constdef.name().vx_string();
      if (constpkg == "vx/core") {
        output = constname;
      } else {
        output = constpkg + "/" + constname;
      }
    } else if (value is Vx.Core.Type_list vallist) {
      Vx.Core.Type_typedef typedef = vallist.vx_typedef();
      Vx.Core.Type_string typedefname = typedef.name();
      int indentint = indent;
      indentint += 1;
      List<Vx.Core.Type_any> listval = vallist.vx_list();
      foreach (Vx.Core.Type_any valsub in listval) {
        string valtext = Vx.Core.vx_string_from_any_indent(valsub, indentint, linefeed);
        output += "\n " + indenttext + valtext;
      }
      if (vallist.vx_msgblock() != Vx.Core.e_msgblock) {
        string msgtext = Vx.Core.vx_string_from_any_indent(vallist.vx_msgblock(), indentint, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
      }
      output = "(" + typedefname.vx_string() + output + ")";
    } else if (value is Vx.Core.Type_map valmap) {
      Vx.Core.Type_typedef typedef = valmap.vx_typedef();
      Vx.Core.Type_string typedefname = typedef.name();
      int indentint = indent;
      indentint += 2;
      Map<string, Vx.Core.Type_any> mapval = valmap.vx_map();
      List<string> keys = mapval.keys();
      foreach (string skey in keys) {
        string key = skey;
        Vx.Core.Type_any valsub = mapval.get(key);
        if (!key.StartsWith(":")) {
          key = ":" + key;
        }
        string strval = Vx.Core.vx_string_from_any_indent(valsub, indentint, linefeed);
        if (strval.Contains("\n")) {
          strval = "\n  " + indenttext + strval;
        } else {
          strval = " " + strval;
        }
        output += "\n" + indenttext + " " + key + strval;
      }
      if (valmap.vx_msgblock() != Vx.Core.e_msgblock) {
        string msgtext = Vx.Core.vx_string_from_any_indent(valmap.vx_msgblock(), indentint, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
      }
      output = "(" + typedefname.vx_string() + output + ")";
    } else if (value is Vx.Core.Type_struct valstruct) {
      Vx.Core.Type_typedef typedef = valstruct.vx_typedef();
      Vx.Core.Type_string typedefname = typedef.name();
      int indentint2 = indent;
      indentint2 += 2;
      Map<string, Vx.Core.Type_any> mapval2 = valstruct.vx_map();
      List<string> keys2 = mapval2.keys();
      foreach (string skey in keys2) {
        string key = skey;
        Vx.Core.Type_any valsub2 = mapval2.get(key);
        if (!Vx.Core.f_is_empty_1(valsub2).vx_boolean()) {
          if (!key.StartsWith(":")) {
            key = ":" + key;
          }
          string strval2 = Vx.Core.vx_string_from_any_indent(valsub2, indentint2, linefeed);
          if (strval2.Contains("\n")) {
            strval2 = "\n  " + indenttext + strval2;
          } else {
            strval2 = " " + strval2;
          }
          output += "\n" + indenttext + " " + key + strval2;
        }
      }
      if (valstruct.vx_msgblock() != Vx.Core.e_msgblock) {
        string msgtext2 = Vx.Core.vx_string_from_any_indent(valstruct.vx_msgblock(), indentint2, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext2;
      }
      output = "(" + typedefname.vx_string() + output + ")";
    } else if (value is Vx.Core.Type_func valfunc) {
      Vx.Core.Type_funcdef funcdef = valfunc.vx_funcdef();
      Vx.Core.Type_string funcdefname = Vx.Core.f_funcname_from_funcdef(funcdef);
      output = funcdefname.vx_string();
      if (valfunc.vx_msgblock() != Vx.Core.e_msgblock) {
        string msgtext = Vx.Core.vx_string_from_any_indent(valfunc.vx_msgblock(), indent, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
      }
      output = "(" + output + ")";
    }
    return output;
  }

  public static Vx.Core.Type_string vx_string_from_any_indent(
    Vx.Core.Type_any value,
    Vx.Core.Type_int indent,
    Vx.Core.Type_boolean linefeed) {
    string soutput = Vx.Core.vx_string_from_any_indent(value, indent.vx_int(), linefeed.vx_boolean());
    Vx.Core.Type_string output = Vx.Core.vx_new_string(soutput);
    return output;
  }

  public static string vx_string_from_object(object obj) {
    string output = "";
    string? text = obj.ToString();
    if (text != null) {
      output = text;
    }
    return output;
  }

  // vx_string_from_string_find_replace(string, string, string)
  public static string vx_string_from_string_find_replace(
    string text,
    string find,
    string replace) {
    string output = text;
    if (find != "") {
      output = text.Replace(find, replace);
    }
    return output;
  }

  // vx_string_from_string_find_replace(string, string, string)
  public static Vx.Core.Type_string vx_string_from_string_find_replace(
    Vx.Core.Type_string text,
    Vx.Core.Type_string find,
    Vx.Core.Type_string replace) {
    string stext = Vx.Core.vx_string_from_string_find_replace(text.vx_string(), find.vx_string(), replace.vx_string());
    Vx.Core.Type_string output = Vx.Core.vx_new_string(stext);
    return output;
  }

  public static string vx_string_from_string_start_end(string text, int start, int end) {
    string output = "";
    int maxlen = text.Length;
    if (end < 0) {
     end += maxlen;
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end > maxlen) {
        end = maxlen;
      }
      output = text.Substring(start - 1, end - start + 1);
    }
    return output;
  }

  public static string vx_string_repeat(string text, int repeat) {
    System.Text.StringBuilder sb = new System.Text.StringBuilder(text.Length * repeat);
    sb.Insert(0, text, repeat);
    string output = sb.ToString();
    return output;
  }

  public static Vx.Core.Type_string vx_string_repeat(Vx.Core.Type_string text, Vx.Core.Type_int repeat) {
    string stext = Vx.Core.vx_string_repeat(text.vx_string(), repeat.vx_int());
    Vx.Core.Type_string output = Vx.Core.vx_new_string(stext);
    return output;
  }

  public static T vx_switch<T, U>(
    T generic_any_1,
    U val,
    Vx.Core.Type_thenelselist thenelselist)
    where T : Vx.Core.Type_any
    where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    Vx.Core.Func_any_from_func fn_any = Vx.Core.e_any_from_func;
    List<Vx.Core.Type_thenelse> listthenelse = thenelselist.vx_listthenelse();
    foreach (Vx.Core.Type_thenelse thenelse in listthenelse) {
      Vx.Core.Type_string code = thenelse.code();
      switch (code.vx_string()) {
      case ":case":
        Vx.Core.Type_any value = thenelse.value();
        Vx.Core.Type_boolean iseq = Vx.Core.f_eq(val, value);
        if (iseq.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case ":casemany":
        Vx.Core.Type_list values = thenelse.values();
        Vx.Core.Type_boolean iscontain = Vx.Core.f_contains_1(values, val);
        if (iscontain.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case ":else":
        fn_any = thenelse.fn_any();
        break;
      }
      if (fn_any != Vx.Core.e_any_from_func) {
        break;
      }
    }
    if (fn_any != Vx.Core.e_any_from_func) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }
    return output;
  }

  public static Vx.Core.Type_typedef typedef_new(
    string pkgname,
    string name,
    string extend,
    Vx.Core.Type_typelist traits,
    Vx.Core.Type_typelist allowtypes,
    Vx.Core.Type_typelist disallowtypes,
    Vx.Core.Type_funclist allowfuncs,
    Vx.Core.Type_funclist disallowfuncs,
    Vx.Core.Type_anylist allowvalues,
    Vx.Core.Type_anylist disallowvalues,
    Vx.Core.Type_argmap properties
  ) {
    Vx.Core.Class_typedef output = new Vx.Core.Class_typedef();
    output.vx_p_pkgname = Vx.Core.vx_new_string(pkgname);
    output.vx_p_name = Vx.Core.vx_new_string(name);
    output.vx_p_extend = Vx.Core.vx_new_string(extend);
    output.vx_p_traits = traits;
    output.vx_p_allowtypes = allowtypes;
    output.vx_p_disallowtypes = disallowtypes;
    output.vx_p_allowfuncs = disallowfuncs;
    output.vx_p_disallowfuncs = disallowfuncs;
    output.vx_p_allowvalues = disallowvalues;
    output.vx_p_disallowvalues = disallowvalues;
    output.vx_p_properties = properties;
    return output;
  }

  public static Vx.Core.Type_anylist vx_anylist_from_arraystring(params string[] arraystring) {
    List<object> listany = new List<object>();
    foreach (string svalue in arraystring) {
      Vx.Core.Type_string value = Vx.Core.vx_new_string(svalue);
      listany.Add(value);
    }
    object[] arrayany = [.. listany];
    Vx.Core.Type_anylist output = Vx.Core.vx_new(Vx.Core.t_anylist, arrayany);
    return output;
  }

  // Warning!: Blocking
  public static T vx_sync_from_async<T>(T generic_any_1, Task<T> future) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    try {
      future.Wait();
      output = future.Result;
    } catch (Exception ex) {
      Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_exception("sync<-async", ex);
      Vx.Core.Type_any val = generic_any_1.vx_new(msg);
      output = Vx.Core.f_any_from_any(generic_any_1, val);
    }
    return output;
  }

  /**
   * type: any
   * Any Value for Variant Type
   * (type any)
   */
  public interface Type_any {
    public Vx.Core.Type_any vx_new(params object[] vals);
    public Vx.Core.Type_any vx_copy(params object[] vals);
    public Vx.Core.Type_any vx_empty();
    public Vx.Core.Type_any vx_type();
    public Vx.Core.Type_typedef vx_typedef();
    public Vx.Core.Type_constdef vx_constdef();
    public List<Vx.Core.Type_any> vx_dispose();
    public Vx.Core.Type_msgblock vx_msgblock();
    public bool vx_release();
    public void vx_reserve();
  }

  public class Class_any : Vx.Core.Class_base, Type_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_any output = Vx.Core.vx_copy(Vx.Core.e_any, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_any output = this;
      bool ischanged = false;
      Vx.Core.Class_any value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_any work = new Vx.Core.Class_any();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "any", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_any e_any = new Vx.Core.Class_any();
  public static Vx.Core.Type_any t_any = new Vx.Core.Class_any();

  /**
   * type: any-async<-func
   * A sync or async function that returns one value.
   * (type any-async<-func)
   */
  public interface Type_any_async_from_func : Vx.Core.Type_any {
  }

  public class Class_any_async_from_func : Vx.Core.Class_base, Type_any_async_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_any_async_from_func output = Vx.Core.vx_copy(Vx.Core.e_any_async_from_func, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_any_async_from_func output = this;
      bool ischanged = false;
      Vx.Core.Class_any_async_from_func value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_any_async_from_func work = new Vx.Core.Class_any_async_from_func();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_async_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_async_from_func;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "any-async<-func", // name
        ":func", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_any_async_from_func e_any_async_from_func = new Vx.Core.Class_any_async_from_func();
  public static Vx.Core.Type_any_async_from_func t_any_async_from_func = new Vx.Core.Class_any_async_from_func();

  /**
   * type: any<-anylist
   * List of any<-any
   * (type any<-anylist)
   */
  public interface Type_any_from_anylist : Vx.Core.Type_list {
    public List<Vx.Core.Func_any_from_any> vx_listany_from_any();
    public Vx.Core.Func_any_from_any vx_any_from_any(Vx.Core.Type_int index);
  }

  public class Class_any_from_anylist : Vx.Core.Class_base, Type_any_from_anylist {

    public List<Vx.Core.Func_any_from_any> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Func_any_from_any>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Func_any_from_any vx_any_from_any(Vx.Core.Type_int index) {
      Vx.Core.Func_any_from_any output = Vx.Core.e_any_from_any;
      Vx.Core.Class_any_from_anylist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Func_any_from_any> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Func_any_from_any> vx_listany_from_any() {
      List<Vx.Core.Func_any_from_any> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Func_any_from_any output = this.vx_any_from_any(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_any_from_anylist output = Vx.Core.vx_copy(Vx.Core.e_any_from_anylist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_any_from_anylist output = this;
      bool ischanged = false;
      Vx.Core.Class_any_from_anylist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Func_any_from_any> listval = new List<Vx.Core.Func_any_from_any>(value.vx_listany_from_any());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Func_any_from_any allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_any_from_anylist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listany_from_any());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Func_any_from_any valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_any_from_anylist work = new Vx.Core.Class_any_from_anylist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_anylist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_anylist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "any<-anylist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_any_from_anylist e_any_from_anylist = new Vx.Core.Class_any_from_anylist();
  public static Vx.Core.Type_any_from_anylist t_any_from_anylist = new Vx.Core.Class_any_from_anylist();

  /**
   * type: anylist
   * A list of any
   * (type anylist)
   */
  public interface Type_anylist : Vx.Core.Type_list {
  }

  public class Class_anylist : Vx.Core.Class_base, Type_anylist {

    public List<Vx.Core.Type_any> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_any>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_anylist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_anylist output = Vx.Core.vx_copy(Vx.Core.e_anylist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_anylist output = this;
      bool ischanged = false;
      Vx.Core.Class_anylist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_any> listval = new List<Vx.Core.Type_any>(value.vx_list());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_any allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_anylist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_list());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_any valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/anylist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/anylist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_anylist work = new Vx.Core.Class_anylist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_anylist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_anylist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "anylist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_anylist e_anylist = new Vx.Core.Class_anylist();
  public static Vx.Core.Type_anylist t_anylist = new Vx.Core.Class_anylist();

  /**
   * type: anymap
   * A map of any
   * (type anymap)
   */
  public interface Type_anymap : Vx.Core.Type_map {
  }

  public class Class_anymap : Vx.Core.Class_base, Type_anymap {

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = this.vx_p_map;
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_any castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(this.vx_p_map);
        if (castval == Vx.Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_anymap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_any);
      return output;
    }

    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_anymap output = new Vx.Core.Class_anymap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_any castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/anymap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_anymap output = Vx.Core.vx_copy(Vx.Core.e_anymap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_anymap output = this;
      bool ischanged = false;
      Vx.Core.Class_anymap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(value.vx_map());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/anymap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_any valany = Vx.Core.e_any;
          if (false) {
          } else if (valsub is Vx.Core.Type_any valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_any) {
            valany = (Vx.Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/anymap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_anymap work = new Vx.Core.Class_anymap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_anymap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_anymap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "anymap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_anymap e_anymap = new Vx.Core.Class_anymap();
  public static Vx.Core.Type_anymap t_anymap = new Vx.Core.Class_anymap();

  /**
   * type: anytype
   * Any Type that allows any Type as a Value
   * (type anytype)
   */
  public interface Type_anytype : Vx.Core.Type_any {
  }

  public class Class_anytype : Vx.Core.Class_base, Type_anytype {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_anytype output = Vx.Core.vx_copy(Vx.Core.e_anytype, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_anytype output = this;
      bool ischanged = false;
      Vx.Core.Class_anytype value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_anytype work = new Vx.Core.Class_anytype();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_anytype;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_anytype;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "anytype", // name
        ":type", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_anytype e_anytype = new Vx.Core.Class_anytype();
  public static Vx.Core.Type_anytype t_anytype = new Vx.Core.Class_anytype();

  /**
   * type: arg
   * A function argument
   * (type arg)
   */
  public interface Type_arg : Vx.Core.Type_struct {
    public Vx.Core.Type_string name();
    public Vx.Core.Type_any argtype();
    public Vx.Core.Func_any_from_func fn_any();
    public Vx.Core.Type_string doc();
  }

  public class Class_arg : Vx.Core.Class_base, Type_arg {

    public Vx.Core.Type_string? vx_p_name = null;

    public Vx.Core.Type_string name() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any? vx_p_argtype = null;

    public Vx.Core.Type_any argtype() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_argtype;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Func_any_from_func? vx_p_fn_any = null;

    public Vx.Core.Func_any_from_func fn_any() {
      Vx.Core.Func_any_from_func output = Vx.Core.e_any_from_func;
      Vx.Core.Func_any_from_func? testnull = vx_p_fn_any;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_doc = null;

    public Vx.Core.Type_string doc() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_doc;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":name")) {
        output = this.name();
      } else if ((skey==":argtype")) {
        output = this.argtype();
      } else if ((skey==":fn-any")) {
        output = this.fn_any();
      } else if ((skey==":doc")) {
        output = this.doc();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":name", this.name());
      map.put(":argtype", this.argtype());
      map.put(":fn-any", this.fn_any());
      map.put(":doc", this.doc());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_arg output = Vx.Core.vx_copy(Vx.Core.e_arg, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_arg output = this;
      bool ischanged = false;
      Vx.Core.Class_arg value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_name = value.name();
      Vx.Core.Type_any vx_p_argtype = value.argtype();
      Vx.Core.Func_any_from_func vx_p_fn_any = value.fn_any();
      Vx.Core.Type_string vx_p_doc = value.doc();
      List<string> validkeys = new List<string>();
      validkeys.Add(":name");
      validkeys.Add(":argtype");
      validkeys.Add(":fn-any");
      validkeys.Add(":doc");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is Vx.Core.Type_string valname) {
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_name = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":argtype")) {
            if (valsub == vx_p_argtype) {
            } else if (valsub is Vx.Core.Type_any valargtype) {
              ischanged = true;
              vx_p_argtype = valargtype;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("argtype"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":fn-any")) {
            if (valsub == vx_p_fn_any) {
            } else if (valsub is Vx.Core.Func_any_from_func valfn_any) {
              ischanged = true;
              vx_p_fn_any = valfn_any;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("fn-any"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":doc")) {
            if (valsub == vx_p_doc) {
            } else if (valsub is Vx.Core.Type_string valdoc) {
              ischanged = true;
              vx_p_doc = valdoc;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_doc = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("doc"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_arg work = new Vx.Core.Class_arg();
        work.vx_p_name = vx_p_name;
        work.vx_p_argtype = vx_p_argtype;
        work.vx_p_fn_any = vx_p_fn_any;
        work.vx_p_doc = vx_p_doc;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_arg;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_arg;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "arg", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_arg e_arg = new Vx.Core.Class_arg();
  public static Vx.Core.Type_arg t_arg = new Vx.Core.Class_arg();

  /**
   * type: arglist
   * A list of arg
   * (type arglist)
   */
  public interface Type_arglist : Vx.Core.Type_list {
    public List<Vx.Core.Type_arg> vx_listarg();
    public Vx.Core.Type_arg vx_arg(Vx.Core.Type_int index);
  }

  public class Class_arglist : Vx.Core.Class_base, Type_arglist {

    public List<Vx.Core.Type_arg> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_arg>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_arg vx_arg(Vx.Core.Type_int index) {
      Vx.Core.Type_arg output = Vx.Core.e_arg;
      Vx.Core.Class_arglist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_arg> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_arg> vx_listarg() {
      List<Vx.Core.Type_arg> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_arg output = this.vx_arg(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_arglist output = Vx.Core.vx_copy(Vx.Core.e_arglist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_arglist output = this;
      bool ischanged = false;
      Vx.Core.Class_arglist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_arg> listval = new List<Vx.Core.Type_arg>(value.vx_listarg());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_arg allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_arg) {
          ischanged = true;
          listval.Add((Vx.Core.Type_arg)valsub);
        } else if (valsub is Vx.Core.Type_arglist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listarg());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_arg valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/arglist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/arglist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_arglist work = new Vx.Core.Class_arglist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_arglist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_arglist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "arglist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_arg), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_arglist e_arglist = new Vx.Core.Class_arglist();
  public static Vx.Core.Type_arglist t_arglist = new Vx.Core.Class_arglist();

  /**
   * type: argmap
   * A map of arg
   * (type argmap)
   */
  public interface Type_argmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_arg> vx_maparg();
    public Vx.Core.Type_arg vx_arg(Vx.Core.Type_string key);
  }

  public class Class_argmap : Vx.Core.Class_base, Type_argmap {

    public Vx.Core.Map<string, Vx.Core.Type_arg> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_arg>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_arg>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_arg castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_arg> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_arg>(this.vx_p_map);
        if (castval == Vx.Core.e_arg) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_arg vx_arg(Vx.Core.Type_string key) {
      Vx.Core.Type_arg output = Vx.Core.e_arg;
      Vx.Core.Class_argmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_arg> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_arg);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_arg> vx_maparg() {
      Vx.Core.Map<string, Vx.Core.Type_arg> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_arg(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_argmap output = new Vx.Core.Class_argmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_arg> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_arg>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_arg castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/argmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_argmap output = Vx.Core.vx_copy(Vx.Core.e_argmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_argmap output = this;
      bool ischanged = false;
      Vx.Core.Class_argmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_arg> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_arg>(value.vx_maparg());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/argmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_arg valany = Vx.Core.e_arg;
          if (false) {
          } else if (valsub is Vx.Core.Type_arg valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_arg) {
            valany = (Vx.Core.Type_arg)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/argmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_argmap work = new Vx.Core.Class_argmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_argmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_argmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "argmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_arg), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_argmap e_argmap = new Vx.Core.Class_argmap();
  public static Vx.Core.Type_argmap t_argmap = new Vx.Core.Class_argmap();

  /**
   * type: boolean
   * Standard Boolean Type
   * (type boolean)
   */
  public interface Type_boolean : Vx.Core.Type_any {
    public bool vx_boolean();
  }

  public class Class_boolean : Vx.Core.Class_base, Type_boolean {

    internal bool vxboolean = false;
    
    // :implements
    public bool vx_boolean() {
      return vxboolean;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_boolean output = Vx.Core.vx_copy(Vx.Core.e_boolean, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_boolean output = this;
      bool ischanged = false;
      Vx.Core.Class_boolean value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      bool booleanval = value.vx_boolean();
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_boolean valboolean) {
          booleanval = booleanval || valboolean.vx_boolean();
        } else if (valsub is bool issubval) {
          booleanval = booleanval || issubval;
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_boolean work = new Vx.Core.Class_boolean();
        work.vxboolean = booleanval;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      } else if (booleanval) {
        output = Vx.Core.c_true;
      } else {
        output = Vx.Core.c_false;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_boolean;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_boolean;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "boolean", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_boolean t_boolean = new Vx.Core.Class_boolean();

  /**
   * type: booleanlist
   * (type booleanlist)
   */
  public interface Type_booleanlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_boolean> vx_listboolean();
    public Vx.Core.Type_boolean vx_boolean(Vx.Core.Type_int index);
  }

  public class Class_booleanlist : Vx.Core.Class_base, Type_booleanlist {

    public List<Vx.Core.Type_boolean> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_boolean>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_boolean vx_boolean(Vx.Core.Type_int index) {
      Vx.Core.Type_boolean output = Vx.Core.e_boolean;
      Vx.Core.Class_booleanlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_boolean> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_boolean> vx_listboolean() {
      List<Vx.Core.Type_boolean> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_boolean output = this.vx_boolean(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_booleanlist output = Vx.Core.vx_copy(Vx.Core.e_booleanlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_booleanlist output = this;
      bool ischanged = false;
      Vx.Core.Class_booleanlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_boolean> listval = new List<Vx.Core.Type_boolean>(value.vx_listboolean());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_boolean allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is bool) {
          ischanged = true;
          listval.Add(Vx.Core.vx_new(Vx.Core.t_boolean, valsub));
        } else if (valsub is Vx.Core.Type_booleanlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listboolean());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_boolean valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_booleanlist work = new Vx.Core.Class_booleanlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_booleanlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_booleanlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "booleanlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_boolean), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_booleanlist e_booleanlist = new Vx.Core.Class_booleanlist();
  public static Vx.Core.Type_booleanlist t_booleanlist = new Vx.Core.Class_booleanlist();

  /**
   * type: collection
   * (type collection)
   */
  public interface Type_collection : Vx.Core.Type_any {
  }

  public class Class_collection : Vx.Core.Class_base, Type_collection {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_collection output = Vx.Core.vx_copy(Vx.Core.e_collection, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_collection output = this;
      bool ischanged = false;
      Vx.Core.Class_collection value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_collection work = new Vx.Core.Class_collection();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_collection;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_collection;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "collection", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_list, Vx.Core.t_map), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_collection e_collection = new Vx.Core.Class_collection();
  public static Vx.Core.Type_collection t_collection = new Vx.Core.Class_collection();

  /**
   * type: compilelanguages
   * (type compilelanguages)
   */
  public interface Type_compilelanguages : Vx.Core.Type_any {
  }

  public class Class_compilelanguages : Vx.Core.Class_base, Type_compilelanguages {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_compilelanguages output = Vx.Core.vx_copy(Vx.Core.e_compilelanguages, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_compilelanguages output = this;
      bool ischanged = false;
      Vx.Core.Class_compilelanguages value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_compilelanguages work = new Vx.Core.Class_compilelanguages();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_compilelanguages;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_compilelanguages;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "compilelanguages", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_compilelanguages e_compilelanguages = new Vx.Core.Class_compilelanguages();
  public static Vx.Core.Type_compilelanguages t_compilelanguages = new Vx.Core.Class_compilelanguages();

  /**
   * type: connect
   * General connect trait
   * (type connect)
   */
  public interface Type_connect : Vx.Core.Type_any {
  }

  public class Class_connect : Vx.Core.Class_base, Type_connect {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_connect output = Vx.Core.vx_copy(Vx.Core.e_connect, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_connect output = this;
      bool ischanged = false;
      Vx.Core.Class_connect value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_connect work = new Vx.Core.Class_connect();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_connect;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_connect;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "connect", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_connect e_connect = new Vx.Core.Class_connect();
  public static Vx.Core.Type_connect t_connect = new Vx.Core.Class_connect();

  /**
   * type: connectlist
   * List of connect
   * (type connectlist)
   */
  public interface Type_connectlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_connect> vx_listconnect();
    public Vx.Core.Type_connect vx_connect(Vx.Core.Type_int index);
  }

  public class Class_connectlist : Vx.Core.Class_base, Type_connectlist {

    public List<Vx.Core.Type_connect> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_connect>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_connect vx_connect(Vx.Core.Type_int index) {
      Vx.Core.Type_connect output = Vx.Core.e_connect;
      Vx.Core.Class_connectlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_connect> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_connect> vx_listconnect() {
      List<Vx.Core.Type_connect> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_connect output = this.vx_connect(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_connectlist output = Vx.Core.vx_copy(Vx.Core.e_connectlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_connectlist output = this;
      bool ischanged = false;
      Vx.Core.Class_connectlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_connect> listval = new List<Vx.Core.Type_connect>(value.vx_listconnect());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_connect allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_connect) {
          ischanged = true;
          listval.Add((Vx.Core.Type_connect)valsub);
        } else if (valsub is Vx.Core.Type_connectlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listconnect());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_connect valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_connectlist work = new Vx.Core.Class_connectlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_connectlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_connectlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "connectlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_connect), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_connectlist e_connectlist = new Vx.Core.Class_connectlist();
  public static Vx.Core.Type_connectlist t_connectlist = new Vx.Core.Class_connectlist();

  /**
   * type: connectmap
   * Map of connect
   * (type connectmap)
   */
  public interface Type_connectmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_connect> vx_mapconnect();
    public Vx.Core.Type_connect vx_connect(Vx.Core.Type_string key);
  }

  public class Class_connectmap : Vx.Core.Class_base, Type_connectmap {

    public Vx.Core.Map<string, Vx.Core.Type_connect> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_connect>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_connect>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_connect castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_connect> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_connect>(this.vx_p_map);
        if (castval == Vx.Core.e_connect) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_connect vx_connect(Vx.Core.Type_string key) {
      Vx.Core.Type_connect output = Vx.Core.e_connect;
      Vx.Core.Class_connectmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_connect> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_connect);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_connect> vx_mapconnect() {
      Vx.Core.Map<string, Vx.Core.Type_connect> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_connect(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_connectmap output = new Vx.Core.Class_connectmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_connect> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_connect>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_connect castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/connectmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_connectmap output = Vx.Core.vx_copy(Vx.Core.e_connectmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_connectmap output = this;
      bool ischanged = false;
      Vx.Core.Class_connectmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_connect> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_connect>(value.vx_mapconnect());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/connectmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_connect valany = Vx.Core.e_connect;
          if (false) {
          } else if (valsub is Vx.Core.Type_connect valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_connect) {
            valany = (Vx.Core.Type_connect)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/connectmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_connectmap work = new Vx.Core.Class_connectmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_connectmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_connectmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "connectmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_connect), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_connectmap e_connectmap = new Vx.Core.Class_connectmap();
  public static Vx.Core.Type_connectmap t_connectmap = new Vx.Core.Class_connectmap();

  /**
   * type: const
   * Original Constant Class.
   * (type const)
   */
  public interface Type_const : Vx.Core.Type_any {
  }

  public class Class_const : Vx.Core.Class_base, Type_const {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_const output = Vx.Core.vx_copy(Vx.Core.e_const, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_const output = this;
      bool ischanged = false;
      Vx.Core.Class_const value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_const work = new Vx.Core.Class_const();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_const;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_const;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "const", // name
        ":const", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_const e_const = new Vx.Core.Class_const();
  public static Vx.Core.Type_const t_const = new Vx.Core.Class_const();

  /**
   * type: constdef
   * Const Definition Class for inspecting properties.
   * (type constdef)
   */
  public interface Type_constdef : Vx.Core.Type_struct {
    public Vx.Core.Type_string pkgname();
    public Vx.Core.Type_string name();
    public Vx.Core.Type_any type();
  }

  public class Class_constdef : Vx.Core.Class_base, Type_constdef {

    public Vx.Core.Type_string? vx_p_pkgname = null;

    public Vx.Core.Type_string pkgname() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_name = null;

    public Vx.Core.Type_string name() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any? vx_p_type = null;

    public Vx.Core.Type_any type() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_type;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname();
      } else if ((skey==":name")) {
        output = this.name();
      } else if ((skey==":type")) {
        output = this.type();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":name", this.name());
      map.put(":type", this.type());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_constdef output = Vx.Core.vx_copy(Vx.Core.e_constdef, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_constdef output = this;
      bool ischanged = false;
      Vx.Core.Class_constdef value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_pkgname = value.pkgname();
      Vx.Core.Type_string vx_p_name = value.name();
      Vx.Core.Type_any vx_p_type = value.type();
      List<string> validkeys = new List<string>();
      validkeys.Add(":pkgname");
      validkeys.Add(":name");
      validkeys.Add(":type");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/constdef", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is Vx.Core.Type_string valpkgname) {
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_pkgname = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is Vx.Core.Type_string valname) {
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_name = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":type")) {
            if (valsub == vx_p_type) {
            } else if (valsub is Vx.Core.Type_any valtype) {
              ischanged = true;
              vx_p_type = valtype;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("type"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_constdef work = new Vx.Core.Class_constdef();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_name = vx_p_name;
        work.vx_p_type = vx_p_type;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_constdef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_constdef;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "constdef", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_constdef e_constdef = new Vx.Core.Class_constdef();
  public static Vx.Core.Type_constdef t_constdef = new Vx.Core.Class_constdef();

  /**
   * type: constlist
   * List of Const.
   * (type constlist)
   */
  public interface Type_constlist : Vx.Core.Type_list {
  }

  public class Class_constlist : Vx.Core.Class_base, Type_constlist {

    public List<Vx.Core.Type_any> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_any>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_constlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_constlist output = Vx.Core.vx_copy(Vx.Core.e_constlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_constlist output = this;
      bool ischanged = false;
      Vx.Core.Class_constlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_any> listval = new List<Vx.Core.Type_any>(value.vx_list());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_any allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_constlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_list());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_any valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/constlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/constlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_constlist work = new Vx.Core.Class_constlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_constlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_constlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "constlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_constlist e_constlist = new Vx.Core.Class_constlist();
  public static Vx.Core.Type_constlist t_constlist = new Vx.Core.Class_constlist();

  /**
   * type: constmap
   * Map of Const.
   * (type constmap)
   */
  public interface Type_constmap : Vx.Core.Type_map {
  }

  public class Class_constmap : Vx.Core.Class_base, Type_constmap {

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = this.vx_p_map;
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_any castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(this.vx_p_map);
        if (castval == Vx.Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_constmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_any);
      return output;
    }

    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_constmap output = new Vx.Core.Class_constmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_any castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/constmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_constmap output = Vx.Core.vx_copy(Vx.Core.e_constmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_constmap output = this;
      bool ischanged = false;
      Vx.Core.Class_constmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(value.vx_map());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/constmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_any valany = Vx.Core.e_any;
          if (false) {
          } else if (valsub is Vx.Core.Type_any valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_any) {
            valany = (Vx.Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/constmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_constmap work = new Vx.Core.Class_constmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_constmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_constmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "constmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_constmap e_constmap = new Vx.Core.Class_constmap();
  public static Vx.Core.Type_constmap t_constmap = new Vx.Core.Class_constmap();

  /**
   * type: context
   * Context
   * (type context)
   */
  public interface Type_context : Vx.Core.Type_struct {
    public Vx.Core.Type_string code();
    public Vx.Core.Type_session session();
    public Vx.Core.Type_setting setting();
    public Vx.Core.Type_state state();
  }

  public class Class_context : Vx.Core.Class_base, Type_context {

    public Vx.Core.Type_string? vx_p_code = null;

    public Vx.Core.Type_string code() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_code;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_session? vx_p_session = null;

    public Vx.Core.Type_session session() {
      Vx.Core.Type_session output = Vx.Core.e_session;
      Vx.Core.Type_session? testnull = vx_p_session;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_setting? vx_p_setting = null;

    public Vx.Core.Type_setting setting() {
      Vx.Core.Type_setting output = Vx.Core.e_setting;
      Vx.Core.Type_setting? testnull = vx_p_setting;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_state? vx_p_state = null;

    public Vx.Core.Type_state state() {
      Vx.Core.Type_state output = Vx.Core.e_state;
      Vx.Core.Type_state? testnull = vx_p_state;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":code")) {
        output = this.code();
      } else if ((skey==":session")) {
        output = this.session();
      } else if ((skey==":setting")) {
        output = this.setting();
      } else if ((skey==":state")) {
        output = this.state();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":code", this.code());
      map.put(":session", this.session());
      map.put(":setting", this.setting());
      map.put(":state", this.state());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_context output = Vx.Core.vx_copy(Vx.Core.e_context, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_context output = this;
      bool ischanged = false;
      Vx.Core.Class_context value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_code = value.code();
      Vx.Core.Type_session vx_p_session = value.session();
      Vx.Core.Type_setting vx_p_setting = value.setting();
      Vx.Core.Type_state vx_p_state = value.state();
      List<string> validkeys = new List<string>();
      validkeys.Add(":code");
      validkeys.Add(":session");
      validkeys.Add(":setting");
      validkeys.Add(":state");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":code")) {
            if (valsub == vx_p_code) {
            } else if (valsub is Vx.Core.Type_string valcode) {
              ischanged = true;
              vx_p_code = valcode;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_code = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("code"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":session")) {
            if (valsub == vx_p_session) {
            } else if (valsub is Vx.Core.Type_session valsession) {
              ischanged = true;
              vx_p_session = valsession;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("session"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":setting")) {
            if (valsub == vx_p_setting) {
            } else if (valsub is Vx.Core.Type_setting valsetting) {
              ischanged = true;
              vx_p_setting = valsetting;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("setting"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":state")) {
            if (valsub == vx_p_state) {
            } else if (valsub is Vx.Core.Type_state valstate) {
              ischanged = true;
              vx_p_state = valstate;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("state"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_context work = new Vx.Core.Class_context();
        work.vx_p_code = vx_p_code;
        work.vx_p_session = vx_p_session;
        work.vx_p_setting = vx_p_setting;
        work.vx_p_state = vx_p_state;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_context;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "context", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_context e_context = new Vx.Core.Class_context();
  public static Vx.Core.Type_context t_context = new Vx.Core.Class_context();

  /**
   * type: date
   * A simple UTC date.
   * (type date)
   */
  public interface Type_date : Vx.Core.Type_any {
  }

  public class Class_date : Vx.Core.Class_base, Type_date {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_date output = Vx.Core.vx_copy(Vx.Core.e_date, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_date output = this;
      bool ischanged = false;
      Vx.Core.Class_date value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_date work = new Vx.Core.Class_date();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_date;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_date;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "date", // name
        ":string", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_date e_date = new Vx.Core.Class_date();
  public static Vx.Core.Type_date t_date = new Vx.Core.Class_date();

  /**
   * type: decimal
   * A clean version of float like Java BigDecimal.
   * (type decimal)
   */
  public interface Type_decimal : Vx.Core.Type_number {
    public float vx_float();
    public string vx_string();
    public Type_decimal vx_new_from_string(string sval);
  }

  public class Class_decimal : Vx.Core.Class_base, Type_decimal {

    internal string vxdecimal = "0.0";
    
    // :implements
    public float vx_float() {
      return float.Parse(vxdecimal);
    }
    
    // :implements
    public string vx_string() {
      return vxdecimal;
    }
    
    // :implements
    public Type_decimal vx_new_from_string(string sval) {
      Class_decimal output = new Class_decimal();
      output.vxdecimal = sval;
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_decimal output = Vx.Core.vx_copy(Vx.Core.e_decimal, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_decimal output = this;
      bool ischanged = false;
      Vx.Core.Class_decimal value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      string sval = value.vx_string();
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_string valstring) {
          ischanged = true;
          sval = valstring.vx_string();
        } else if (valsub is string svalsub) {
          ischanged = true;
          sval = svalsub;
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_decimal work = new Vx.Core.Class_decimal();
        work.vxdecimal = sval;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_decimal;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_decimal;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "decimal", // name
        "", // extends
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_decimal e_decimal = new Vx.Core.Class_decimal();
  public static Vx.Core.Type_decimal t_decimal = new Vx.Core.Class_decimal();

  /**
   * type: error
   * Error Type
   * (type error)
   */
  public interface Type_error : Vx.Core.Type_any {
  }

  public class Class_error : Vx.Core.Class_base, Type_error {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_error output = Vx.Core.vx_copy(Vx.Core.e_error, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_error output = this;
      bool ischanged = false;
      Vx.Core.Class_error value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_error work = new Vx.Core.Class_error();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_error;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_error;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "error", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_error e_error = new Vx.Core.Class_error();
  public static Vx.Core.Type_error t_error = new Vx.Core.Class_error();

  /**
   * type: float
   * Standard Floating Point Number
   * (type float)
   */
  public interface Type_float : Vx.Core.Type_number {
    public float vx_float();
  }

  public class Class_float : Vx.Core.Class_base, Type_float {

    internal float vxfloat = 0;
    
    // :implements
    public float vx_float() {
      return vxfloat;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_float output = Vx.Core.vx_copy(Vx.Core.e_float, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_float output = this;
      bool ischanged = false;
      Vx.Core.Class_float value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      float floatval = value.vx_float();
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_decimal valdecimal) {
          ischanged = true;
          floatval += valdecimal.vx_float();
        } else if (valsub is Vx.Core.Type_float valfloat) {
          ischanged = true;
          floatval += valfloat.vx_float();
        } else if (valsub is Vx.Core.Type_int valint) {
          ischanged = true;
          floatval += valint.vx_int();
        } else if (valsub is Vx.Core.Type_string valstring) {
          ischanged = true;
          floatval += float.Parse(valstring.vx_string());
        } else if (valsub is float fval) {
          ischanged = true;
          floatval += fval;
        } else if (valsub is int ival) {
          ischanged = true;
          floatval += ival;
        } else if (valsub is string sval) {
          ischanged = true;
          floatval += float.Parse(sval);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_float work = new Vx.Core.Class_float();
        work.vxfloat = floatval;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_float;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_float;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "float", // name
        "", // extends
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_float e_float = new Vx.Core.Class_float();
  public static Vx.Core.Type_float t_float = new Vx.Core.Class_float();

  /**
   * type: func
   * Original Function Class.
   * (type func)
   */
  public interface Type_func : Vx.Core.Type_any {
    public Vx.Core.Type_funcdef vx_funcdef();
  }

  public class Class_func : Vx.Core.Class_base, Type_func {

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.e_funcdef;
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_func output = Vx.Core.vx_copy(Vx.Core.e_func, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_func output = this;
      bool ischanged = false;
      Vx.Core.Class_func value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_func work = new Vx.Core.Class_func();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_func;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "func", // name
        ":func", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_func e_func = new Vx.Core.Class_func();
  public static Vx.Core.Type_func t_func = new Vx.Core.Class_func();

  /**
   * type: funcdef
   * Func Definition Class for inspecting properties.
   * (type funcdef)
   */
  public interface Type_funcdef : Vx.Core.Type_struct {
    public Vx.Core.Type_string pkgname();
    public Vx.Core.Type_string name();
    public Vx.Core.Type_int idx();
    public Vx.Core.Type_any type();
    public Vx.Core.Type_boolean async();
  }

  public class Class_funcdef : Vx.Core.Class_base, Type_funcdef {

    public Vx.Core.Type_string? vx_p_pkgname = null;

    public Vx.Core.Type_string pkgname() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_name = null;

    public Vx.Core.Type_string name() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_int? vx_p_idx = null;

    public Vx.Core.Type_int idx() {
      Vx.Core.Type_int output = Vx.Core.e_int;
      Vx.Core.Type_int? testnull = vx_p_idx;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any? vx_p_type = null;

    public Vx.Core.Type_any type() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_type;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_boolean? vx_p_async = null;

    public Vx.Core.Type_boolean async() {
      Vx.Core.Type_boolean output = Vx.Core.e_boolean;
      Vx.Core.Type_boolean? testnull = vx_p_async;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname();
      } else if ((skey==":name")) {
        output = this.name();
      } else if ((skey==":idx")) {
        output = this.idx();
      } else if ((skey==":type")) {
        output = this.type();
      } else if ((skey==":async")) {
        output = this.async();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":name", this.name());
      map.put(":idx", this.idx());
      map.put(":type", this.type());
      map.put(":async", this.async());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_funcdef output = Vx.Core.vx_copy(Vx.Core.e_funcdef, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_funcdef output = this;
      bool ischanged = false;
      Vx.Core.Class_funcdef value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_pkgname = value.pkgname();
      Vx.Core.Type_string vx_p_name = value.name();
      Vx.Core.Type_int vx_p_idx = value.idx();
      Vx.Core.Type_any vx_p_type = value.type();
      Vx.Core.Type_boolean vx_p_async = value.async();
      List<string> validkeys = new List<string>();
      validkeys.Add(":pkgname");
      validkeys.Add(":name");
      validkeys.Add(":idx");
      validkeys.Add(":type");
      validkeys.Add(":async");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is Vx.Core.Type_string valpkgname) {
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_pkgname = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is Vx.Core.Type_string valname) {
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_name = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":idx")) {
            if (valsub == vx_p_idx) {
            } else if (valsub is Vx.Core.Type_int validx) {
              ischanged = true;
              vx_p_idx = validx;
            } else if (valsub is int) {
              ischanged = true;
              vx_p_idx = Vx.Core.vx_new(Vx.Core.t_int, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("idx"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":type")) {
            if (valsub == vx_p_type) {
            } else if (valsub is Vx.Core.Type_any valtype) {
              ischanged = true;
              vx_p_type = valtype;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("type"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":async")) {
            if (valsub == vx_p_async) {
            } else if (valsub is Vx.Core.Type_boolean valasync) {
              ischanged = true;
              vx_p_async = valasync;
            } else if (valsub is bool) {
              ischanged = true;
              vx_p_async = Vx.Core.vx_new(Vx.Core.t_boolean, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("async"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_funcdef work = new Vx.Core.Class_funcdef();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_name = vx_p_name;
        work.vx_p_idx = vx_p_idx;
        work.vx_p_type = vx_p_type;
        work.vx_p_async = vx_p_async;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_funcdef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_funcdef;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "funcdef", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_funcdef e_funcdef = new Vx.Core.Class_funcdef();
  public static Vx.Core.Type_funcdef t_funcdef = new Vx.Core.Class_funcdef();

  /**
   * type: funclist
   * List of Func.
   * (type funclist)
   */
  public interface Type_funclist : Vx.Core.Type_list {
    public List<Vx.Core.Type_func> vx_listfunc();
    public Vx.Core.Type_func vx_func(Vx.Core.Type_int index);
  }

  public class Class_funclist : Vx.Core.Class_base, Type_funclist {

    public List<Vx.Core.Type_func> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_func>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_func vx_func(Vx.Core.Type_int index) {
      Vx.Core.Type_func output = Vx.Core.e_func;
      Vx.Core.Class_funclist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_func> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_func> vx_listfunc() {
      List<Vx.Core.Type_func> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_func output = this.vx_func(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_funclist output = Vx.Core.vx_copy(Vx.Core.e_funclist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_funclist output = this;
      bool ischanged = false;
      Vx.Core.Class_funclist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_func> listval = new List<Vx.Core.Type_func>(value.vx_listfunc());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_func allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_func) {
          ischanged = true;
          listval.Add((Vx.Core.Type_func)valsub);
        } else if (valsub is Vx.Core.Type_funclist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listfunc());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_func valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/funclist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/funclist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_funclist work = new Vx.Core.Class_funclist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_funclist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_funclist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "funclist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_func), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_funclist e_funclist = new Vx.Core.Class_funclist();
  public static Vx.Core.Type_funclist t_funclist = new Vx.Core.Class_funclist();

  /**
   * type: funcmap
   * Map of Func.
   * (type funcmap)
   */
  public interface Type_funcmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_func> vx_mapfunc();
    public Vx.Core.Type_func vx_func(Vx.Core.Type_string key);
  }

  public class Class_funcmap : Vx.Core.Class_base, Type_funcmap {

    public Vx.Core.Map<string, Vx.Core.Type_func> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_func>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_func>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_func castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_func> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_func>(this.vx_p_map);
        if (castval == Vx.Core.e_func) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_func vx_func(Vx.Core.Type_string key) {
      Vx.Core.Type_func output = Vx.Core.e_func;
      Vx.Core.Class_funcmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_func> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_func);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_func> vx_mapfunc() {
      Vx.Core.Map<string, Vx.Core.Type_func> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_func(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_funcmap output = new Vx.Core.Class_funcmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_func> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_func>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_func castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/funcmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_funcmap output = Vx.Core.vx_copy(Vx.Core.e_funcmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_funcmap output = this;
      bool ischanged = false;
      Vx.Core.Class_funcmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_func> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_func>(value.vx_mapfunc());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/funcmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_func valany = Vx.Core.e_func;
          if (false) {
          } else if (valsub is Vx.Core.Type_func valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_func) {
            valany = (Vx.Core.Type_func)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/funcmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_funcmap work = new Vx.Core.Class_funcmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_funcmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_funcmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "funcmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_func), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_funcmap e_funcmap = new Vx.Core.Class_funcmap();
  public static Vx.Core.Type_funcmap t_funcmap = new Vx.Core.Class_funcmap();

  /**
   * type: int
   * A simple integer.
   * (type int)
   */
  public interface Type_int : Vx.Core.Type_number {
    public int vx_int();
  }

  public class Class_int : Vx.Core.Class_base, Type_int {

    internal int vxint = 0;
    
    // :implements
    public int vx_int() {
      return vxint;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_int output = Vx.Core.vx_copy(Vx.Core.e_int, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_int output = this;
      bool ischanged = false;
      Vx.Core.Class_int value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      int intval = value.vx_int();
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_int valint) {
          ischanged = true;
          intval += valint.vx_int();
        } else if (valsub is int ival) {
          ischanged = true;
          intval += ival;
        } else if (valsub is string sval) {
          ischanged = true;
          intval += Int32.Parse(sval);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_int work = new Vx.Core.Class_int();
        work.vxint = intval;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_int;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_int;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "int", // name
        "", // extends
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_int e_int = new Vx.Core.Class_int();
  public static Vx.Core.Type_int t_int = new Vx.Core.Class_int();

  /**
   * type: intlist
   * A list of int.
   * (type intlist)
   */
  public interface Type_intlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_int> vx_listint();
    public Vx.Core.Type_int vx_int(Vx.Core.Type_int index);
  }

  public class Class_intlist : Vx.Core.Class_base, Type_intlist {

    public List<Vx.Core.Type_int> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_int>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_int vx_int(Vx.Core.Type_int index) {
      Vx.Core.Type_int output = Vx.Core.e_int;
      Vx.Core.Class_intlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_int> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_int> vx_listint() {
      List<Vx.Core.Type_int> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_int output = this.vx_int(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_intlist output = Vx.Core.vx_copy(Vx.Core.e_intlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_intlist output = this;
      bool ischanged = false;
      Vx.Core.Class_intlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_int> listval = new List<Vx.Core.Type_int>(value.vx_listint());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_int allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is int) {
          ischanged = true;
          listval.Add(Vx.Core.vx_new(Vx.Core.t_int, valsub));
        } else if (valsub is Vx.Core.Type_intlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listint());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_int valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/intlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/intlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_intlist work = new Vx.Core.Class_intlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_intlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_intlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "intlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_intlist e_intlist = new Vx.Core.Class_intlist();
  public static Vx.Core.Type_intlist t_intlist = new Vx.Core.Class_intlist();

  /**
   * type: intmap
   * A map of int.
   * (type intmap)
   */
  public interface Type_intmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_int> vx_mapint();
    public Vx.Core.Type_int vx_int(Vx.Core.Type_string key);
  }

  public class Class_intmap : Vx.Core.Class_base, Type_intmap {

    public Vx.Core.Map<string, Vx.Core.Type_int> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_int>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_int>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_int castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_int> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_int>(this.vx_p_map);
        if (castval == Vx.Core.e_int) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_int vx_int(Vx.Core.Type_string key) {
      Vx.Core.Type_int output = Vx.Core.e_int;
      Vx.Core.Class_intmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_int> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_int);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_int> vx_mapint() {
      Vx.Core.Map<string, Vx.Core.Type_int> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_int(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_intmap output = new Vx.Core.Class_intmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_int> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_int>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_int castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/intmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_intmap output = Vx.Core.vx_copy(Vx.Core.e_intmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_intmap output = this;
      bool ischanged = false;
      Vx.Core.Class_intmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_int> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_int>(value.vx_mapint());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/intmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_int valany = Vx.Core.e_int;
          if (false) {
          } else if (valsub is Vx.Core.Type_int valallowed) {
            valany = valallowed;
          } else if (valsub is int) {
            valany = Vx.Core.vx_new(Vx.Core.t_int, valsub);
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/intmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_intmap work = new Vx.Core.Class_intmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_intmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_intmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "intmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_intmap e_intmap = new Vx.Core.Class_intmap();
  public static Vx.Core.Type_intmap t_intmap = new Vx.Core.Class_intmap();

  /**
   * type: list
   * A simple untyped list.
   * (type list)
   */
  public interface Type_list : Vx.Core.Type_any {
    public List<Vx.Core.Type_any> vx_list();
    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index);
  }

  public class Class_list : Vx.Core.Class_base, Type_list {

    public List<Vx.Core.Type_any> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_any>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_list list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_list output = Vx.Core.vx_copy(Vx.Core.e_list, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_list output = this;
      bool ischanged = false;
      Vx.Core.Class_list value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_any> listval = new List<Vx.Core.Type_any>(value.vx_list());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_any allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_list multi) {
          ischanged = true;
          listval.AddRange(multi.vx_list());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_any valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/list", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/list", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_list work = new Vx.Core.Class_list();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "list", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_list e_list = new Vx.Core.Class_list();
  public static Vx.Core.Type_list t_list = new Vx.Core.Class_list();

  /**
   * type: listtype
   * A generic type that extends :list.
   * (type listtype)
   */
  public interface Type_listtype : Vx.Core.Type_any {
  }

  public class Class_listtype : Vx.Core.Class_base, Type_listtype {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_listtype output = Vx.Core.vx_copy(Vx.Core.e_listtype, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_listtype output = this;
      bool ischanged = false;
      Vx.Core.Class_listtype value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_listtype work = new Vx.Core.Class_listtype();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_listtype;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_listtype;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "listtype", // name
        ":type", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_listtype e_listtype = new Vx.Core.Class_listtype();
  public static Vx.Core.Type_listtype t_listtype = new Vx.Core.Class_listtype();

  /**
   * type: locale
   * Localization data.
   * (type locale)
   */
  public interface Type_locale : Vx.Core.Type_struct {
  }

  public class Class_locale : Vx.Core.Class_base, Type_locale {

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_locale output = Vx.Core.vx_copy(Vx.Core.e_locale, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_locale output = this;
      bool ischanged = false;
      Vx.Core.Class_locale value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_locale work = new Vx.Core.Class_locale();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_locale;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_locale;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "locale", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_locale e_locale = new Vx.Core.Class_locale();
  public static Vx.Core.Type_locale t_locale = new Vx.Core.Class_locale();

  /**
   * type: map
   * A simple untyped map.
   * (type map)
   */
  public interface Type_map : Vx.Core.Type_any {
    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval);
    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key);
    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map();
    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value);
  }

  public class Class_map : Vx.Core.Class_base, Type_map {

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = this.vx_p_map;
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_any castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(this.vx_p_map);
        if (castval == Vx.Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_map map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_any);
      return output;
    }

    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_map output = new Vx.Core.Class_map();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_any castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/map", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_map output = Vx.Core.vx_copy(Vx.Core.e_map, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_map output = this;
      bool ischanged = false;
      Vx.Core.Class_map value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(value.vx_map());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/map", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_any valany = Vx.Core.e_any;
          if (false) {
          } else if (valsub is Vx.Core.Type_any valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_any) {
            valany = (Vx.Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/map", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_map work = new Vx.Core.Class_map();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_map;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_map;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "map", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_map e_map = new Vx.Core.Class_map();
  public static Vx.Core.Type_map t_map = new Vx.Core.Class_map();

  /**
   * type: maptype
   * A generic type that extends :map.
   * (type maptype)
   */
  public interface Type_maptype : Vx.Core.Type_any {
  }

  public class Class_maptype : Vx.Core.Class_base, Type_maptype {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_maptype output = Vx.Core.vx_copy(Vx.Core.e_maptype, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_maptype output = this;
      bool ischanged = false;
      Vx.Core.Class_maptype value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_maptype work = new Vx.Core.Class_maptype();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_maptype;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_maptype;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "maptype", // name
        ":type", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_maptype e_maptype = new Vx.Core.Class_maptype();
  public static Vx.Core.Type_maptype t_maptype = new Vx.Core.Class_maptype();

  /**
   * type: mempool
   * Memory Pool
   * (type mempool)
   */
  public interface Type_mempool : Vx.Core.Type_struct {
    public Vx.Core.Type_value valuepool();
  }

  public class Class_mempool : Vx.Core.Class_base, Type_mempool {

    public Vx.Core.Type_value? vx_p_valuepool = null;

    public Vx.Core.Type_value valuepool() {
      Vx.Core.Type_value output = Vx.Core.e_value;
      Vx.Core.Type_value? testnull = vx_p_valuepool;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":valuepool")) {
        output = this.valuepool();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":valuepool", this.valuepool());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_mempool output = Vx.Core.vx_copy(Vx.Core.e_mempool, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_mempool output = this;
      bool ischanged = false;
      Vx.Core.Class_mempool value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_value vx_p_valuepool = value.valuepool();
      List<string> validkeys = new List<string>();
      validkeys.Add(":valuepool");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/mempool", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":valuepool")) {
            if (valsub == vx_p_valuepool) {
            } else if (valsub is Vx.Core.Type_value valvaluepool) {
              ischanged = true;
              vx_p_valuepool = valvaluepool;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("valuepool"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/mempool", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_mempool work = new Vx.Core.Class_mempool();
        work.vx_p_valuepool = vx_p_valuepool;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_mempool;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_mempool;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "mempool", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_mempool e_mempool = new Vx.Core.Class_mempool();
  public static Vx.Core.Type_mempool t_mempool = new Vx.Core.Class_mempool();

  /**
   * type: msg
   * Message Type for error handling
   * (type msg)
   */
  public interface Type_msg : Vx.Core.Type_struct {
    public Vx.Core.Type_string code();
    public Vx.Core.Type_any detail();
    public Vx.Core.Type_string path();
    public Vx.Core.Type_int severity();
    public Vx.Core.Type_string text();
  }

  public class Class_msg : Vx.Core.Class_base, Type_msg {

    public Exception? err = null;

    public Vx.Core.Type_string? vx_p_code = null;

    public Vx.Core.Type_string code() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_code;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any? vx_p_detail = null;

    public Vx.Core.Type_any detail() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_detail;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_path = null;

    public Vx.Core.Type_string path() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_path;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_int? vx_p_severity = null;

    public Vx.Core.Type_int severity() {
      Vx.Core.Type_int output = Vx.Core.e_int;
      Vx.Core.Type_int? testnull = vx_p_severity;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_text = null;

    public Vx.Core.Type_string text() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_text;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":code")) {
        output = this.code();
      } else if ((skey==":detail")) {
        output = this.detail();
      } else if ((skey==":path")) {
        output = this.path();
      } else if ((skey==":severity")) {
        output = this.severity();
      } else if ((skey==":text")) {
        output = this.text();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":code", this.code());
      map.put(":detail", this.detail());
      map.put(":path", this.path());
      map.put(":severity", this.severity());
      map.put(":text", this.text());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_msg output = Vx.Core.vx_copy(Vx.Core.e_msg, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_msg output = this;
      bool ischanged = false;
      Vx.Core.Class_msg value = this;
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_code = value.code();
      Vx.Core.Type_any vx_p_detail = value.detail();
      Vx.Core.Type_string vx_p_path = value.path();
      Vx.Core.Type_int vx_p_severity = value.severity();
      Vx.Core.Type_string vx_p_text = value.text();
      string key = "";
      foreach (object valsub in vals) {
        if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            key = valstr.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          }
        } else {
          if (false) {
          } else if ((key==":code")) {
            if (valsub == vx_p_code) {
            } else if (valsub is Vx.Core.Type_string valcode) {
              ischanged = true;
              vx_p_code = valcode;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_code = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            }
          } else if ((key==":detail")) {
            if (valsub == vx_p_detail) {
            } else if (valsub is Vx.Core.Type_any valdetail) {
              ischanged = true;
              vx_p_detail = valdetail;
            }
          } else if ((key==":path")) {
            if (valsub == vx_p_path) {
            } else if (valsub is Vx.Core.Type_string valpath) {
              ischanged = true;
              vx_p_path = valpath;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_path = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            }
          } else if ((key==":severity")) {
            if (valsub == vx_p_severity) {
            } else if (valsub is Vx.Core.Type_int valseverity) {
              ischanged = true;
              vx_p_severity = valseverity;
            } else if (valsub is int) {
              ischanged = true;
              vx_p_severity = Vx.Core.vx_new(Vx.Core.t_int, valsub);
            }
          } else if ((key==":text")) {
            if (valsub == vx_p_text) {
            } else if (valsub is Vx.Core.Type_string valtext) {
              ischanged = true;
              vx_p_text = valtext;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_text = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            }
          }
          key = "";
        }
      }
      if (ischanged) {
        Vx.Core.Class_msg work = new Vx.Core.Class_msg();
        work.vx_p_code = vx_p_code;
        work.vx_p_detail = vx_p_detail;
        work.vx_p_path = vx_p_path;
        work.vx_p_severity = vx_p_severity;
        work.vx_p_text = vx_p_text;
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msg;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msg;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "msg", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_msg e_msg = new Vx.Core.Class_msg();
  public static Vx.Core.Type_msg t_msg = new Vx.Core.Class_msg();

  /**
   * type: msgblock
   * Block of Messages
   * (type msgblock)
   */
  public interface Type_msgblock : Vx.Core.Type_struct {
    public Vx.Core.Type_msglist msgs();
    public Vx.Core.Type_msgblocklist msgblocks();
  }

  public class Class_msgblock : Vx.Core.Class_base, Type_msgblock {

    public Vx.Core.Type_msglist? vx_p_msgs = null;

    public Vx.Core.Type_msglist msgs() {
      Vx.Core.Type_msglist output = Vx.Core.e_msglist;
      Vx.Core.Type_msglist? testnull = vx_p_msgs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_msgblocklist? vx_p_msgblocks = null;

    public Vx.Core.Type_msgblocklist msgblocks() {
      Vx.Core.Type_msgblocklist output = Vx.Core.e_msgblocklist;
      Vx.Core.Type_msgblocklist? testnull = vx_p_msgblocks;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":msgs")) {
        output = this.msgs();
      } else if ((skey==":msgblocks")) {
        output = this.msgblocks();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":msgs", this.msgs());
      map.put(":msgblocks", this.msgblocks());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_msgblock output = Vx.Core.vx_copy(Vx.Core.e_msgblock, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_msgblock output = this;
      bool ischanged = false;
      Vx.Core.Class_msgblock value = this;
      Vx.Core.Type_msgblock msgblock = this;
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_msglist vx_p_msgs = value.msgs();
      Vx.Core.Type_msgblocklist vx_p_msgblocks = value.msgblocks();
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          if (valsub != Vx.Core.e_msgblock) {
            vx_p_msgblocks = Vx.Core.vx_copy(vx_p_msgblocks, valsub);
            ischanged = true;
          }
        } else if (valsub is Vx.Core.Type_msgblocklist) {
          if (valsub != Vx.Core.e_msgblocklist) {
            vx_p_msgblocks = Vx.Core.vx_copy(vx_p_msgblocks, valsub);
            ischanged = true;
          }
        } else if (valsub is Vx.Core.Type_msg) {
          if (valsub != Vx.Core.e_msg) {
            vx_p_msgs = Vx.Core.vx_copy(vx_p_msgs, valsub);
            ischanged = true;
          }
        } else if (valsub is Vx.Core.Type_msglist) {
          if (valsub != Vx.Core.e_msglist) {
            vx_p_msgs = Vx.Core.vx_copy(vx_p_msgs, valsub);
            ischanged = true;
          }
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            key = valstr.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          }
        } else {
          if (false) {
          } else if ((key==":msgs")) {
            if (valsub == vx_p_msgs) {
            } else if (valsub is Vx.Core.Type_msglist valmsgs) {
              ischanged = true;
              vx_p_msgs = valmsgs;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("msgs"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":msgblocks")) {
            if (valsub == vx_p_msgblocks) {
            } else if (valsub is Vx.Core.Type_msgblocklist valmsgblocks) {
              ischanged = true;
              vx_p_msgblocks = valmsgblocks;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("msgblocks"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
          key = "";
        }
      }
      if (ischanged) {
        if ((vx_p_msgs.vx_list().Count == 0) && (vx_p_msgblocks.vx_list().Count == 1)) {
          output = vx_p_msgblocks.vx_listmsgblock()[0];
        } else {
          Vx.Core.Class_msgblock work = new Vx.Core.Class_msgblock();
          work.vx_p_msgs = vx_p_msgs;
          work.vx_p_msgblocks = vx_p_msgblocks;
          output = work;
        }
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msgblock;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msgblock;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "msgblock", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_msgblock e_msgblock = new Vx.Core.Class_msgblock();
  public static Vx.Core.Type_msgblock t_msgblock = new Vx.Core.Class_msgblock();

  /**
   * type: msgblocklist
   * List of Message Blocks
   * (type msgblocklist)
   */
  public interface Type_msgblocklist : Vx.Core.Type_list {
    public List<Vx.Core.Type_msgblock> vx_listmsgblock();
    public Vx.Core.Type_msgblock vx_msgblock(Vx.Core.Type_int index);
  }

  public class Class_msgblocklist : Vx.Core.Class_base, Type_msgblocklist {

    public List<Vx.Core.Type_msgblock> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_msgblock>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_msgblock vx_msgblock(Vx.Core.Type_int index) {
      Vx.Core.Type_msgblock output = Vx.Core.e_msgblock;
      Vx.Core.Class_msgblocklist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_msgblock> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_msgblock> vx_listmsgblock() {
      List<Vx.Core.Type_msgblock> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_msgblock output = this.vx_msgblock(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_msgblocklist output = Vx.Core.vx_copy(Vx.Core.e_msgblocklist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_msgblocklist output = this;
      bool ischanged = false;
      Vx.Core.Class_msgblocklist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_msgblock> listval = new List<Vx.Core.Type_msgblock>(value.vx_listmsgblock());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msgblock) {
          ischanged = true;
          listval.Add((Vx.Core.Type_msgblock)valsub);
        } else if (valsub is Vx.Core.Type_msgblocklist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listmsgblock());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_msgblock valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_msgblocklist work = new Vx.Core.Class_msgblocklist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msgblocklist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msgblocklist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "msgblocklist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_msgblock), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_msgblocklist e_msgblocklist = new Vx.Core.Class_msgblocklist();
  public static Vx.Core.Type_msgblocklist t_msgblocklist = new Vx.Core.Class_msgblocklist();

  /**
   * type: msglist
   * List of Messages
   * (type msglist)
   */
  public interface Type_msglist : Vx.Core.Type_list {
    public List<Vx.Core.Type_msg> vx_listmsg();
    public Vx.Core.Type_msg vx_msg(Vx.Core.Type_int index);
  }

  public class Class_msglist : Vx.Core.Class_base, Type_msglist {

    public List<Vx.Core.Type_msg> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_msg>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_msg vx_msg(Vx.Core.Type_int index) {
      Vx.Core.Type_msg output = Vx.Core.e_msg;
      Vx.Core.Class_msglist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_msg> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_msg> vx_listmsg() {
      List<Vx.Core.Type_msg> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_msg output = this.vx_msg(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_msglist output = Vx.Core.vx_copy(Vx.Core.e_msglist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_msglist output = this;
      bool ischanged = false;
      Vx.Core.Class_msglist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_msg> listval = new List<Vx.Core.Type_msg>(value.vx_listmsg());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          ischanged = true;
          listval.Add((Vx.Core.Type_msg)valsub);
        } else if (valsub is Vx.Core.Type_msglist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listmsg());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_msg valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/msglist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/msglist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_msglist work = new Vx.Core.Class_msglist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msglist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msglist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "msglist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_msg), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_msglist e_msglist = new Vx.Core.Class_msglist();
  public static Vx.Core.Type_msglist t_msglist = new Vx.Core.Class_msglist();

  /**
   * type: none
   * No Type. No type is returned at all. e.g. Void
   * (type none)
   */
  public interface Type_none : Vx.Core.Type_any {
  }

  public class Class_none : Vx.Core.Class_base, Type_none {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_none output = Vx.Core.vx_copy(Vx.Core.e_none, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_none output = this;
      bool ischanged = false;
      Vx.Core.Class_none value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_none work = new Vx.Core.Class_none();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_none;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_none;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "none", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_none e_none = new Vx.Core.Class_none();
  public static Vx.Core.Type_none t_none = new Vx.Core.Class_none();

  /**
   * type: notype
   * No Type that allows no Types as a Value
   * (type notype)
   */
  public interface Type_notype : Vx.Core.Type_any {
  }

  public class Class_notype : Vx.Core.Class_base, Type_notype {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_notype output = Vx.Core.vx_copy(Vx.Core.e_notype, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_notype output = this;
      bool ischanged = false;
      Vx.Core.Class_notype value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_notype work = new Vx.Core.Class_notype();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_notype;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_notype;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "notype", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_notype e_notype = new Vx.Core.Class_notype();
  public static Vx.Core.Type_notype t_notype = new Vx.Core.Class_notype();

  /**
   * type: number
   * A generic number that could be int, float, or decimal.
   * (type number)
   */
  public interface Type_number : Vx.Core.Type_any {
  }

  public class Class_number : Vx.Core.Class_base, Type_number {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_number output = Vx.Core.vx_copy(Vx.Core.e_number, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_number output = this;
      bool ischanged = false;
      Vx.Core.Class_number value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_number work = new Vx.Core.Class_number();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_number;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_number;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "number", // name
        "", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_number e_number = new Vx.Core.Class_number();
  public static Vx.Core.Type_number t_number = new Vx.Core.Class_number();

  /**
   * type: numberlist
   * A list of number.
   * (type numberlist)
   */
  public interface Type_numberlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_number> vx_listnumber();
    public Vx.Core.Type_number vx_number(Vx.Core.Type_int index);
  }

  public class Class_numberlist : Vx.Core.Class_base, Type_numberlist {

    public List<Vx.Core.Type_number> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_number>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_number vx_number(Vx.Core.Type_int index) {
      Vx.Core.Type_number output = Vx.Core.e_number;
      Vx.Core.Class_numberlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_number> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_number> vx_listnumber() {
      List<Vx.Core.Type_number> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_number output = this.vx_number(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_numberlist output = Vx.Core.vx_copy(Vx.Core.e_numberlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_numberlist output = this;
      bool ischanged = false;
      Vx.Core.Class_numberlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_number> listval = new List<Vx.Core.Type_number>(value.vx_listnumber());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_number allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_number) {
          ischanged = true;
          listval.Add((Vx.Core.Type_number)valsub);
        } else if (valsub is Vx.Core.Type_numberlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listnumber());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_number valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_numberlist work = new Vx.Core.Class_numberlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_numberlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_numberlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "numberlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_numberlist e_numberlist = new Vx.Core.Class_numberlist();
  public static Vx.Core.Type_numberlist t_numberlist = new Vx.Core.Class_numberlist();

  /**
   * type: numbermap
   * A map of number.
   * (type numbermap)
   */
  public interface Type_numbermap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_number> vx_mapnumber();
    public Vx.Core.Type_number vx_number(Vx.Core.Type_string key);
  }

  public class Class_numbermap : Vx.Core.Class_base, Type_numbermap {

    public Vx.Core.Map<string, Vx.Core.Type_number> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_number>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_number>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_number castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_number> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_number>(this.vx_p_map);
        if (castval == Vx.Core.e_number) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_number vx_number(Vx.Core.Type_string key) {
      Vx.Core.Type_number output = Vx.Core.e_number;
      Vx.Core.Class_numbermap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_number> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_number);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_number> vx_mapnumber() {
      Vx.Core.Map<string, Vx.Core.Type_number> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_number(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_numbermap output = new Vx.Core.Class_numbermap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_number> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_number>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_number castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/numbermap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_numbermap output = Vx.Core.vx_copy(Vx.Core.e_numbermap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_numbermap output = this;
      bool ischanged = false;
      Vx.Core.Class_numbermap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_number> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_number>(value.vx_mapnumber());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/numbermap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_number valany = Vx.Core.e_number;
          if (false) {
          } else if (valsub is Vx.Core.Type_number valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_number) {
            valany = (Vx.Core.Type_number)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/numbermap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_numbermap work = new Vx.Core.Class_numbermap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_numbermap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_numbermap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "numbermap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_numbermap e_numbermap = new Vx.Core.Class_numbermap();
  public static Vx.Core.Type_numbermap t_numbermap = new Vx.Core.Class_numbermap();

  /**
   * type: package
   * A package that store types, consts and funcs.
   * (type package)
   */
  public interface Type_package : Vx.Core.Type_struct {
    public Vx.Core.Type_string pkgname();
    public Vx.Core.Type_constmap constmap();
    public Vx.Core.Type_funcmap funcmap();
    public Vx.Core.Type_typemap typemap();
    public Vx.Core.Type_map emptymap();
  }

  public class Class_package : Vx.Core.Class_base, Type_package {

    public Vx.Core.Type_string? vx_p_pkgname = null;

    public Vx.Core.Type_string pkgname() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_constmap? vx_p_constmap = null;

    public Vx.Core.Type_constmap constmap() {
      Vx.Core.Type_constmap output = Vx.Core.e_constmap;
      Vx.Core.Type_constmap? testnull = vx_p_constmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_funcmap? vx_p_funcmap = null;

    public Vx.Core.Type_funcmap funcmap() {
      Vx.Core.Type_funcmap output = Vx.Core.e_funcmap;
      Vx.Core.Type_funcmap? testnull = vx_p_funcmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_typemap? vx_p_typemap = null;

    public Vx.Core.Type_typemap typemap() {
      Vx.Core.Type_typemap output = Vx.Core.e_typemap;
      Vx.Core.Type_typemap? testnull = vx_p_typemap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_map? vx_p_emptymap = null;

    public Vx.Core.Type_map emptymap() {
      Vx.Core.Type_map output = Vx.Core.e_map;
      Vx.Core.Type_map? testnull = vx_p_emptymap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname();
      } else if ((skey==":constmap")) {
        output = this.constmap();
      } else if ((skey==":funcmap")) {
        output = this.funcmap();
      } else if ((skey==":typemap")) {
        output = this.typemap();
      } else if ((skey==":emptymap")) {
        output = this.emptymap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":constmap", this.constmap());
      map.put(":funcmap", this.funcmap());
      map.put(":typemap", this.typemap());
      map.put(":emptymap", this.emptymap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_package output = Vx.Core.vx_copy(Vx.Core.e_package, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_package output = this;
      bool ischanged = false;
      Vx.Core.Class_package value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_pkgname = value.pkgname();
      Vx.Core.Type_constmap vx_p_constmap = value.constmap();
      Vx.Core.Type_funcmap vx_p_funcmap = value.funcmap();
      Vx.Core.Type_typemap vx_p_typemap = value.typemap();
      Vx.Core.Type_map vx_p_emptymap = value.emptymap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":pkgname");
      validkeys.Add(":constmap");
      validkeys.Add(":funcmap");
      validkeys.Add(":typemap");
      validkeys.Add(":emptymap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is Vx.Core.Type_string valpkgname) {
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_pkgname = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":constmap")) {
            if (valsub == vx_p_constmap) {
            } else if (valsub is Vx.Core.Type_constmap valconstmap) {
              ischanged = true;
              vx_p_constmap = valconstmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("constmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":funcmap")) {
            if (valsub == vx_p_funcmap) {
            } else if (valsub is Vx.Core.Type_funcmap valfuncmap) {
              ischanged = true;
              vx_p_funcmap = valfuncmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("funcmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":typemap")) {
            if (valsub == vx_p_typemap) {
            } else if (valsub is Vx.Core.Type_typemap valtypemap) {
              ischanged = true;
              vx_p_typemap = valtypemap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("typemap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":emptymap")) {
            if (valsub == vx_p_emptymap) {
            } else if (valsub is Vx.Core.Type_map valemptymap) {
              ischanged = true;
              vx_p_emptymap = valemptymap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("emptymap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_package work = new Vx.Core.Class_package();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_constmap = vx_p_constmap;
        work.vx_p_funcmap = vx_p_funcmap;
        work.vx_p_typemap = vx_p_typemap;
        work.vx_p_emptymap = vx_p_emptymap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_package;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_package;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "package", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_package e_package = new Vx.Core.Class_package();
  public static Vx.Core.Type_package t_package = new Vx.Core.Class_package();

  /**
   * type: packagemap
   * (type packagemap)
   */
  public interface Type_packagemap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_package> vx_mappackage();
    public Vx.Core.Type_package vx_package(Vx.Core.Type_string key);
  }

  public class Class_packagemap : Vx.Core.Class_base, Type_packagemap {

    public Vx.Core.Map<string, Vx.Core.Type_package> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_package>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_package>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_package castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_package> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_package>(this.vx_p_map);
        if (castval == Vx.Core.e_package) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_package vx_package(Vx.Core.Type_string key) {
      Vx.Core.Type_package output = Vx.Core.e_package;
      Vx.Core.Class_packagemap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_package> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_package);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_package> vx_mappackage() {
      Vx.Core.Map<string, Vx.Core.Type_package> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_package(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_packagemap output = new Vx.Core.Class_packagemap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_package> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_package>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_package castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/packagemap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_packagemap output = Vx.Core.vx_copy(Vx.Core.e_packagemap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_packagemap output = this;
      bool ischanged = false;
      Vx.Core.Class_packagemap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_package> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_package>(value.vx_mappackage());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/packagemap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_package valany = Vx.Core.e_package;
          if (false) {
          } else if (valsub is Vx.Core.Type_package valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_package) {
            valany = (Vx.Core.Type_package)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/packagemap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_packagemap work = new Vx.Core.Class_packagemap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_packagemap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_packagemap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "packagemap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_package), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_packagemap e_packagemap = new Vx.Core.Class_packagemap();
  public static Vx.Core.Type_packagemap t_packagemap = new Vx.Core.Class_packagemap();

  /**
   * type: permission
   * Permission
   * (type permission)
   */
  public interface Type_permission : Vx.Core.Type_struct {
    public Vx.Core.Type_string id();
  }

  public class Class_permission : Vx.Core.Class_base, Type_permission {

    public Vx.Core.Type_string? vx_p_id = null;

    public Vx.Core.Type_string id() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_id;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":id")) {
        output = this.id();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":id", this.id());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_permission output = Vx.Core.vx_copy(Vx.Core.e_permission, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_permission output = this;
      bool ischanged = false;
      Vx.Core.Class_permission value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_id = value.id();
      List<string> validkeys = new List<string>();
      validkeys.Add(":id");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/permission", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":id")) {
            if (valsub == vx_p_id) {
            } else if (valsub is Vx.Core.Type_string valid) {
              ischanged = true;
              vx_p_id = valid;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_id = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("id"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/permission", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_permission work = new Vx.Core.Class_permission();
        work.vx_p_id = vx_p_id;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_permission;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_permission;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "permission", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_permission e_permission = new Vx.Core.Class_permission();
  public static Vx.Core.Type_permission t_permission = new Vx.Core.Class_permission();

  /**
   * type: permissionlist
   * List of Permission
   * (type permissionlist)
   */
  public interface Type_permissionlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_permission> vx_listpermission();
    public Vx.Core.Type_permission vx_permission(Vx.Core.Type_int index);
  }

  public class Class_permissionlist : Vx.Core.Class_base, Type_permissionlist {

    public List<Vx.Core.Type_permission> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_permission>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_permission vx_permission(Vx.Core.Type_int index) {
      Vx.Core.Type_permission output = Vx.Core.e_permission;
      Vx.Core.Class_permissionlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_permission> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_permission> vx_listpermission() {
      List<Vx.Core.Type_permission> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_permission output = this.vx_permission(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_permissionlist output = Vx.Core.vx_copy(Vx.Core.e_permissionlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_permissionlist output = this;
      bool ischanged = false;
      Vx.Core.Class_permissionlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_permission> listval = new List<Vx.Core.Type_permission>(value.vx_listpermission());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_permission allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_permission) {
          ischanged = true;
          listval.Add((Vx.Core.Type_permission)valsub);
        } else if (valsub is Vx.Core.Type_permissionlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listpermission());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_permission valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_permissionlist work = new Vx.Core.Class_permissionlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_permissionlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_permissionlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "permissionlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_permission), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_permissionlist e_permissionlist = new Vx.Core.Class_permissionlist();
  public static Vx.Core.Type_permissionlist t_permissionlist = new Vx.Core.Class_permissionlist();

  /**
   * type: permissionmap
   * Map of Permission
   * (type permissionmap)
   */
  public interface Type_permissionmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_permission> vx_mappermission();
    public Vx.Core.Type_permission vx_permission(Vx.Core.Type_string key);
  }

  public class Class_permissionmap : Vx.Core.Class_base, Type_permissionmap {

    public Vx.Core.Map<string, Vx.Core.Type_permission> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_permission>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_permission>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_permission castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_permission> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_permission>(this.vx_p_map);
        if (castval == Vx.Core.e_permission) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_permission vx_permission(Vx.Core.Type_string key) {
      Vx.Core.Type_permission output = Vx.Core.e_permission;
      Vx.Core.Class_permissionmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_permission> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_permission);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_permission> vx_mappermission() {
      Vx.Core.Map<string, Vx.Core.Type_permission> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_permission(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_permissionmap output = new Vx.Core.Class_permissionmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_permission> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_permission>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_permission castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/permissionmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_permissionmap output = Vx.Core.vx_copy(Vx.Core.e_permissionmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_permissionmap output = this;
      bool ischanged = false;
      Vx.Core.Class_permissionmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_permission> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_permission>(value.vx_mappermission());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/permissionmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_permission valany = Vx.Core.e_permission;
          if (false) {
          } else if (valsub is Vx.Core.Type_permission valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_permission) {
            valany = (Vx.Core.Type_permission)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/permissionmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_permissionmap work = new Vx.Core.Class_permissionmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_permissionmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_permissionmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "permissionmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_permission), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_permissionmap e_permissionmap = new Vx.Core.Class_permissionmap();
  public static Vx.Core.Type_permissionmap t_permissionmap = new Vx.Core.Class_permissionmap();

  /**
   * type: project
   * A project.
   * (type project)
   */
  public interface Type_project : Vx.Core.Type_struct {
    public Vx.Core.Type_packagemap packagemap();
  }

  public class Class_project : Vx.Core.Class_base, Type_project {

    public Vx.Core.Type_packagemap? vx_p_packagemap = null;

    public Vx.Core.Type_packagemap packagemap() {
      Vx.Core.Type_packagemap output = Vx.Core.e_packagemap;
      Vx.Core.Type_packagemap? testnull = vx_p_packagemap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":packagemap")) {
        output = this.packagemap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":packagemap", this.packagemap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_project output = Vx.Core.vx_copy(Vx.Core.e_project, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_project output = this;
      bool ischanged = false;
      Vx.Core.Class_project value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_packagemap vx_p_packagemap = value.packagemap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":packagemap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/project", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":packagemap")) {
            if (valsub == vx_p_packagemap) {
            } else if (valsub is Vx.Core.Type_packagemap valpackagemap) {
              ischanged = true;
              vx_p_packagemap = valpackagemap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("packagemap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/project", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_project work = new Vx.Core.Class_project();
        work.vx_p_packagemap = vx_p_packagemap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_project;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_project;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "project", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_project e_project = new Vx.Core.Class_project();
  public static Vx.Core.Type_project t_project = new Vx.Core.Class_project();

  /**
   * type: security
   * Security rules
   * (type security)
   */
  public interface Type_security : Vx.Core.Type_struct {
    public Vx.Core.Type_funclist allowfuncs();
    public Vx.Core.Type_permissionlist permissions();
    public Vx.Core.Type_permissionmap permissionmap();
  }

  public class Class_security : Vx.Core.Class_base, Type_security {

    public Vx.Core.Type_funclist? vx_p_allowfuncs = null;

    public Vx.Core.Type_funclist allowfuncs() {
      Vx.Core.Type_funclist output = Vx.Core.e_funclist;
      Vx.Core.Type_funclist? testnull = vx_p_allowfuncs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_permissionlist? vx_p_permissions = null;

    public Vx.Core.Type_permissionlist permissions() {
      Vx.Core.Type_permissionlist output = Vx.Core.e_permissionlist;
      Vx.Core.Type_permissionlist? testnull = vx_p_permissions;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_permissionmap? vx_p_permissionmap = null;

    public Vx.Core.Type_permissionmap permissionmap() {
      Vx.Core.Type_permissionmap output = Vx.Core.e_permissionmap;
      Vx.Core.Type_permissionmap? testnull = vx_p_permissionmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":allowfuncs")) {
        output = this.allowfuncs();
      } else if ((skey==":permissions")) {
        output = this.permissions();
      } else if ((skey==":permissionmap")) {
        output = this.permissionmap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":allowfuncs", this.allowfuncs());
      map.put(":permissions", this.permissions());
      map.put(":permissionmap", this.permissionmap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_security output = Vx.Core.vx_copy(Vx.Core.e_security, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_security output = this;
      bool ischanged = false;
      Vx.Core.Class_security value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_funclist vx_p_allowfuncs = value.allowfuncs();
      Vx.Core.Type_permissionlist vx_p_permissions = value.permissions();
      Vx.Core.Type_permissionmap vx_p_permissionmap = value.permissionmap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":allowfuncs");
      validkeys.Add(":permissions");
      validkeys.Add(":permissionmap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/security", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":allowfuncs")) {
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub is Vx.Core.Type_funclist valallowfuncs) {
              ischanged = true;
              vx_p_allowfuncs = valallowfuncs;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("allowfuncs"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":permissions")) {
            if (valsub == vx_p_permissions) {
            } else if (valsub is Vx.Core.Type_permissionlist valpermissions) {
              ischanged = true;
              vx_p_permissions = valpermissions;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("permissions"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":permissionmap")) {
            if (valsub == vx_p_permissionmap) {
            } else if (valsub is Vx.Core.Type_permissionmap valpermissionmap) {
              ischanged = true;
              vx_p_permissionmap = valpermissionmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("permissionmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_security work = new Vx.Core.Class_security();
        work.vx_p_allowfuncs = vx_p_allowfuncs;
        work.vx_p_permissions = vx_p_permissions;
        work.vx_p_permissionmap = vx_p_permissionmap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_security;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_security;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "security", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_security e_security = new Vx.Core.Class_security();
  public static Vx.Core.Type_security t_security = new Vx.Core.Class_security();

  /**
   * type: session
   * Session
   * (type session)
   */
  public interface Type_session : Vx.Core.Type_struct {
    public Vx.Core.Type_user user();
    public Vx.Core.Type_connectlist connectlist();
    public Vx.Core.Type_connectmap connectmap();
    public Vx.Core.Type_locale locale();
    public Vx.Core.Type_translation translation();
    public Vx.Core.Type_translationmap translationmap();
  }

  public class Class_session : Vx.Core.Class_base, Type_session {

    public Vx.Core.Type_user? vx_p_user = null;

    public Vx.Core.Type_user user() {
      Vx.Core.Type_user output = Vx.Core.e_user;
      Vx.Core.Type_user? testnull = vx_p_user;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_connectlist? vx_p_connectlist = null;

    public Vx.Core.Type_connectlist connectlist() {
      Vx.Core.Type_connectlist output = Vx.Core.e_connectlist;
      Vx.Core.Type_connectlist? testnull = vx_p_connectlist;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_connectmap? vx_p_connectmap = null;

    public Vx.Core.Type_connectmap connectmap() {
      Vx.Core.Type_connectmap output = Vx.Core.e_connectmap;
      Vx.Core.Type_connectmap? testnull = vx_p_connectmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_locale? vx_p_locale = null;

    public Vx.Core.Type_locale locale() {
      Vx.Core.Type_locale output = Vx.Core.e_locale;
      Vx.Core.Type_locale? testnull = vx_p_locale;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_translation? vx_p_translation = null;

    public Vx.Core.Type_translation translation() {
      Vx.Core.Type_translation output = Vx.Core.e_translation;
      Vx.Core.Type_translation? testnull = vx_p_translation;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_translationmap? vx_p_translationmap = null;

    public Vx.Core.Type_translationmap translationmap() {
      Vx.Core.Type_translationmap output = Vx.Core.e_translationmap;
      Vx.Core.Type_translationmap? testnull = vx_p_translationmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":user")) {
        output = this.user();
      } else if ((skey==":connectlist")) {
        output = this.connectlist();
      } else if ((skey==":connectmap")) {
        output = this.connectmap();
      } else if ((skey==":locale")) {
        output = this.locale();
      } else if ((skey==":translation")) {
        output = this.translation();
      } else if ((skey==":translationmap")) {
        output = this.translationmap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":user", this.user());
      map.put(":connectlist", this.connectlist());
      map.put(":connectmap", this.connectmap());
      map.put(":locale", this.locale());
      map.put(":translation", this.translation());
      map.put(":translationmap", this.translationmap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_session output = Vx.Core.vx_copy(Vx.Core.e_session, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_session output = this;
      bool ischanged = false;
      Vx.Core.Class_session value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_user vx_p_user = value.user();
      Vx.Core.Type_connectlist vx_p_connectlist = value.connectlist();
      Vx.Core.Type_connectmap vx_p_connectmap = value.connectmap();
      Vx.Core.Type_locale vx_p_locale = value.locale();
      Vx.Core.Type_translation vx_p_translation = value.translation();
      Vx.Core.Type_translationmap vx_p_translationmap = value.translationmap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":user");
      validkeys.Add(":connectlist");
      validkeys.Add(":connectmap");
      validkeys.Add(":locale");
      validkeys.Add(":translation");
      validkeys.Add(":translationmap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":user")) {
            if (valsub == vx_p_user) {
            } else if (valsub is Vx.Core.Type_user valuser) {
              ischanged = true;
              vx_p_user = valuser;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("user"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":connectlist")) {
            if (valsub == vx_p_connectlist) {
            } else if (valsub is Vx.Core.Type_connectlist valconnectlist) {
              ischanged = true;
              vx_p_connectlist = valconnectlist;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("connectlist"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":connectmap")) {
            if (valsub == vx_p_connectmap) {
            } else if (valsub is Vx.Core.Type_connectmap valconnectmap) {
              ischanged = true;
              vx_p_connectmap = valconnectmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("connectmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":locale")) {
            if (valsub == vx_p_locale) {
            } else if (valsub is Vx.Core.Type_locale vallocale) {
              ischanged = true;
              vx_p_locale = vallocale;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("locale"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":translation")) {
            if (valsub == vx_p_translation) {
            } else if (valsub is Vx.Core.Type_translation valtranslation) {
              ischanged = true;
              vx_p_translation = valtranslation;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("translation"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":translationmap")) {
            if (valsub == vx_p_translationmap) {
            } else if (valsub is Vx.Core.Type_translationmap valtranslationmap) {
              ischanged = true;
              vx_p_translationmap = valtranslationmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("translationmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_session work = new Vx.Core.Class_session();
        work.vx_p_user = vx_p_user;
        work.vx_p_connectlist = vx_p_connectlist;
        work.vx_p_connectmap = vx_p_connectmap;
        work.vx_p_locale = vx_p_locale;
        work.vx_p_translation = vx_p_translation;
        work.vx_p_translationmap = vx_p_translationmap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_session;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_session;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "session", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_session e_session = new Vx.Core.Class_session();
  public static Vx.Core.Type_session t_session = new Vx.Core.Class_session();

  /**
   * type: setting
   * Settings
   * (type setting)
   */
  public interface Type_setting : Vx.Core.Type_struct {
    public Vx.Core.Type_stringmap pathmap();
  }

  public class Class_setting : Vx.Core.Class_base, Type_setting {

    public Vx.Core.Type_stringmap? vx_p_pathmap = null;

    public Vx.Core.Type_stringmap pathmap() {
      Vx.Core.Type_stringmap output = Vx.Core.e_stringmap;
      Vx.Core.Type_stringmap? testnull = vx_p_pathmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":pathmap")) {
        output = this.pathmap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":pathmap", this.pathmap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_setting output = Vx.Core.vx_copy(Vx.Core.e_setting, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_setting output = this;
      bool ischanged = false;
      Vx.Core.Class_setting value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_stringmap vx_p_pathmap = value.pathmap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":pathmap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/setting", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":pathmap")) {
            if (valsub == vx_p_pathmap) {
            } else if (valsub is Vx.Core.Type_stringmap valpathmap) {
              ischanged = true;
              vx_p_pathmap = valpathmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("pathmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/setting", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_setting work = new Vx.Core.Class_setting();
        work.vx_p_pathmap = vx_p_pathmap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_setting;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_setting;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "setting", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_setting e_setting = new Vx.Core.Class_setting();
  public static Vx.Core.Type_setting t_setting = new Vx.Core.Class_setting();

  /**
   * type: state
   * State. Note that this type is has mutable values.
   * (type state)
   */
  public interface Type_state : Vx.Core.Type_struct {
    public Vx.Core.Type_statelistenermap statelistenermap();
  }

  public class Class_state : Vx.Core.Class_base, Type_state {

    public Vx.Core.Type_statelistenermap? vx_p_statelistenermap = null;

    public Vx.Core.Type_statelistenermap statelistenermap() {
      Vx.Core.Type_statelistenermap output = Vx.Core.e_statelistenermap;
      Vx.Core.Type_statelistenermap? testnull = vx_p_statelistenermap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":statelistenermap")) {
        output = this.statelistenermap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":statelistenermap", this.statelistenermap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_state output = Vx.Core.vx_copy(Vx.Core.e_state, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_state output = this;
      bool ischanged = false;
      Vx.Core.Class_state value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_statelistenermap vx_p_statelistenermap = value.statelistenermap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":statelistenermap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/state", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":statelistenermap")) {
            if (valsub == vx_p_statelistenermap) {
            } else if (valsub is Vx.Core.Type_statelistenermap valstatelistenermap) {
              ischanged = true;
              vx_p_statelistenermap = valstatelistenermap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("statelistenermap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/state", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_state work = new Vx.Core.Class_state();
        work.vx_p_statelistenermap = vx_p_statelistenermap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_state;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_state;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "state", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_state e_state = new Vx.Core.Class_state();
  public static Vx.Core.Type_state t_state = new Vx.Core.Class_state();

  /**
   * type: statelistener
   * (type statelistener)
   */
  public interface Type_statelistener : Vx.Core.Type_struct {
    public Vx.Core.Type_string name();
    public Vx.Core.Type_any value();
    public Vx.Core.Func_boolean_from_none fn_boolean();
  }

  public class Class_statelistener : Vx.Core.Class_base, Type_statelistener {

    public Vx.Core.Type_string? vx_p_name = null;

    public Vx.Core.Type_string name() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any? vx_p_value = null;

    public Vx.Core.Type_any value() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_value;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Func_boolean_from_none? vx_p_fn_boolean = null;

    public Vx.Core.Func_boolean_from_none fn_boolean() {
      Vx.Core.Func_boolean_from_none output = Vx.Core.e_boolean_from_none;
      Vx.Core.Func_boolean_from_none? testnull = vx_p_fn_boolean;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":name")) {
        output = this.name();
      } else if ((skey==":value")) {
        output = this.value();
      } else if ((skey==":fn-boolean")) {
        output = this.fn_boolean();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":name", this.name());
      map.put(":value", this.value());
      map.put(":fn-boolean", this.fn_boolean());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_statelistener output = Vx.Core.vx_copy(Vx.Core.e_statelistener, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_statelistener output = this;
      bool ischanged = false;
      Vx.Core.Class_statelistener value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_name = value.name();
      Vx.Core.Type_any vx_p_value = value.value();
      Vx.Core.Func_boolean_from_none vx_p_fn_boolean = value.fn_boolean();
      List<string> validkeys = new List<string>();
      validkeys.Add(":name");
      validkeys.Add(":value");
      validkeys.Add(":fn-boolean");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/statelistener", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is Vx.Core.Type_string valname) {
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_name = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":value")) {
            if (valsub == vx_p_value) {
            } else if (valsub is Vx.Core.Type_any valvalue) {
              ischanged = true;
              vx_p_value = valvalue;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("value"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":fn-boolean")) {
            if (valsub == vx_p_fn_boolean) {
            } else if (valsub is Vx.Core.Func_boolean_from_none valfn_boolean) {
              ischanged = true;
              vx_p_fn_boolean = valfn_boolean;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("fn-boolean"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_statelistener work = new Vx.Core.Class_statelistener();
        work.vx_p_name = vx_p_name;
        work.vx_p_value = vx_p_value;
        work.vx_p_fn_boolean = vx_p_fn_boolean;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_statelistener;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_statelistener;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "statelistener", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_statelistener e_statelistener = new Vx.Core.Class_statelistener();
  public static Vx.Core.Type_statelistener t_statelistener = new Vx.Core.Class_statelistener();

  /**
   * type: statelistenermap
   * Mutable map of statelisteners
   * (type statelistenermap)
   */
  public interface Type_statelistenermap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_statelistener> vx_mapstatelistener();
    public Vx.Core.Type_statelistener vx_statelistener(Vx.Core.Type_string key);
  }

  public class Class_statelistenermap : Vx.Core.Class_base, Type_statelistenermap {

    public Vx.Core.Map<string, Vx.Core.Type_statelistener> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_statelistener>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_statelistener>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_statelistener castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_statelistener> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_statelistener>(this.vx_p_map);
        if (castval == Vx.Core.e_statelistener) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_statelistener vx_statelistener(Vx.Core.Type_string key) {
      Vx.Core.Type_statelistener output = Vx.Core.e_statelistener;
      Vx.Core.Class_statelistenermap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_statelistener> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_statelistener);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_statelistener> vx_mapstatelistener() {
      Vx.Core.Map<string, Vx.Core.Type_statelistener> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_statelistener(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_statelistenermap output = new Vx.Core.Class_statelistenermap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_statelistener> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_statelistener>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_statelistener castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/statelistenermap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_statelistenermap output = Vx.Core.vx_copy(Vx.Core.e_statelistenermap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_statelistenermap output = this;
      bool ischanged = false;
      Vx.Core.Class_statelistenermap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_statelistener> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_statelistener>(value.vx_mapstatelistener());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/statelistenermap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_statelistener valany = Vx.Core.e_statelistener;
          if (false) {
          } else if (valsub is Vx.Core.Type_statelistener valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_statelistener) {
            valany = (Vx.Core.Type_statelistener)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/statelistenermap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_statelistenermap work = new Vx.Core.Class_statelistenermap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_statelistenermap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_statelistenermap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "statelistenermap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_statelistener), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_statelistenermap e_statelistenermap = new Vx.Core.Class_statelistenermap();
  public static Vx.Core.Type_statelistenermap t_statelistenermap = new Vx.Core.Class_statelistenermap();

  /**
   * type: string
   * A simple string.
   * (type string)
   */
  public interface Type_string : Vx.Core.Type_any {
    public string vx_string();
  }

  public class Class_string : Vx.Core.Class_base, Type_string {

    internal string vxstring = "";
    
    // :implements
    public string vx_string() {
      return vxstring;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_string output = Vx.Core.vx_copy(Vx.Core.e_string, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_string output = this;
      bool ischanged = false;
      Vx.Core.Class_string value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      System.Text.StringBuilder sb = new System.Text.StringBuilder(value.vx_string());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_string valstring) {
          string ssub = valstring.vx_string();
          if (ssub == "") {
          } else {
            ischanged = true;
            sb.Append(ssub);
          }
        } else if (valsub is Vx.Core.Type_int valint) {
          ischanged = true;
          sb.Append(valint.vx_int());
        } else if (valsub is Vx.Core.Type_float valfloat) {
          ischanged = true;
          sb.Append(valfloat.vx_float());
        } else if (valsub is Vx.Core.Type_decimal valdecimal) {
          ischanged = true;
          sb.Append(valdecimal.vx_string());
        } else if (valsub is string sval) {
          if (sval == "") {
          } else {
            ischanged = true;
            sb.Append(sval);
          }
        } else if (valsub is int ival) {
          ischanged = true;
          sb.Append(ival);
        } else if (valsub is float fval) {
          ischanged = true;
          sb.Append(fval);
        } else if (valsub is Vx.Core.Type_any anysub) {
          msg = Vx.Core.vx_msg_from_error("vx/core/string", ":invalidtype", anysub);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/string", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        string vxstring = Vx.Core.vx_string_from_object(sb);
        Vx.Core.Class_string work = new Vx.Core.Class_string();
        work.vxstring = vxstring;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_string;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_string;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "string", // name
        ":string", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_string e_string = new Vx.Core.Class_string();
  public static Vx.Core.Type_string t_string = new Vx.Core.Class_string();

  /**
   * type: stringlist
   * A list of string.
   * (type stringlist)
   */
  public interface Type_stringlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_string> vx_liststring();
    public Vx.Core.Type_string vx_string(Vx.Core.Type_int index);
  }

  public class Class_stringlist : Vx.Core.Class_base, Type_stringlist {

    public List<Vx.Core.Type_string> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_string>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_string vx_string(Vx.Core.Type_int index) {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Class_stringlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_string> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_string> vx_liststring() {
      List<Vx.Core.Type_string> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_string output = this.vx_string(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_stringlist output = Vx.Core.vx_copy(Vx.Core.e_stringlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_stringlist output = this;
      bool ischanged = false;
      Vx.Core.Class_stringlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_string> listval = new List<Vx.Core.Type_string>(value.vx_liststring());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_string allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is string) {
          ischanged = true;
          listval.Add(Vx.Core.vx_new(Vx.Core.t_string, valsub));
        } else if (valsub is Vx.Core.Type_stringlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_liststring());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_string valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_stringlist work = new Vx.Core.Class_stringlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_stringlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_stringlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "stringlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_string), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_stringlist e_stringlist = new Vx.Core.Class_stringlist();
  public static Vx.Core.Type_stringlist t_stringlist = new Vx.Core.Class_stringlist();

  /**
   * type: stringlistlist
   * A list of stringlist.
   * (type stringlistlist)
   */
  public interface Type_stringlistlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_stringlist> vx_liststringlist();
    public Vx.Core.Type_stringlist vx_stringlist(Vx.Core.Type_int index);
  }

  public class Class_stringlistlist : Vx.Core.Class_base, Type_stringlistlist {

    public List<Vx.Core.Type_stringlist> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_stringlist>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_stringlist vx_stringlist(Vx.Core.Type_int index) {
      Vx.Core.Type_stringlist output = Vx.Core.e_stringlist;
      Vx.Core.Class_stringlistlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_stringlist> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_stringlist> vx_liststringlist() {
      List<Vx.Core.Type_stringlist> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_stringlist output = this.vx_stringlist(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_stringlistlist output = Vx.Core.vx_copy(Vx.Core.e_stringlistlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_stringlistlist output = this;
      bool ischanged = false;
      Vx.Core.Class_stringlistlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_stringlist> listval = new List<Vx.Core.Type_stringlist>(value.vx_liststringlist());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_stringlist allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_stringlist) {
          ischanged = true;
          listval.Add((Vx.Core.Type_stringlist)valsub);
        } else if (valsub is Vx.Core.Type_stringlistlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_liststringlist());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_stringlist valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_stringlistlist work = new Vx.Core.Class_stringlistlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_stringlistlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_stringlistlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "stringlistlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_stringlist), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_stringlistlist e_stringlistlist = new Vx.Core.Class_stringlistlist();
  public static Vx.Core.Type_stringlistlist t_stringlistlist = new Vx.Core.Class_stringlistlist();

  /**
   * type: stringmap
   * A map of string.
   * (type stringmap)
   */
  public interface Type_stringmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_string> vx_mapstring();
    public Vx.Core.Type_string vx_string(Vx.Core.Type_string key);
  }

  public class Class_stringmap : Vx.Core.Class_base, Type_stringmap {

    public Vx.Core.Map<string, Vx.Core.Type_string> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_string>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_string castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_string> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>(this.vx_p_map);
        if (castval == Vx.Core.e_string) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_string vx_string(Vx.Core.Type_string key) {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Class_stringmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_string> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_string);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_string> vx_mapstring() {
      Vx.Core.Map<string, Vx.Core.Type_string> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_string(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_stringmap output = new Vx.Core.Class_stringmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_string> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_string castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/stringmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_stringmap output = Vx.Core.vx_copy(Vx.Core.e_stringmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_stringmap output = this;
      bool ischanged = false;
      Vx.Core.Class_stringmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_string> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>(value.vx_mapstring());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/stringmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_string valany = Vx.Core.e_string;
          if (false) {
          } else if (valsub is Vx.Core.Type_string valallowed) {
            valany = valallowed;
          } else if (valsub is string) {
            valany = Vx.Core.vx_new(Vx.Core.t_string, valsub);
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/stringmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_stringmap work = new Vx.Core.Class_stringmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_stringmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_stringmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "stringmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_string), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_stringmap e_stringmap = new Vx.Core.Class_stringmap();
  public static Vx.Core.Type_stringmap t_stringmap = new Vx.Core.Class_stringmap();

  /**
   * type: stringmutablemap
   * A mutable map of string. Note: Mutables are dangerous.
   * (type stringmutablemap)
   */
  public interface Type_stringmutablemap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_string> vx_mapstring();
    public Vx.Core.Type_string vx_string(Vx.Core.Type_string key);
  }

  public class Class_stringmutablemap : Vx.Core.Class_base, Type_stringmutablemap {

    public Vx.Core.Map<string, Vx.Core.Type_string> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_string>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_string castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_string> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>(this.vx_p_map);
        if (castval == Vx.Core.e_string) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_string vx_string(Vx.Core.Type_string key) {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Class_stringmutablemap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_string> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_string);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_string> vx_mapstring() {
      Vx.Core.Map<string, Vx.Core.Type_string> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_string(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_stringmutablemap output = new Vx.Core.Class_stringmutablemap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_string> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_string castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_stringmutablemap output = Vx.Core.vx_copy(Vx.Core.e_stringmutablemap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_stringmutablemap output = this;
      bool ischanged = false;
      Vx.Core.Class_stringmutablemap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_string> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_string>(value.vx_mapstring());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/stringmutablemap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_string valany = Vx.Core.e_string;
          if (false) {
          } else if (valsub is Vx.Core.Type_string valallowed) {
            valany = valallowed;
          } else if (valsub is string) {
            valany = Vx.Core.vx_new(Vx.Core.t_string, valsub);
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_stringmutablemap work = new Vx.Core.Class_stringmutablemap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_stringmutablemap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_stringmutablemap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "stringmutablemap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_string), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_stringmutablemap e_stringmutablemap = new Vx.Core.Class_stringmutablemap();
  public static Vx.Core.Type_stringmutablemap t_stringmutablemap = new Vx.Core.Class_stringmutablemap();

  /**
   * type: struct
   * Struct is the type of all structures/objects with properties.
   * (type struct)
   */
  public interface Type_struct : Vx.Core.Type_any {
    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key);
    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map();
  }

  public class Class_struct : Vx.Core.Class_base, Type_struct {

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_struct output = Vx.Core.vx_copy(Vx.Core.e_struct, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_struct output = this;
      bool ischanged = false;
      Vx.Core.Class_struct value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_struct work = new Vx.Core.Class_struct();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_struct;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_struct;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "struct", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_struct e_struct = new Vx.Core.Class_struct();
  public static Vx.Core.Type_struct t_struct = new Vx.Core.Class_struct();

  /**
   * type: thenelse
   * (type thenelse)
   */
  public interface Type_thenelse : Vx.Core.Type_struct {
    public Vx.Core.Type_string code();
    public Vx.Core.Type_any value();
    public Vx.Core.Type_list values();
    public Vx.Core.Func_boolean_from_func fn_cond();
    public Vx.Core.Func_any_from_func fn_any();
  }

  public class Class_thenelse : Vx.Core.Class_base, Type_thenelse {

    public Vx.Core.Type_string? vx_p_code = null;

    public Vx.Core.Type_string code() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_code;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any? vx_p_value = null;

    public Vx.Core.Type_any value() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_value;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_list? vx_p_values = null;

    public Vx.Core.Type_list values() {
      Vx.Core.Type_list output = Vx.Core.e_list;
      Vx.Core.Type_list? testnull = vx_p_values;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Func_boolean_from_func? vx_p_fn_cond = null;

    public Vx.Core.Func_boolean_from_func fn_cond() {
      Vx.Core.Func_boolean_from_func output = Vx.Core.e_boolean_from_func;
      Vx.Core.Func_boolean_from_func? testnull = vx_p_fn_cond;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Func_any_from_func? vx_p_fn_any = null;

    public Vx.Core.Func_any_from_func fn_any() {
      Vx.Core.Func_any_from_func output = Vx.Core.e_any_from_func;
      Vx.Core.Func_any_from_func? testnull = vx_p_fn_any;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":code")) {
        output = this.code();
      } else if ((skey==":value")) {
        output = this.value();
      } else if ((skey==":values")) {
        output = this.values();
      } else if ((skey==":fn-cond")) {
        output = this.fn_cond();
      } else if ((skey==":fn-any")) {
        output = this.fn_any();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":code", this.code());
      map.put(":value", this.value());
      map.put(":values", this.values());
      map.put(":fn-cond", this.fn_cond());
      map.put(":fn-any", this.fn_any());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_thenelse output = Vx.Core.vx_copy(Vx.Core.e_thenelse, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_thenelse output = this;
      bool ischanged = false;
      Vx.Core.Class_thenelse value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_code = value.code();
      Vx.Core.Type_any vx_p_value = value.value();
      Vx.Core.Type_list vx_p_values = value.values();
      Vx.Core.Func_boolean_from_func vx_p_fn_cond = value.fn_cond();
      Vx.Core.Func_any_from_func vx_p_fn_any = value.fn_any();
      List<string> validkeys = new List<string>();
      validkeys.Add(":code");
      validkeys.Add(":value");
      validkeys.Add(":values");
      validkeys.Add(":fn-cond");
      validkeys.Add(":fn-any");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":code")) {
            if (valsub == vx_p_code) {
            } else if (valsub is Vx.Core.Type_string valcode) {
              ischanged = true;
              vx_p_code = valcode;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_code = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("code"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":value")) {
            if (valsub == vx_p_value) {
            } else if (valsub is Vx.Core.Type_any valvalue) {
              ischanged = true;
              vx_p_value = valvalue;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("value"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":values")) {
            if (valsub == vx_p_values) {
            } else if (valsub is Vx.Core.Type_list valvalues) {
              ischanged = true;
              vx_p_values = valvalues;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("values"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":fn-cond")) {
            if (valsub == vx_p_fn_cond) {
            } else if (valsub is Vx.Core.Func_boolean_from_func valfn_cond) {
              ischanged = true;
              vx_p_fn_cond = valfn_cond;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("fn-cond"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":fn-any")) {
            if (valsub == vx_p_fn_any) {
            } else if (valsub is Vx.Core.Func_any_from_func valfn_any) {
              ischanged = true;
              vx_p_fn_any = valfn_any;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("fn-any"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_thenelse work = new Vx.Core.Class_thenelse();
        work.vx_p_code = vx_p_code;
        work.vx_p_value = vx_p_value;
        work.vx_p_values = vx_p_values;
        work.vx_p_fn_cond = vx_p_fn_cond;
        work.vx_p_fn_any = vx_p_fn_any;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_thenelse;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_thenelse;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "thenelse", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_thenelse e_thenelse = new Vx.Core.Class_thenelse();
  public static Vx.Core.Type_thenelse t_thenelse = new Vx.Core.Class_thenelse();

  /**
   * type: thenelselist
   * (type thenelselist)
   */
  public interface Type_thenelselist : Vx.Core.Type_list {
    public List<Vx.Core.Type_thenelse> vx_listthenelse();
    public Vx.Core.Type_thenelse vx_thenelse(Vx.Core.Type_int index);
  }

  public class Class_thenelselist : Vx.Core.Class_base, Type_thenelselist {

    public List<Vx.Core.Type_thenelse> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_thenelse>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_thenelse vx_thenelse(Vx.Core.Type_int index) {
      Vx.Core.Type_thenelse output = Vx.Core.e_thenelse;
      Vx.Core.Class_thenelselist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_thenelse> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_thenelse> vx_listthenelse() {
      List<Vx.Core.Type_thenelse> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_thenelse output = this.vx_thenelse(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_thenelselist output = Vx.Core.vx_copy(Vx.Core.e_thenelselist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_thenelselist output = this;
      bool ischanged = false;
      Vx.Core.Class_thenelselist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_thenelse> listval = new List<Vx.Core.Type_thenelse>(value.vx_listthenelse());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_thenelse allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_thenelse) {
          ischanged = true;
          listval.Add((Vx.Core.Type_thenelse)valsub);
        } else if (valsub is Vx.Core.Type_thenelselist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listthenelse());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_thenelse valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_thenelselist work = new Vx.Core.Class_thenelselist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_thenelselist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_thenelselist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "thenelselist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_thenelse), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_thenelselist e_thenelselist = new Vx.Core.Class_thenelselist();
  public static Vx.Core.Type_thenelselist t_thenelselist = new Vx.Core.Class_thenelselist();

  /**
   * type: translation
   * i18 language translation.
   * (type translation)
   */
  public interface Type_translation : Vx.Core.Type_struct {
    public Vx.Core.Type_string name();
    public Vx.Core.Type_stringmap wordmap();
  }

  public class Class_translation : Vx.Core.Class_base, Type_translation {

    public Vx.Core.Type_string? vx_p_name = null;

    public Vx.Core.Type_string name() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_stringmap? vx_p_wordmap = null;

    public Vx.Core.Type_stringmap wordmap() {
      Vx.Core.Type_stringmap output = Vx.Core.e_stringmap;
      Vx.Core.Type_stringmap? testnull = vx_p_wordmap;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":name")) {
        output = this.name();
      } else if ((skey==":wordmap")) {
        output = this.wordmap();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":name", this.name());
      map.put(":wordmap", this.wordmap());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_translation output = Vx.Core.vx_copy(Vx.Core.e_translation, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_translation output = this;
      bool ischanged = false;
      Vx.Core.Class_translation value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_name = value.name();
      Vx.Core.Type_stringmap vx_p_wordmap = value.wordmap();
      List<string> validkeys = new List<string>();
      validkeys.Add(":name");
      validkeys.Add(":wordmap");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/translation", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is Vx.Core.Type_string valname) {
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_name = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":wordmap")) {
            if (valsub == vx_p_wordmap) {
            } else if (valsub is Vx.Core.Type_stringmap valwordmap) {
              ischanged = true;
              vx_p_wordmap = valwordmap;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("wordmap"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_translation work = new Vx.Core.Class_translation();
        work.vx_p_name = vx_p_name;
        work.vx_p_wordmap = vx_p_wordmap;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_translation;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_translation;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "translation", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_translation e_translation = new Vx.Core.Class_translation();
  public static Vx.Core.Type_translation t_translation = new Vx.Core.Class_translation();

  /**
   * type: translationlist
   * i18 language translation list.
   * (type translationlist)
   */
  public interface Type_translationlist : Vx.Core.Type_list {
    public List<Vx.Core.Type_translation> vx_listtranslation();
    public Vx.Core.Type_translation vx_translation(Vx.Core.Type_int index);
  }

  public class Class_translationlist : Vx.Core.Class_base, Type_translationlist {

    public List<Vx.Core.Type_translation> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_translation>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_translation vx_translation(Vx.Core.Type_int index) {
      Vx.Core.Type_translation output = Vx.Core.e_translation;
      Vx.Core.Class_translationlist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_translation> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public List<Vx.Core.Type_translation> vx_listtranslation() {
      List<Vx.Core.Type_translation> output = this.vx_p_list;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_translation output = this.vx_translation(index);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_translationlist output = Vx.Core.vx_copy(Vx.Core.e_translationlist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_translationlist output = this;
      bool ischanged = false;
      Vx.Core.Class_translationlist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_translation> listval = new List<Vx.Core.Type_translation>(value.vx_listtranslation());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_translation allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_translation) {
          ischanged = true;
          listval.Add((Vx.Core.Type_translation)valsub);
        } else if (valsub is Vx.Core.Type_translationlist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_listtranslation());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_translation valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_translationlist work = new Vx.Core.Class_translationlist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_translationlist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_translationlist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "translationlist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_translation), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_translationlist e_translationlist = new Vx.Core.Class_translationlist();
  public static Vx.Core.Type_translationlist t_translationlist = new Vx.Core.Class_translationlist();

  /**
   * type: translationmap
   * i18 language translation map.
   * (type translationmap)
   */
  public interface Type_translationmap : Vx.Core.Type_map {
    public Vx.Core.Map<string, Vx.Core.Type_translation> vx_maptranslation();
    public Vx.Core.Type_translation vx_translation(Vx.Core.Type_string key);
  }

  public class Class_translationmap : Vx.Core.Class_base, Type_translationmap {

    public Vx.Core.Map<string, Vx.Core.Type_translation> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_translation>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = Vx.Core.vx_map_from_map<Vx.Core.Type_any, Vx.Core.Type_translation>(this.vx_p_map);
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_translation castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_translation> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_translation>(this.vx_p_map);
        if (castval == Vx.Core.e_translation) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_translation vx_translation(Vx.Core.Type_string key) {
      Vx.Core.Type_translation output = Vx.Core.e_translation;
      Vx.Core.Class_translationmap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_translation> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_translation);
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_translation> vx_maptranslation() {
      Vx.Core.Map<string, Vx.Core.Type_translation> output = this.vx_p_map;
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = this.vx_translation(key);
      return output;
    }


    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_translationmap output = new Vx.Core.Class_translationmap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_translation> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_translation>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_translation castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/translationmap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_translationmap output = Vx.Core.vx_copy(Vx.Core.e_translationmap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_translationmap output = this;
      bool ischanged = false;
      Vx.Core.Class_translationmap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_translation> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_translation>(value.vx_maptranslation());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/translationmap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_translation valany = Vx.Core.e_translation;
          if (false) {
          } else if (valsub is Vx.Core.Type_translation valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_translation) {
            valany = (Vx.Core.Type_translation)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/translationmap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_translationmap work = new Vx.Core.Class_translationmap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_translationmap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_translationmap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "translationmap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_translation), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_translationmap e_translationmap = new Vx.Core.Class_translationmap();
  public static Vx.Core.Type_translationmap t_translationmap = new Vx.Core.Class_translationmap();

  /**
   * type: type
   * Original Type Class
   * (type type)
   */
  public interface Type_type : Vx.Core.Type_any {
  }

  public class Class_type : Vx.Core.Class_base, Type_type {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_type output = Vx.Core.vx_copy(Vx.Core.e_type, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_type output = this;
      bool ischanged = false;
      Vx.Core.Class_type value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_type work = new Vx.Core.Class_type();
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_type;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_type;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "type", // name
        ":type", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_type e_type = new Vx.Core.Class_type();
  public static Vx.Core.Type_type t_type = new Vx.Core.Class_type();

  /**
   * type: typedef
   * Type Definition Class for inspecting Type properties.
   * (type typedef)
   */
  public interface Type_typedef : Vx.Core.Type_struct {
    public Vx.Core.Type_string pkgname();
    public Vx.Core.Type_string name();
    public Vx.Core.Type_string extend();
    public Vx.Core.Type_funclist allowfuncs();
    public Vx.Core.Type_typelist allowtypes();
    public Vx.Core.Type_anylist allowvalues();
    public Vx.Core.Type_funclist disallowfuncs();
    public Vx.Core.Type_typelist disallowtypes();
    public Vx.Core.Type_anylist disallowvalues();
    public Vx.Core.Type_argmap properties();
    public Vx.Core.Type_arg proplast();
    public Vx.Core.Type_typelist traits();
  }

  public class Class_typedef : Vx.Core.Class_base, Type_typedef {

    public Vx.Core.Type_string? vx_p_pkgname = null;

    public Vx.Core.Type_string pkgname() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_pkgname;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_name = null;

    public Vx.Core.Type_string name() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_name;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_extend = null;

    public Vx.Core.Type_string extend() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_extend;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_funclist? vx_p_allowfuncs = null;

    public Vx.Core.Type_funclist allowfuncs() {
      Vx.Core.Type_funclist output = Vx.Core.e_funclist;
      Vx.Core.Type_funclist? testnull = vx_p_allowfuncs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_typelist? vx_p_allowtypes = null;

    public Vx.Core.Type_typelist allowtypes() {
      Vx.Core.Type_typelist output = Vx.Core.e_typelist;
      Vx.Core.Type_typelist? testnull = vx_p_allowtypes;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_anylist? vx_p_allowvalues = null;

    public Vx.Core.Type_anylist allowvalues() {
      Vx.Core.Type_anylist output = Vx.Core.e_anylist;
      Vx.Core.Type_anylist? testnull = vx_p_allowvalues;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_funclist? vx_p_disallowfuncs = null;

    public Vx.Core.Type_funclist disallowfuncs() {
      Vx.Core.Type_funclist output = Vx.Core.e_funclist;
      Vx.Core.Type_funclist? testnull = vx_p_disallowfuncs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_typelist? vx_p_disallowtypes = null;

    public Vx.Core.Type_typelist disallowtypes() {
      Vx.Core.Type_typelist output = Vx.Core.e_typelist;
      Vx.Core.Type_typelist? testnull = vx_p_disallowtypes;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_anylist? vx_p_disallowvalues = null;

    public Vx.Core.Type_anylist disallowvalues() {
      Vx.Core.Type_anylist output = Vx.Core.e_anylist;
      Vx.Core.Type_anylist? testnull = vx_p_disallowvalues;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_argmap? vx_p_properties = null;

    public Vx.Core.Type_argmap properties() {
      Vx.Core.Type_argmap output = Vx.Core.e_argmap;
      Vx.Core.Type_argmap? testnull = vx_p_properties;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_arg? vx_p_proplast = null;

    public Vx.Core.Type_arg proplast() {
      Vx.Core.Type_arg output = Vx.Core.e_arg;
      Vx.Core.Type_arg? testnull = vx_p_proplast;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_typelist? vx_p_traits = null;

    public Vx.Core.Type_typelist traits() {
      Vx.Core.Type_typelist output = Vx.Core.e_typelist;
      Vx.Core.Type_typelist? testnull = vx_p_traits;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname();
      } else if ((skey==":name")) {
        output = this.name();
      } else if ((skey==":extends")) {
        output = this.extend();
      } else if ((skey==":allowfuncs")) {
        output = this.allowfuncs();
      } else if ((skey==":allowtypes")) {
        output = this.allowtypes();
      } else if ((skey==":allowvalues")) {
        output = this.allowvalues();
      } else if ((skey==":disallowfuncs")) {
        output = this.disallowfuncs();
      } else if ((skey==":disallowtypes")) {
        output = this.disallowtypes();
      } else if ((skey==":disallowvalues")) {
        output = this.disallowvalues();
      } else if ((skey==":properties")) {
        output = this.properties();
      } else if ((skey==":proplast")) {
        output = this.proplast();
      } else if ((skey==":traits")) {
        output = this.traits();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":pkgname", this.pkgname());
      map.put(":name", this.name());
      map.put(":extends", this.extend());
      map.put(":allowfuncs", this.allowfuncs());
      map.put(":allowtypes", this.allowtypes());
      map.put(":allowvalues", this.allowvalues());
      map.put(":disallowfuncs", this.disallowfuncs());
      map.put(":disallowtypes", this.disallowtypes());
      map.put(":disallowvalues", this.disallowvalues());
      map.put(":properties", this.properties());
      map.put(":proplast", this.proplast());
      map.put(":traits", this.traits());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_typedef output = Vx.Core.vx_copy(Vx.Core.e_typedef, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_typedef output = this;
      bool ischanged = false;
      Vx.Core.Class_typedef value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_string vx_p_pkgname = value.pkgname();
      Vx.Core.Type_string vx_p_name = value.name();
      Vx.Core.Type_string vx_p_extend = value.extend();
      Vx.Core.Type_funclist vx_p_allowfuncs = value.allowfuncs();
      Vx.Core.Type_typelist vx_p_allowtypes = value.allowtypes();
      Vx.Core.Type_anylist vx_p_allowvalues = value.allowvalues();
      Vx.Core.Type_funclist vx_p_disallowfuncs = value.disallowfuncs();
      Vx.Core.Type_typelist vx_p_disallowtypes = value.disallowtypes();
      Vx.Core.Type_anylist vx_p_disallowvalues = value.disallowvalues();
      Vx.Core.Type_argmap vx_p_properties = value.properties();
      Vx.Core.Type_arg vx_p_proplast = value.proplast();
      Vx.Core.Type_typelist vx_p_traits = value.traits();
      List<string> validkeys = new List<string>();
      validkeys.Add(":pkgname");
      validkeys.Add(":name");
      validkeys.Add(":extends");
      validkeys.Add(":allowfuncs");
      validkeys.Add(":allowtypes");
      validkeys.Add(":allowvalues");
      validkeys.Add(":disallowfuncs");
      validkeys.Add(":disallowtypes");
      validkeys.Add(":disallowvalues");
      validkeys.Add(":properties");
      validkeys.Add(":proplast");
      validkeys.Add(":traits");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is Vx.Core.Type_string valpkgname) {
              ischanged = true;
              vx_p_pkgname = valpkgname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_pkgname = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("pkgname"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is Vx.Core.Type_string valname) {
              ischanged = true;
              vx_p_name = valname;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_name = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("name"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":extends")) {
            if (valsub == vx_p_extend) {
            } else if (valsub is Vx.Core.Type_string valextend) {
              ischanged = true;
              vx_p_extend = valextend;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_extend = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("extends"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":allowfuncs")) {
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub is Vx.Core.Type_funclist valallowfuncs) {
              ischanged = true;
              vx_p_allowfuncs = valallowfuncs;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("allowfuncs"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":allowtypes")) {
            if (valsub == vx_p_allowtypes) {
            } else if (valsub is Vx.Core.Type_typelist valallowtypes) {
              ischanged = true;
              vx_p_allowtypes = valallowtypes;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("allowtypes"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":allowvalues")) {
            if (valsub == vx_p_allowvalues) {
            } else if (valsub is Vx.Core.Type_anylist valallowvalues) {
              ischanged = true;
              vx_p_allowvalues = valallowvalues;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("allowvalues"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":disallowfuncs")) {
            if (valsub == vx_p_disallowfuncs) {
            } else if (valsub is Vx.Core.Type_funclist valdisallowfuncs) {
              ischanged = true;
              vx_p_disallowfuncs = valdisallowfuncs;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("disallowfuncs"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":disallowtypes")) {
            if (valsub == vx_p_disallowtypes) {
            } else if (valsub is Vx.Core.Type_typelist valdisallowtypes) {
              ischanged = true;
              vx_p_disallowtypes = valdisallowtypes;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("disallowtypes"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":disallowvalues")) {
            if (valsub == vx_p_disallowvalues) {
            } else if (valsub is Vx.Core.Type_anylist valdisallowvalues) {
              ischanged = true;
              vx_p_disallowvalues = valdisallowvalues;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("disallowvalues"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":properties")) {
            if (valsub == vx_p_properties) {
            } else if (valsub is Vx.Core.Type_argmap valproperties) {
              ischanged = true;
              vx_p_properties = valproperties;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("properties"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":proplast")) {
            if (valsub == vx_p_proplast) {
            } else if (valsub is Vx.Core.Type_arg valproplast) {
              ischanged = true;
              vx_p_proplast = valproplast;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("proplast"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":traits")) {
            if (valsub == vx_p_traits) {
            } else if (valsub is Vx.Core.Type_typelist valtraits) {
              ischanged = true;
              vx_p_traits = valtraits;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("traits"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_typedef work = new Vx.Core.Class_typedef();
        work.vx_p_pkgname = vx_p_pkgname;
        work.vx_p_name = vx_p_name;
        work.vx_p_extend = vx_p_extend;
        work.vx_p_allowfuncs = vx_p_allowfuncs;
        work.vx_p_allowtypes = vx_p_allowtypes;
        work.vx_p_allowvalues = vx_p_allowvalues;
        work.vx_p_disallowfuncs = vx_p_disallowfuncs;
        work.vx_p_disallowtypes = vx_p_disallowtypes;
        work.vx_p_disallowvalues = vx_p_disallowvalues;
        work.vx_p_properties = vx_p_properties;
        work.vx_p_proplast = vx_p_proplast;
        work.vx_p_traits = vx_p_traits;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typedef;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "typedef", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_typedef e_typedef = new Vx.Core.Class_typedef();
  public static Vx.Core.Type_typedef t_typedef = new Vx.Core.Class_typedef();

  /**
   * type: typelist
   * List of Types
   * (type typelist)
   */
  public interface Type_typelist : Vx.Core.Type_list {
  }

  public class Class_typelist : Vx.Core.Class_base, Type_typelist {

    public List<Vx.Core.Type_any> vx_p_list = Vx.Core.immutablelist(
      new List<Vx.Core.Type_any>()
    );

    public List<Vx.Core.Type_any> vx_list() {
      List<Vx.Core.Type_any> output = Vx.Core.immutablelist(
        new List<Vx.Core.Type_any>(this.vx_p_list)
      );
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_int index) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_typelist list = this;
      int iindex = index.vx_int();
      List<Vx.Core.Type_any> listval = list.vx_p_list;
      if (iindex < listval.Count) {
        output = listval[iindex];
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_typelist output = Vx.Core.vx_copy(Vx.Core.e_typelist, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_typelist output = this;
      bool ischanged = false;
      Vx.Core.Class_typelist value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      List<Vx.Core.Type_any> listval = new List<Vx.Core.Type_any>(value.vx_list());
      Vx.Core.Type_msg msg;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_any allowsub) {
          ischanged = true;
          listval.Add(allowsub);
        } else if (valsub is Vx.Core.Type_typelist multi) {
          ischanged = true;
          listval.AddRange(multi.vx_list());
        } else if (valsub is List<Vx.Core.Type_any> listany) {
          foreach (Vx.Core.Type_any item in listany) {
            if (false) {
            } else if (item is Vx.Core.Type_any valitem) {
              ischanged = true;
              listval.Add(valitem);
            }
          }
        } else if (valsub is Vx.Core.Type_any anyinvalid) {
          msg = Vx.Core.vx_msg_from_error("vx/core/typelist", ":invalidtype", anyinvalid);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        } else {
          msg = Vx.Core.vx_msg_from_error("vx/core/typelist", ":invalidtype", Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub)));
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_typelist work = new Vx.Core.Class_typelist();
        work.vx_p_list = Vx.Core.immutablelist(listval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typelist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typelist;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "typelist", // name
        ":list", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_typelist e_typelist = new Vx.Core.Class_typelist();
  public static Vx.Core.Type_typelist t_typelist = new Vx.Core.Class_typelist();

  /**
   * type: typemap
   * Map of Any Type Class
   * (type typemap)
   */
  public interface Type_typemap : Vx.Core.Type_map {
  }

  public class Class_typemap : Vx.Core.Class_base, Type_typemap {

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_p_map = Vx.Core.immutablemap(new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>());

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> anymap = this.vx_p_map;
      Vx.Core.Map<string, Vx.Core.Type_any> map = anymap.copy();
      return Vx.Core.immutablemap(map);
    }

    public Vx.Core.Type_boolean vx_set(Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      if (false) {
      } else if (value is Vx.Core.Type_any castval) {
        string key = name.vx_string();
        if (key.StartsWith(":")) {
          key = key.Substring(1);
        }
        Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(this.vx_p_map);
        if (castval == Vx.Core.e_any) {
          map.remove(key);
        } else {
          map.put(key, castval);
        }
        this.vx_p_map = Vx.Core.immutablemap(map);
        output = Vx.Core.c_true;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Class_typemap map = this;
      string skey = key.vx_string();
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = map.vx_p_map;
      output = mapval.getOrElse(skey, Vx.Core.e_any);
      return output;
    }

    public Vx.Core.Type_map vx_new_from_map(Vx.Core.Map<string, Vx.Core.Type_any> mapval) {
      Vx.Core.Class_typemap output = new Vx.Core.Class_typemap();
      Vx.Core.Type_msgblock msgblock = Vx.Core.e_msgblock;
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      List<string> keys = mapval.keys();
      foreach (string key in keys) {
        Vx.Core.Type_any value = mapval.get(key);
        if (false) {
        } else if (value is Vx.Core.Type_any castval) {
          map.put(key, castval);
        } else {
          Vx.Core.Type_msg msg = Vx.Core.vx_msg_from_error("vx/core/typemap", ":invalidvalue", value);
          msgblock = Vx.Core.vx_copy(msgblock, msg);
        }
      }
      output.vx_p_map = Vx.Core.immutablemap(map);
      if (msgblock != Vx.Core.e_msgblock) {
        output.vxmsgblock = msgblock;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_typemap output = Vx.Core.vx_copy(Vx.Core.e_typemap, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_typemap output = this;
      bool ischanged = false;
      Vx.Core.Class_typemap value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Map<string, Vx.Core.Type_any> mapval = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>(value.vx_map());
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstring) {
            key = valstring.vx_string();
          } else if (valsub is string sval) {
            key = sval;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/typemap", ":keyexpected", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
        } else {
          Vx.Core.Type_any valany = Vx.Core.e_any;
          if (false) {
          } else if (valsub is Vx.Core.Type_any valallowed) {
            valany = valallowed;
          } else if (valsub is Vx.Core.Type_any) {
            valany = (Vx.Core.Type_any)valsub;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valinvalid) {
              msgval = valinvalid;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
            mapany.put("key", Vx.Core.vx_new_string(key));
            mapany.put("value", msgval);
            Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
            msg = Vx.Core.vx_msg_from_error("vx/core/typemap", ":invalidkeyvalue", msgmap);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (valany != Vx.Core.e_any) {
            ischanged = true;
            if (key.StartsWith(":")) {
              key = key.Substring(1);
            }
            mapval.put(key, valany);
            key = "";
          }
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_typemap work = new Vx.Core.Class_typemap();
        work.vx_p_map = Vx.Core.immutablemap(mapval);
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typemap;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typemap;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "typemap", // name
        ":map", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_typemap e_typemap = new Vx.Core.Class_typemap();
  public static Vx.Core.Type_typemap t_typemap = new Vx.Core.Class_typemap();

  /**
   * type: user
   * User Type
   * (type user)
   */
  public interface Type_user : Vx.Core.Type_struct {
    public Vx.Core.Type_security security();
    public Vx.Core.Type_string username();
    public Vx.Core.Type_string token();
  }

  public class Class_user : Vx.Core.Class_base, Type_user {

    public Vx.Core.Type_security? vx_p_security = null;

    public Vx.Core.Type_security security() {
      Vx.Core.Type_security output = Vx.Core.e_security;
      Vx.Core.Type_security? testnull = vx_p_security;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_username = null;

    public Vx.Core.Type_string username() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_username;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_string? vx_p_token = null;

    public Vx.Core.Type_string token() {
      Vx.Core.Type_string output = Vx.Core.e_string;
      Vx.Core.Type_string? testnull = vx_p_token;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":security")) {
        output = this.security();
      } else if ((skey==":username")) {
        output = this.username();
      } else if ((skey==":token")) {
        output = this.token();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":security", this.security());
      map.put(":username", this.username());
      map.put(":token", this.token());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_user output = Vx.Core.vx_copy(Vx.Core.e_user, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_user output = this;
      bool ischanged = false;
      Vx.Core.Class_user value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_security vx_p_security = value.security();
      Vx.Core.Type_string vx_p_username = value.username();
      Vx.Core.Type_string vx_p_token = value.token();
      List<string> validkeys = new List<string>();
      validkeys.Add(":security");
      validkeys.Add(":username");
      validkeys.Add(":token");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/user", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":security")) {
            if (valsub == vx_p_security) {
            } else if (valsub is Vx.Core.Type_security valsecurity) {
              ischanged = true;
              vx_p_security = valsecurity;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("security"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":username")) {
            if (valsub == vx_p_username) {
            } else if (valsub is Vx.Core.Type_string valusername) {
              ischanged = true;
              vx_p_username = valusername;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_username = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("username"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":token")) {
            if (valsub == vx_p_token) {
            } else if (valsub is Vx.Core.Type_string valtoken) {
              ischanged = true;
              vx_p_token = valtoken;
            } else if (valsub is string) {
              ischanged = true;
              vx_p_token = Vx.Core.vx_new(Vx.Core.t_string, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("token"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_user work = new Vx.Core.Class_user();
        work.vx_p_security = vx_p_security;
        work.vx_p_username = vx_p_username;
        work.vx_p_token = vx_p_token;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_user;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_user;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "user", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_user e_user = new Vx.Core.Class_user();
  public static Vx.Core.Type_user t_user = new Vx.Core.Class_user();

  /**
   * type: value
   * (type value)
   */
  public interface Type_value : Vx.Core.Type_struct {
    public Vx.Core.Type_any next();
    public Vx.Core.Type_int refs();
  }

  public class Class_value : Vx.Core.Class_base, Type_value {

    public Vx.Core.Type_any? vx_p_next = null;

    public Vx.Core.Type_any next() {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any? testnull = vx_p_next;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_int? vx_p_refs = null;

    public Vx.Core.Type_int refs() {
      Vx.Core.Type_int output = Vx.Core.e_int;
      Vx.Core.Type_int? testnull = vx_p_refs;
      if (testnull != null) {
        output = testnull;
      }
      return output;
    }

    public Vx.Core.Type_any vx_any(Vx.Core.Type_string key) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      string skey = key.vx_string();
      if (false) {
      } else if ((skey==":next")) {
        output = this.next();
      } else if ((skey==":refs")) {
        output = this.refs();
      }
      return output;
    }

    public Vx.Core.Map<string, Vx.Core.Type_any> vx_map() {
      Vx.Core.Map<string, Vx.Core.Type_any> map = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
      map.put(":next", this.next());
      map.put(":refs", this.refs());
      Vx.Core.Map<string, Vx.Core.Type_any> output = Vx.Core.immutablemap(map);
      return output;
    }

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Type_value output = Vx.Core.vx_copy(Vx.Core.e_value, vals);
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Type_value output = this;
      bool ischanged = false;
      Vx.Core.Class_value value = this;
      Vx.Core.Type_msgblock msgblock = Vx.Core.vx_msgblock_from_copy_arrayval(value, vals);
      if (this.vx_constdef() != Vx.Core.e_constdef) {
        ischanged = true;
      }
      Vx.Core.Type_any vx_p_next = value.next();
      Vx.Core.Type_int vx_p_refs = value.refs();
      List<string> validkeys = new List<string>();
      validkeys.Add(":next");
      validkeys.Add(":refs");
      string key = "";
      Vx.Core.Type_msg msg = Vx.Core.e_msg;
      Vx.Core.Type_any msgval = Vx.Core.e_any;
      foreach (object valsub in vals) {
        if (valsub is Vx.Core.Type_msgblock) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (valsub is Vx.Core.Type_msg) {
          msgblock = Vx.Core.vx_copy(msgblock, valsub);
        } else if (key == "") {
          bool istestkey = false;
          string testkey = "";
          if (false) {
          } else if (valsub is Vx.Core.Type_string valstr) {
            testkey = valstr.vx_string();
            istestkey = true;
          } else if (valsub is string sval) {
            testkey = sval;
            istestkey = true;
          } else {
            if (false) {
            } else if (valsub is Vx.Core.Type_any valmsg) {
              msgval = valmsg;
            } else {
              msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
            }
            msg = Vx.Core.vx_msg_from_error("vx/core/value", ":invalidkeytype", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          if (istestkey) {
            if (!testkey.StartsWith(":")) {
              testkey = ":" + testkey;
            }
            bool isvalidkey = validkeys.Contains(testkey);
            if (isvalidkey) {
              key = testkey;
            } else {
              msgval = Vx.Core.vx_new_string(testkey);
              msg = Vx.Core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          }
        } else {
          if (false) {
          } else if ((key==":next")) {
            if (valsub == vx_p_next) {
            } else if (valsub is Vx.Core.Type_any valnext) {
              ischanged = true;
              vx_p_next = valnext;
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("next"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else if ((key==":refs")) {
            if (valsub == vx_p_refs) {
            } else if (valsub is Vx.Core.Type_int valrefs) {
              ischanged = true;
              vx_p_refs = valrefs;
            } else if (valsub is int) {
              ischanged = true;
              vx_p_refs = Vx.Core.vx_new(Vx.Core.t_int, valsub);
            } else {
              if (false) {
              } else if (valsub is Vx.Core.Type_any valinvalid) {
                msgval = valinvalid;
              } else {
                msgval = Vx.Core.vx_new_string(Vx.Core.vx_string_from_object(valsub));
              }
              Vx.Core.Map<string, Vx.Core.Type_any> mapany = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
              mapany.put("key", Vx.Core.vx_new_string("refs"));
              mapany.put("value", msgval);
              Vx.Core.Type_map msgmap = Vx.Core.t_anymap.vx_new_from_map(mapany);
              msg = Vx.Core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap);
              msgblock = Vx.Core.vx_copy(msgblock, msg);
            }
          } else {
            msgval = Vx.Core.vx_new_string(key);
            msg = Vx.Core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval);
            msgblock = Vx.Core.vx_copy(msgblock, msg);
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != Vx.Core.e_msgblock)) {
        Vx.Core.Class_value work = new Vx.Core.Class_value();
        work.vx_p_next = vx_p_next;
        work.vx_p_refs = vx_p_refs;
        if (msgblock != Vx.Core.e_msgblock) {
          work.vxmsgblock = msgblock;
        }
        output = work;
      }
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_value;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_value;
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.typedef_new(
        "vx/core", // pkgname
        "value", // name
        ":struct", // extends
        Vx.Core.e_typelist, // traits
        Vx.Core.e_typelist, // allowtypes
        Vx.Core.e_typelist, // disallowtypes
        Vx.Core.e_funclist, // allowfuncs
        Vx.Core.e_funclist, // disallowfuncs
        Vx.Core.e_anylist, // allowvalues
        Vx.Core.e_anylist, // disallowvalues
        Vx.Core.e_argmap // properties
      );
      return output;
    }

  }

  public static Vx.Core.Type_value e_value = new Vx.Core.Class_value();
  public static Vx.Core.Type_value t_value = new Vx.Core.Class_value();

  /**
   * Constant: false
   * {boolean}
   */
  public class Const_false {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "false", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_boolean output) {
      Vx.Core.Class_boolean outval = (Vx.Core.Class_boolean)output;
      outval.vx_p_constdef = constdef();
      outval.vxboolean = false;
    }

  }

  public static Vx.Core.Type_boolean c_false = new Vx.Core.Class_boolean();

  public static Vx.Core.Type_boolean e_boolean = Vx.Core.c_false;

  /**
   * Constant: global
   * Global variable for project data.
   * {project}
   */
  public class Const_global {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "global", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "project", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_project output) {
      Vx.Core.Class_project outval = (Vx.Core.Class_project)output;
      outval.vx_p_constdef = constdef();
    }

  }

  public static Vx.Core.Type_project c_global = new Vx.Core.Class_project();


  /**
   * Constant: infinity
   * Infinity. Returned during unusual calculations.
   * {int}
   */
  public class Const_infinity {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "infinity", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static Vx.Core.Type_int c_infinity = new Vx.Core.Class_int();


  /**
   * Constant: mempool-active
   * Active Value Memory Pool
   * {mempool}
   */
  public class Const_mempool_active {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "mempool-active", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "mempool", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_mempool output) {
      Vx.Core.Class_mempool outval = (Vx.Core.Class_mempool)output;
      outval.vx_p_constdef = constdef();
    }

  }

  public static Vx.Core.Type_mempool c_mempool_active = new Vx.Core.Class_mempool();


  /**
   * Constant: msg-error
   * Message is an Error
   * {int}
   */
  public class Const_msg_error {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "msg-error", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 2;
    }

  }

  public static Vx.Core.Type_int c_msg_error = new Vx.Core.Class_int();


  /**
   * Constant: msg-info
   * Message is just information
   * {int}
   */
  public class Const_msg_info {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "msg-info", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static Vx.Core.Type_int c_msg_info = new Vx.Core.Class_int();


  /**
   * Constant: msg-severe
   * Message is a Severe Error
   * {int}
   */
  public class Const_msg_severe {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "msg-severe", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 3;
    }

  }

  public static Vx.Core.Type_int c_msg_severe = new Vx.Core.Class_int();


  /**
   * Constant: msg-warning
   * Message is a Warning
   * {int}
   */
  public class Const_msg_warning {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "msg-warning", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 1;
    }

  }

  public static Vx.Core.Type_int c_msg_warning = new Vx.Core.Class_int();


  /**
   * Constant: neginfinity
   * Negative Infinity. Returned during unusual calculations.
   * {int}
   */
  public class Const_neginfinity {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "neginfinity", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static Vx.Core.Type_int c_neginfinity = new Vx.Core.Class_int();


  /**
   * Constant: newline
   * New line constant
   * {string}
   */
  public class Const_newline {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "newline", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_string output) {
      Vx.Core.Class_string outval = (Vx.Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "\n";
    }

  }

  public static Vx.Core.Type_string c_newline = new Vx.Core.Class_string();


  /**
   * Constant: notanumber
   * Not a number. Returned during invalid calculations.
   * {int}
   */
  public class Const_notanumber {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "notanumber", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_int output) {
      Vx.Core.Class_int outval = (Vx.Core.Class_int)output;
      outval.vx_p_constdef = constdef();
      outval.vxint = 0;
    }

  }

  public static Vx.Core.Type_int c_notanumber = new Vx.Core.Class_int();


  /**
   * Constant: nothing
   * Nothing Value. Opposite of every other value. e.g. Nil, Null
   * {string}
   */
  public class Const_nothing {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "nothing", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_string output) {
      Vx.Core.Class_string outval = (Vx.Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "nothing";
    }

  }

  public static Vx.Core.Type_string c_nothing = new Vx.Core.Class_string();


  /**
   * Constant: path-test-resources
   * The test path from project file
   * {string}
   */
  public class Const_path_test_resources {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "path-test-resources", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_string output) {
      Vx.Core.Class_string outval = (Vx.Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "test/resources";
    }

  }

  public static Vx.Core.Type_string c_path_test_resources = new Vx.Core.Class_string();


  /**
   * Constant: quote
   * Quotation mark constant
   * {string}
   */
  public class Const_quote {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "quote", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_string output) {
      Vx.Core.Class_string outval = (Vx.Core.Class_string)output;
      outval.vx_p_constdef = constdef();
      outval.vxstring = "\"";
    }

  }

  public static Vx.Core.Type_string c_quote = new Vx.Core.Class_string();


  /**
   * Constant: true
   * {boolean}
   */
  public class Const_true {
    public static Vx.Core.Type_constdef constdef() {
      Vx.Core.Type_constdef output = Vx.Core.constdef_new(
        "vx/core", // pkgname
        "true", // name
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        )
      );
      return output;
    }

    public static void const_new(Vx.Core.Type_boolean output) {
      Vx.Core.Class_boolean outval = (Vx.Core.Class_boolean)output;
      outval.vx_p_constdef = constdef();
      outval.vxboolean = true;
    }

  }

  public static Vx.Core.Type_boolean c_true = new Vx.Core.Class_boolean();

  /**
   * @function not
   * Boolean not
   * @param  {boolean} value Thing to not
   * @return {boolean}
   * (func !)
   */
  public interface Func_not : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_not(Vx.Core.Type_boolean value);
  }

  public class Class_not : Vx.Core.Class_base, Func_not {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_not output = new Vx.Core.Class_not();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_not output = new Vx.Core.Class_not();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "!", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_not;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_not;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_boolean inputval = (Vx.Core.Type_boolean)value;
      Vx.Core.Type_any outputval = Vx.Core.f_not(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_boolean value = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_not(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_not(Vx.Core.Type_boolean value) {
      Vx.Core.Type_boolean output = Vx.Core.f_not(value);
      return output;
    }

  }

  public static Vx.Core.Func_not e_not = new Vx.Core.Class_not();
  public static Vx.Core.Func_not t_not = new Vx.Core.Class_not();

  public static Vx.Core.Type_boolean f_not(Vx.Core.Type_boolean value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.vx_new_boolean(!value.vx_boolean());
    return output;
  }

  /**
   * @function notempty
   * Returns true if text is not empty.
   * @param  {string} text
   * @return {boolean}
   * (func !-empty)
   */
  public interface Func_notempty : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_notempty(Vx.Core.Type_string text);
  }

  public class Class_notempty : Vx.Core.Class_base, Func_notempty {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_notempty output = new Vx.Core.Class_notempty();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_notempty output = new Vx.Core.Class_notempty();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_notempty;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_notempty;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_notempty(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_notempty(text);
      return output;
    }

    public Vx.Core.Type_boolean vx_notempty(Vx.Core.Type_string text) {
      Vx.Core.Type_boolean output = Vx.Core.f_notempty(text);
      return output;
    }

  }

  public static Vx.Core.Func_notempty e_notempty = new Vx.Core.Class_notempty();
  public static Vx.Core.Func_notempty t_notempty = new Vx.Core.Class_notempty();

  public static Vx.Core.Type_boolean f_notempty(Vx.Core.Type_string text) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_is_empty(
        text
      )
    );
    return output;
  }

  /**
   * @function notempty 1
   * Returns true if value is not empty.
   * @param  {any} value
   * @return {boolean}
   * (func !-empty)
   */
  public interface Func_notempty_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_notempty_1(Vx.Core.Type_any value);
  }

  public class Class_notempty_1 : Vx.Core.Class_base, Func_notempty_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_notempty_1 output = new Vx.Core.Class_notempty_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_notempty_1 output = new Vx.Core.Class_notempty_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_notempty_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_notempty_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_notempty_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_notempty_1(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_notempty_1(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_notempty_1(value);
      return output;
    }

  }

  public static Vx.Core.Func_notempty_1 e_notempty_1 = new Vx.Core.Class_notempty_1();
  public static Vx.Core.Func_notempty_1 t_notempty_1 = new Vx.Core.Class_notempty_1();

  public static Vx.Core.Type_boolean f_notempty_1(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_is_empty_1(
        value
      )
    );
    return output;
  }

  /**
   * @function ne
   * Returns true if the first arg is not equal to any of the other arg.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func !=)
   */
  public interface Func_ne : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_ne(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_ne : Vx.Core.Class_base, Func_ne {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_ne output = new Vx.Core.Class_ne();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_ne output = new Vx.Core.Class_ne();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "!=", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_ne;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_ne;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_ne(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_ne(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_ne(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_ne e_ne = new Vx.Core.Class_ne();
  public static Vx.Core.Func_ne t_ne = new Vx.Core.Class_ne();

  public static Vx.Core.Type_boolean f_ne(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_eq(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function neqeq
   * Returns true if the first arg is not strictly equal to any of the other arg.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func !==)
   */
  public interface Func_neqeq : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_neqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_neqeq : Vx.Core.Class_base, Func_neqeq {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_neqeq output = new Vx.Core.Class_neqeq();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_neqeq output = new Vx.Core.Class_neqeq();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "!==", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_neqeq;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_neqeq;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_neqeq(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_neqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_neqeq(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_neqeq e_neqeq = new Vx.Core.Class_neqeq();
  public static Vx.Core.Func_neqeq t_neqeq = new Vx.Core.Class_neqeq();

  public static Vx.Core.Type_boolean f_neqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_eqeq(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function multiply
   * Math int multiply
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func *)
   */
  public interface Func_multiply : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_int vx_multiply(Vx.Core.Type_int num1, Vx.Core.Type_int num2);
  }

  public class Class_multiply : Vx.Core.Class_base, Func_multiply {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_multiply output = new Vx.Core.Class_multiply();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_multiply output = new Vx.Core.Class_multiply();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_multiply;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_multiply;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_int num1 = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int num2 = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_multiply(num1, num2);
      return output;
    }

    public Vx.Core.Type_int vx_multiply(Vx.Core.Type_int num1, Vx.Core.Type_int num2) {
      Vx.Core.Type_int output = Vx.Core.f_multiply(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_multiply e_multiply = new Vx.Core.Class_multiply();
  public static Vx.Core.Func_multiply t_multiply = new Vx.Core.Class_multiply();

  public static Vx.Core.Type_int f_multiply(Vx.Core.Type_int num1, Vx.Core.Type_int num2) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    int result = num1.vx_int() * num2.vx_int();
    output = Vx.Core.vx_new_int(result);
    return output;
  }

  /**
   * @function multiply 1
   * Math multipy
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func *)
   */
  public interface Func_multiply_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_number vx_multiply_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2);
  }

  public class Class_multiply_1 : Vx.Core.Class_base, Func_multiply_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_multiply_1 output = new Vx.Core.Class_multiply_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_multiply_1 output = new Vx.Core.Class_multiply_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_multiply_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_multiply_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_number num1 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_number num2 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_multiply_1(num1, num2);
      return output;
    }

    public Vx.Core.Type_number vx_multiply_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
      Vx.Core.Type_number output = Vx.Core.f_multiply_1(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_multiply_1 e_multiply_1 = new Vx.Core.Class_multiply_1();
  public static Vx.Core.Func_multiply_1 t_multiply_1 = new Vx.Core.Class_multiply_1();

  public static Vx.Core.Type_number f_multiply_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    float result = Vx.Core.vx_float_from_number(num1) * Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);
    return output;
  }

  /**
   * @function multiply 2
   * Math multiply
   * @param  {intlist} nums
   * @return {int}
   * (func *)
   */
  public interface Func_multiply_2 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_multiply_2(Vx.Core.Type_intlist nums);
  }

  public class Class_multiply_2 : Vx.Core.Class_base, Func_multiply_2 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_multiply_2 output = new Vx.Core.Class_multiply_2();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_multiply_2 output = new Vx.Core.Class_multiply_2();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        2, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_multiply_2;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_multiply_2;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_intlist inputval = (Vx.Core.Type_intlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_multiply_2(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_intlist nums = Vx.Core.f_any_from_any(Vx.Core.t_intlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_multiply_2(nums);
      return output;
    }

    public Vx.Core.Type_int vx_multiply_2(Vx.Core.Type_intlist nums) {
      Vx.Core.Type_int output = Vx.Core.f_multiply_2(nums);
      return output;
    }

  }

  public static Vx.Core.Func_multiply_2 e_multiply_2 = new Vx.Core.Class_multiply_2();
  public static Vx.Core.Func_multiply_2 t_multiply_2 = new Vx.Core.Class_multiply_2();

  public static Vx.Core.Type_int f_multiply_2(Vx.Core.Type_intlist nums) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_any_from_list_start_reduce(
      Vx.Core.t_int,
      nums,
      Vx.Core.vx_new_int(1),
      Vx.Core.t_any_from_reduce.vx_fn_new((total_any, num_any) => {
        Vx.Core.Type_int total = Vx.Core.f_any_from_any(Vx.Core.t_int, total_any);
        Vx.Core.Type_int num = Vx.Core.f_any_from_any(Vx.Core.t_int, num_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_multiply(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function multiply 3
   * Math multiply
   * @param  {numberlist} nums
   * @return {number}
   * (func *)
   */
  public interface Func_multiply_3 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_number vx_multiply_3(Vx.Core.Type_numberlist nums);
  }

  public class Class_multiply_3 : Vx.Core.Class_base, Func_multiply_3 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_multiply_3 output = new Vx.Core.Class_multiply_3();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_multiply_3 output = new Vx.Core.Class_multiply_3();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        3, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_multiply_3;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_multiply_3;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_numberlist inputval = (Vx.Core.Type_numberlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_multiply_3(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_numberlist nums = Vx.Core.f_any_from_any(Vx.Core.t_numberlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_multiply_3(nums);
      return output;
    }

    public Vx.Core.Type_number vx_multiply_3(Vx.Core.Type_numberlist nums) {
      Vx.Core.Type_number output = Vx.Core.f_multiply_3(nums);
      return output;
    }

  }

  public static Vx.Core.Func_multiply_3 e_multiply_3 = new Vx.Core.Class_multiply_3();
  public static Vx.Core.Func_multiply_3 t_multiply_3 = new Vx.Core.Class_multiply_3();

  public static Vx.Core.Type_number f_multiply_3(Vx.Core.Type_numberlist nums) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    output = Vx.Core.f_any_from_list_start_reduce(
      Vx.Core.t_number,
      nums,
      Vx.Core.vx_new_int(1),
      Vx.Core.t_any_from_reduce.vx_fn_new((total_any, num_any) => {
        Vx.Core.Type_number total = Vx.Core.f_any_from_any(Vx.Core.t_number, total_any);
        Vx.Core.Type_number num = Vx.Core.f_any_from_any(Vx.Core.t_number, num_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_multiply_1(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function plus
   * Math int plus
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func +)
   */
  public interface Func_plus : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_int vx_plus(Vx.Core.Type_int num1, Vx.Core.Type_int num2);
  }

  public class Class_plus : Vx.Core.Class_base, Func_plus {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_plus output = new Vx.Core.Class_plus();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_plus output = new Vx.Core.Class_plus();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_plus;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_plus;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_int num1 = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int num2 = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_plus(num1, num2);
      return output;
    }

    public Vx.Core.Type_int vx_plus(Vx.Core.Type_int num1, Vx.Core.Type_int num2) {
      Vx.Core.Type_int output = Vx.Core.f_plus(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_plus e_plus = new Vx.Core.Class_plus();
  public static Vx.Core.Func_plus t_plus = new Vx.Core.Class_plus();

  public static Vx.Core.Type_int f_plus(Vx.Core.Type_int num1, Vx.Core.Type_int num2) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    int result = num1.vx_int() + num2.vx_int();
    output = Vx.Core.vx_new_int(result);
    return output;
  }

  /**
   * @function plus 1
   * Math number plus
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func +)
   */
  public interface Func_plus_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_number vx_plus_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2);
  }

  public class Class_plus_1 : Vx.Core.Class_base, Func_plus_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_plus_1 output = new Vx.Core.Class_plus_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_plus_1 output = new Vx.Core.Class_plus_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_plus_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_plus_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_number num1 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_number num2 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_plus_1(num1, num2);
      return output;
    }

    public Vx.Core.Type_number vx_plus_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
      Vx.Core.Type_number output = Vx.Core.f_plus_1(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_plus_1 e_plus_1 = new Vx.Core.Class_plus_1();
  public static Vx.Core.Func_plus_1 t_plus_1 = new Vx.Core.Class_plus_1();

  public static Vx.Core.Type_number f_plus_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    float result = Vx.Core.vx_float_from_number(num1) + Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);
    return output;
  }

  /**
   * @function plus 2
   * Math int plus
   * @param  {intlist} nums
   * @return {int}
   * (func +)
   */
  public interface Func_plus_2 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_plus_2(Vx.Core.Type_intlist nums);
  }

  public class Class_plus_2 : Vx.Core.Class_base, Func_plus_2 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_plus_2 output = new Vx.Core.Class_plus_2();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_plus_2 output = new Vx.Core.Class_plus_2();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        2, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_plus_2;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_plus_2;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_intlist inputval = (Vx.Core.Type_intlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_plus_2(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_intlist nums = Vx.Core.f_any_from_any(Vx.Core.t_intlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_plus_2(nums);
      return output;
    }

    public Vx.Core.Type_int vx_plus_2(Vx.Core.Type_intlist nums) {
      Vx.Core.Type_int output = Vx.Core.f_plus_2(nums);
      return output;
    }

  }

  public static Vx.Core.Func_plus_2 e_plus_2 = new Vx.Core.Class_plus_2();
  public static Vx.Core.Func_plus_2 t_plus_2 = new Vx.Core.Class_plus_2();

  public static Vx.Core.Type_int f_plus_2(Vx.Core.Type_intlist nums) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_any_from_list_start_reduce(
      Vx.Core.t_int,
      nums,
      Vx.Core.vx_new_int(0),
      Vx.Core.t_any_from_reduce.vx_fn_new((total_any, num_any) => {
        Vx.Core.Type_int total = Vx.Core.f_any_from_any(Vx.Core.t_int, total_any);
        Vx.Core.Type_int num = Vx.Core.f_any_from_any(Vx.Core.t_int, num_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_plus(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function plus 3
   * Math number plus
   * @param  {numberlist} nums
   * @return {number}
   * (func +)
   */
  public interface Func_plus_3 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_number vx_plus_3(Vx.Core.Type_numberlist nums);
  }

  public class Class_plus_3 : Vx.Core.Class_base, Func_plus_3 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_plus_3 output = new Vx.Core.Class_plus_3();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_plus_3 output = new Vx.Core.Class_plus_3();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        3, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_plus_3;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_plus_3;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_numberlist inputval = (Vx.Core.Type_numberlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_plus_3(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_numberlist nums = Vx.Core.f_any_from_any(Vx.Core.t_numberlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_plus_3(nums);
      return output;
    }

    public Vx.Core.Type_number vx_plus_3(Vx.Core.Type_numberlist nums) {
      Vx.Core.Type_number output = Vx.Core.f_plus_3(nums);
      return output;
    }

  }

  public static Vx.Core.Func_plus_3 e_plus_3 = new Vx.Core.Class_plus_3();
  public static Vx.Core.Func_plus_3 t_plus_3 = new Vx.Core.Class_plus_3();

  public static Vx.Core.Type_number f_plus_3(Vx.Core.Type_numberlist nums) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    output = Vx.Core.f_any_from_list_start_reduce(
      Vx.Core.t_number,
      nums,
      Vx.Core.vx_new_int(0),
      Vx.Core.t_any_from_reduce.vx_fn_new((total_any, num_any) => {
        Vx.Core.Type_number total = Vx.Core.f_any_from_any(Vx.Core.t_number, total_any);
        Vx.Core.Type_number num = Vx.Core.f_any_from_any(Vx.Core.t_number, num_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_plus_1(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function plus1
   * Math int plus 1
   * @param  {int} num
   * @return {int}
   * (func +1)
   */
  public interface Func_plus1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_plus1(Vx.Core.Type_int num);
  }

  public class Class_plus1 : Vx.Core.Class_base, Func_plus1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_plus1 output = new Vx.Core.Class_plus1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_plus1 output = new Vx.Core.Class_plus1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "+1", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_plus1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_plus1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_int inputval = (Vx.Core.Type_int)value;
      Vx.Core.Type_any outputval = Vx.Core.f_plus1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_int num = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_plus1(num);
      return output;
    }

    public Vx.Core.Type_int vx_plus1(Vx.Core.Type_int num) {
      Vx.Core.Type_int output = Vx.Core.f_plus1(num);
      return output;
    }

  }

  public static Vx.Core.Func_plus1 e_plus1 = new Vx.Core.Class_plus1();
  public static Vx.Core.Func_plus1 t_plus1 = new Vx.Core.Class_plus1();

  public static Vx.Core.Type_int f_plus1(Vx.Core.Type_int num) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_plus(
      num,
      Vx.Core.vx_new_int(1)
    );
    return output;
  }

  /**
   * @function minus
   * Math int minus
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func -)
   */
  public interface Func_minus : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_int vx_minus(Vx.Core.Type_int num1, Vx.Core.Type_int num2);
  }

  public class Class_minus : Vx.Core.Class_base, Func_minus {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_minus output = new Vx.Core.Class_minus();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_minus output = new Vx.Core.Class_minus();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_minus;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_minus;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_int num1 = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int num2 = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_minus(num1, num2);
      return output;
    }

    public Vx.Core.Type_int vx_minus(Vx.Core.Type_int num1, Vx.Core.Type_int num2) {
      Vx.Core.Type_int output = Vx.Core.f_minus(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_minus e_minus = new Vx.Core.Class_minus();
  public static Vx.Core.Func_minus t_minus = new Vx.Core.Class_minus();

  public static Vx.Core.Type_int f_minus(Vx.Core.Type_int num1, Vx.Core.Type_int num2) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    int result = num1.vx_int() - num2.vx_int();
    output = Vx.Core.vx_new_int(result);
    return output;
  }

  /**
   * @function minus 1
   * Math number minus
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func -)
   */
  public interface Func_minus_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_number vx_minus_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2);
  }

  public class Class_minus_1 : Vx.Core.Class_base, Func_minus_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_minus_1 output = new Vx.Core.Class_minus_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_minus_1 output = new Vx.Core.Class_minus_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_minus_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_minus_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_number num1 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_number num2 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_minus_1(num1, num2);
      return output;
    }

    public Vx.Core.Type_number vx_minus_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
      Vx.Core.Type_number output = Vx.Core.f_minus_1(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_minus_1 e_minus_1 = new Vx.Core.Class_minus_1();
  public static Vx.Core.Func_minus_1 t_minus_1 = new Vx.Core.Class_minus_1();

  public static Vx.Core.Type_number f_minus_1(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    float result = Vx.Core.vx_float_from_number(num1) - Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);
    return output;
  }

  /**
   * @function minus 2
   * Math integer minus
   * @param  {intlist} nums
   * @return {int}
   * (func -)
   */
  public interface Func_minus_2 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_minus_2(Vx.Core.Type_intlist nums);
  }

  public class Class_minus_2 : Vx.Core.Class_base, Func_minus_2 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_minus_2 output = new Vx.Core.Class_minus_2();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_minus_2 output = new Vx.Core.Class_minus_2();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        2, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_minus_2;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_minus_2;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_intlist inputval = (Vx.Core.Type_intlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_minus_2(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_intlist nums = Vx.Core.f_any_from_any(Vx.Core.t_intlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_minus_2(nums);
      return output;
    }

    public Vx.Core.Type_int vx_minus_2(Vx.Core.Type_intlist nums) {
      Vx.Core.Type_int output = Vx.Core.f_minus_2(nums);
      return output;
    }

  }

  public static Vx.Core.Func_minus_2 e_minus_2 = new Vx.Core.Class_minus_2();
  public static Vx.Core.Func_minus_2 t_minus_2 = new Vx.Core.Class_minus_2();

  public static Vx.Core.Type_int f_minus_2(Vx.Core.Type_intlist nums) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_any_from_list_start_reduce(
      Vx.Core.t_int,
      nums,
      Vx.Core.vx_new_int(0),
      Vx.Core.t_any_from_reduce.vx_fn_new((total_any, num_any) => {
        Vx.Core.Type_int total = Vx.Core.f_any_from_any(Vx.Core.t_int, total_any);
        Vx.Core.Type_int num = Vx.Core.f_any_from_any(Vx.Core.t_int, num_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_minus(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function minus 3
   * Math number minus
   * @param  {numberlist} nums
   * @return {number}
   * (func -)
   */
  public interface Func_minus_3 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_number vx_minus_3(Vx.Core.Type_numberlist nums);
  }

  public class Class_minus_3 : Vx.Core.Class_base, Func_minus_3 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_minus_3 output = new Vx.Core.Class_minus_3();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_minus_3 output = new Vx.Core.Class_minus_3();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        3, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_minus_3;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_minus_3;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_numberlist inputval = (Vx.Core.Type_numberlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_minus_3(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_numberlist nums = Vx.Core.f_any_from_any(Vx.Core.t_numberlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_minus_3(nums);
      return output;
    }

    public Vx.Core.Type_number vx_minus_3(Vx.Core.Type_numberlist nums) {
      Vx.Core.Type_number output = Vx.Core.f_minus_3(nums);
      return output;
    }

  }

  public static Vx.Core.Func_minus_3 e_minus_3 = new Vx.Core.Class_minus_3();
  public static Vx.Core.Func_minus_3 t_minus_3 = new Vx.Core.Class_minus_3();

  public static Vx.Core.Type_number f_minus_3(Vx.Core.Type_numberlist nums) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    output = Vx.Core.f_any_from_list_start_reduce(
      Vx.Core.t_number,
      nums,
      Vx.Core.vx_new_int(0),
      Vx.Core.t_any_from_reduce.vx_fn_new((total_any, num_any) => {
        Vx.Core.Type_number total = Vx.Core.f_any_from_any(Vx.Core.t_number, total_any);
        Vx.Core.Type_number num = Vx.Core.f_any_from_any(Vx.Core.t_number, num_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_minus_1(
          total,
          num
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function minus1
   * Math int minus 1
   * @param  {int} num
   * @return {int}
   * (func -1)
   */
  public interface Func_minus1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_minus1(Vx.Core.Type_int num);
  }

  public class Class_minus1 : Vx.Core.Class_base, Func_minus1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_minus1 output = new Vx.Core.Class_minus1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_minus1 output = new Vx.Core.Class_minus1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "-1", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_minus1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_minus1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_int inputval = (Vx.Core.Type_int)value;
      Vx.Core.Type_any outputval = Vx.Core.f_minus1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_int num = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_minus1(num);
      return output;
    }

    public Vx.Core.Type_int vx_minus1(Vx.Core.Type_int num) {
      Vx.Core.Type_int output = Vx.Core.f_minus1(num);
      return output;
    }

  }

  public static Vx.Core.Func_minus1 e_minus1 = new Vx.Core.Class_minus1();
  public static Vx.Core.Func_minus1 t_minus1 = new Vx.Core.Class_minus1();

  public static Vx.Core.Type_int f_minus1(Vx.Core.Type_int num) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_minus(
      num,
      Vx.Core.vx_new_int(1)
    );
    return output;
  }

  /**
   * @function dotmethod
   * Not Recommened: Support for Object Oriented dot notation. e.g. (this.foo 'a') = this.foo('a')
   * @param  {any} target
   * @param  {string} method
   * @param  {anylist} parameters
   * @return {any}
   * (func .)
   */
  public interface Func_dotmethod : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_any vx_dotmethod(Vx.Core.Type_any target, Vx.Core.Type_string method, Vx.Core.Type_anylist parameters);
  }

  public class Class_dotmethod : Vx.Core.Class_base, Func_dotmethod {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_dotmethod output = new Vx.Core.Class_dotmethod();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_dotmethod output = new Vx.Core.Class_dotmethod();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        ".", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_dotmethod;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_dotmethod;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any target = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string method = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_anylist parameters = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_dotmethod(target, method, parameters);
      return output;
    }

    public Vx.Core.Type_any vx_dotmethod(Vx.Core.Type_any target, Vx.Core.Type_string method, Vx.Core.Type_anylist parameters) {
      Vx.Core.Type_any output = Vx.Core.f_dotmethod(target, method, parameters);
      return output;
    }

  }

  public static Vx.Core.Func_dotmethod e_dotmethod = new Vx.Core.Class_dotmethod();
  public static Vx.Core.Func_dotmethod t_dotmethod = new Vx.Core.Class_dotmethod();

  public static Vx.Core.Type_any f_dotmethod(Vx.Core.Type_any target, Vx.Core.Type_string method, Vx.Core.Type_anylist parameters) {
    Vx.Core.Type_any output = Vx.Core.e_any;
    return output;
  }

  /**
   * @function divide
   * Math divide
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func /)
   */
  public interface Func_divide : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_number vx_divide(Vx.Core.Type_number num1, Vx.Core.Type_number num2);
  }

  public class Class_divide : Vx.Core.Class_base, Func_divide {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_divide output = new Vx.Core.Class_divide();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_divide output = new Vx.Core.Class_divide();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "/", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_divide;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_divide;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_number num1 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_number num2 = Vx.Core.f_any_from_any(Vx.Core.t_number, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_divide(num1, num2);
      return output;
    }

    public Vx.Core.Type_number vx_divide(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
      Vx.Core.Type_number output = Vx.Core.f_divide(num1, num2);
      return output;
    }

  }

  public static Vx.Core.Func_divide e_divide = new Vx.Core.Class_divide();
  public static Vx.Core.Func_divide t_divide = new Vx.Core.Class_divide();

  public static Vx.Core.Type_number f_divide(Vx.Core.Type_number num1, Vx.Core.Type_number num2) {
    Vx.Core.Type_number output = Vx.Core.e_number;
    float float1 = Vx.Core.vx_float_from_number(num1);
    float float2 = Vx.Core.vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = Vx.Core.c_notanumber;
    } else {
      float result = float1 / float2;
      output = Vx.Core.vx_new_float(result);
    };
    return output;
  }

  /**
   * @function lt
   * Returns true if the first arg is less than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func <)
   */
  public interface Func_lt : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_lt(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_lt : Vx.Core.Class_base, Func_lt {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_lt output = new Vx.Core.Class_lt();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_lt output = new Vx.Core.Class_lt();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_lt;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_lt;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_lt(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_lt(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_lt(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_lt e_lt = new Vx.Core.Class_lt();
  public static Vx.Core.Func_lt t_lt = new Vx.Core.Class_lt();

  public static Vx.Core.Type_boolean f_lt(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_switch(
      Vx.Core.t_boolean,
      Vx.Core.f_compare(
        val1,
        val2
      ),
      Vx.Core.vx_new(
        Vx.Core.t_thenelselist,
        Vx.Core.f_case_1(
          Vx.Core.vx_new_int(-1),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_1 = Vx.Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Vx.Core.f_else(
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_2 = Vx.Core.vx_new_boolean(false);
            return output_2;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function lt 1
   * Returns true if the first arg is less than all of the other args
   * @param  {anylist} values
   * @return {boolean}
   * (func <)
   */
  public interface Func_lt_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_lt_1(Vx.Core.Type_anylist values);
  }

  public class Class_lt_1 : Vx.Core.Class_base, Func_lt_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_lt_1 output = new Vx.Core.Class_lt_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_lt_1 output = new Vx.Core.Class_lt_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_lt_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_lt_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_lt_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist values = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_lt_1(values);
      return output;
    }

    public Vx.Core.Type_boolean vx_lt_1(Vx.Core.Type_anylist values) {
      Vx.Core.Type_boolean output = Vx.Core.f_lt_1(values);
      return output;
    }

  }

  public static Vx.Core.Func_lt_1 e_lt_1 = new Vx.Core.Class_lt_1();
  public static Vx.Core.Func_lt_1 t_lt_1 = new Vx.Core.Class_lt_1();

  public static Vx.Core.Type_boolean f_lt_1(Vx.Core.Type_anylist values) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_any_from_list_start_reduce_next(
      Vx.Core.t_boolean,
      values,
      Vx.Core.vx_new_boolean(true),
      Vx.Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) => {
        Vx.Core.Type_boolean reduce = Vx.Core.f_any_from_any(Vx.Core.t_boolean, reduce_any);
        Vx.Core.Type_any current = Vx.Core.f_any_from_any(Vx.Core.t_any, current_any);
        Vx.Core.Type_any next = Vx.Core.f_any_from_any(Vx.Core.t_any, next_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_and(
          reduce,
          Vx.Core.f_lt(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function chainfirst
   * This is a special function that applies a value as the first argument for the first function.
   * The result is then used as the first argument on the next function, etc. Sometimes this
   * improves readability.
   * @param  {any-1} value
   * @param  {any<-anylist} fnlist
   * @return {any-1}
   * (func <-)
   */
  public interface Func_chainfirst : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_chainfirst<T>(T generic_any_1, T value, Vx.Core.Type_any_from_anylist fnlist) where T : Vx.Core.Type_any;
  }

  public class Class_chainfirst : Vx.Core.Class_base, Func_chainfirst {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_chainfirst output = new Vx.Core.Class_chainfirst();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_chainfirst output = new Vx.Core.Class_chainfirst();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "<-", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_chainfirst;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_chainfirst;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any_from_anylist fnlist = Vx.Core.f_any_from_any(Vx.Core.t_any_from_anylist, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_chainfirst(generic_any_1, value, fnlist);
      return output;
    }

    public T vx_chainfirst<T>(T generic_any_1, T value, Vx.Core.Type_any_from_anylist fnlist) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_chainfirst(generic_any_1, value, fnlist);
      return output;
    }

  }

  public static Vx.Core.Func_chainfirst e_chainfirst = new Vx.Core.Class_chainfirst();
  public static Vx.Core.Func_chainfirst t_chainfirst = new Vx.Core.Class_chainfirst();

  public static T f_chainfirst<T>(T generic_any_1, T value, Vx.Core.Type_any_from_anylist fnlist) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function chainlast
   * This is a special function that applies a value as the last argument for the first function.
   * The result is then used as the last argument on the next function, etc. Sometimes this
   * improves readability.
   * @param  {any-1} value
   * @param  {any<-anylist} fnlist
   * @return {any-1}
   * (func <<-)
   */
  public interface Func_chainlast : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_chainlast<T>(T generic_any_1, T value, Vx.Core.Type_any_from_anylist fnlist) where T : Vx.Core.Type_any;
  }

  public class Class_chainlast : Vx.Core.Class_base, Func_chainlast {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_chainlast output = new Vx.Core.Class_chainlast();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_chainlast output = new Vx.Core.Class_chainlast();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "<<-", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_chainlast;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_chainlast;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any_from_anylist fnlist = Vx.Core.f_any_from_any(Vx.Core.t_any_from_anylist, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_chainlast(generic_any_1, value, fnlist);
      return output;
    }

    public T vx_chainlast<T>(T generic_any_1, T value, Vx.Core.Type_any_from_anylist fnlist) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_chainlast(generic_any_1, value, fnlist);
      return output;
    }

  }

  public static Vx.Core.Func_chainlast e_chainlast = new Vx.Core.Class_chainlast();
  public static Vx.Core.Func_chainlast t_chainlast = new Vx.Core.Class_chainlast();

  public static T f_chainlast<T>(T generic_any_1, T value, Vx.Core.Type_any_from_anylist fnlist) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function le
   * Returns true if the first arg is less or equal than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func <=)
   */
  public interface Func_le : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_le(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_le : Vx.Core.Class_base, Func_le {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_le output = new Vx.Core.Class_le();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_le output = new Vx.Core.Class_le();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_le;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_le;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_le(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_le(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_le(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_le e_le = new Vx.Core.Class_le();
  public static Vx.Core.Func_le t_le = new Vx.Core.Class_le();

  public static Vx.Core.Type_boolean f_le(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_gt(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function le 1
   * Returns true if the first arg is less or equal than all of the other args
   * @param  {anylist} args
   * @return {boolean}
   * (func <=)
   */
  public interface Func_le_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_le_1(Vx.Core.Type_anylist args);
  }

  public class Class_le_1 : Vx.Core.Class_base, Func_le_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_le_1 output = new Vx.Core.Class_le_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_le_1 output = new Vx.Core.Class_le_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_le_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_le_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_le_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist args = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_le_1(args);
      return output;
    }

    public Vx.Core.Type_boolean vx_le_1(Vx.Core.Type_anylist args) {
      Vx.Core.Type_boolean output = Vx.Core.f_le_1(args);
      return output;
    }

  }

  public static Vx.Core.Func_le_1 e_le_1 = new Vx.Core.Class_le_1();
  public static Vx.Core.Func_le_1 t_le_1 = new Vx.Core.Class_le_1();

  public static Vx.Core.Type_boolean f_le_1(Vx.Core.Type_anylist args) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_gt_1(
        args
      )
    );
    return output;
  }

  /**
   * @function eq
   * Boolean equal/equivalent
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func =)
   */
  public interface Func_eq : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_eq(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_eq : Vx.Core.Class_base, Func_eq {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_eq output = new Vx.Core.Class_eq();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_eq output = new Vx.Core.Class_eq();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_eq;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_eq;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_eq(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_eq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_eq(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_eq e_eq = new Vx.Core.Class_eq();
  public static Vx.Core.Func_eq t_eq = new Vx.Core.Class_eq();

  public static Vx.Core.Type_boolean f_eq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Vx.Core.Type_string strval1 = Vx.Core.f_string_from_any(val1);
      Vx.Core.Type_string strval2 = Vx.Core.f_string_from_any(val2);
      if (strval1.vx_string() == (strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Vx.Core.vx_new_boolean(isequal);
    return output;
  }

  /**
   * @function eq 1
   * Boolean equal/equivalent
   * @param  {anylist} values
   * @return {boolean}
   * (func =)
   */
  public interface Func_eq_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_eq_1(Vx.Core.Type_anylist values);
  }

  public class Class_eq_1 : Vx.Core.Class_base, Func_eq_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_eq_1 output = new Vx.Core.Class_eq_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_eq_1 output = new Vx.Core.Class_eq_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_eq_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_eq_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_eq_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist values = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_eq_1(values);
      return output;
    }

    public Vx.Core.Type_boolean vx_eq_1(Vx.Core.Type_anylist values) {
      Vx.Core.Type_boolean output = Vx.Core.f_eq_1(values);
      return output;
    }

  }

  public static Vx.Core.Func_eq_1 e_eq_1 = new Vx.Core.Class_eq_1();
  public static Vx.Core.Func_eq_1 t_eq_1 = new Vx.Core.Class_eq_1();

  public static Vx.Core.Type_boolean f_eq_1(Vx.Core.Type_anylist values) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_any_from_list_start_reduce_next(
      Vx.Core.t_boolean,
      values,
      Vx.Core.vx_new_boolean(false),
      Vx.Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) => {
        Vx.Core.Type_boolean reduce = Vx.Core.f_any_from_any(Vx.Core.t_boolean, reduce_any);
        Vx.Core.Type_any current = Vx.Core.f_any_from_any(Vx.Core.t_any, current_any);
        Vx.Core.Type_any next = Vx.Core.f_any_from_any(Vx.Core.t_any, next_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_and(
          reduce,
          Vx.Core.f_eq(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function eqeq
   * Strict equality check. Note that all non-empty, non-constants will not be equal.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func ==)
   */
  public interface Func_eqeq : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_eqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_eqeq : Vx.Core.Class_base, Func_eqeq {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_eqeq output = new Vx.Core.Class_eqeq();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_eqeq output = new Vx.Core.Class_eqeq();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "==", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_eqeq;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_eqeq;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_eqeq(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_eqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_eqeq(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_eqeq e_eqeq = new Vx.Core.Class_eqeq();
  public static Vx.Core.Func_eqeq t_eqeq = new Vx.Core.Class_eqeq();

  public static Vx.Core.Type_boolean f_eqeq(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    bool isequal = Vx.Core.vx_eqeq(val1, val2);
    output = Vx.Core.vx_new_boolean(isequal);
    return output;
  }

  /**
   * @function gt
   * Returns true if the first arg is greater than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func >)
   */
  public interface Func_gt : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_gt(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_gt : Vx.Core.Class_base, Func_gt {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_gt output = new Vx.Core.Class_gt();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_gt output = new Vx.Core.Class_gt();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_gt;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_gt;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_gt(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_gt(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_gt(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_gt e_gt = new Vx.Core.Class_gt();
  public static Vx.Core.Func_gt t_gt = new Vx.Core.Class_gt();

  public static Vx.Core.Type_boolean f_gt(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_switch(
      Vx.Core.t_boolean,
      Vx.Core.f_compare(
        val1,
        val2
      ),
      Vx.Core.vx_new(
        Vx.Core.t_thenelselist,
        Vx.Core.f_case_1(
          Vx.Core.vx_new_int(1),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_1 = Vx.Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Vx.Core.f_else(
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_2 = Vx.Core.vx_new_boolean(false);
            return output_2;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function gt 1
   * Returns true if the first arg is greater than all of the other args
   * @param  {anylist} values
   * @return {boolean}
   * (func >)
   */
  public interface Func_gt_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_gt_1(Vx.Core.Type_anylist values);
  }

  public class Class_gt_1 : Vx.Core.Class_base, Func_gt_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_gt_1 output = new Vx.Core.Class_gt_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_gt_1 output = new Vx.Core.Class_gt_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_gt_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_gt_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_gt_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist values = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_gt_1(values);
      return output;
    }

    public Vx.Core.Type_boolean vx_gt_1(Vx.Core.Type_anylist values) {
      Vx.Core.Type_boolean output = Vx.Core.f_gt_1(values);
      return output;
    }

  }

  public static Vx.Core.Func_gt_1 e_gt_1 = new Vx.Core.Class_gt_1();
  public static Vx.Core.Func_gt_1 t_gt_1 = new Vx.Core.Class_gt_1();

  public static Vx.Core.Type_boolean f_gt_1(Vx.Core.Type_anylist values) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_any_from_list_start_reduce_next(
      Vx.Core.t_boolean,
      values,
      Vx.Core.vx_new_boolean(true),
      Vx.Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) => {
        Vx.Core.Type_boolean reduce = Vx.Core.f_any_from_any(Vx.Core.t_boolean, reduce_any);
        Vx.Core.Type_any current = Vx.Core.f_any_from_any(Vx.Core.t_any, current_any);
        Vx.Core.Type_any next = Vx.Core.f_any_from_any(Vx.Core.t_any, next_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_and(
          reduce,
          Vx.Core.f_gt(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function ge
   * Returns true if val1 is greater or equal to val2
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func >=)
   */
  public interface Func_ge : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_ge(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_ge : Vx.Core.Class_base, Func_ge {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_ge output = new Vx.Core.Class_ge();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_ge output = new Vx.Core.Class_ge();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_ge;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_ge;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_ge(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_ge(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_ge(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_ge e_ge = new Vx.Core.Class_ge();
  public static Vx.Core.Func_ge t_ge = new Vx.Core.Class_ge();

  public static Vx.Core.Type_boolean f_ge(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_lt(
        val1,
        val2
      )
    );
    return output;
  }

  /**
   * @function ge 1
   * Returns true if the first arg is greater or equal than all of the other args
   * @param  {anylist} args
   * @return {boolean}
   * (func >=)
   */
  public interface Func_ge_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_ge_1(Vx.Core.Type_anylist args);
  }

  public class Class_ge_1 : Vx.Core.Class_base, Func_ge_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_ge_1 output = new Vx.Core.Class_ge_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_ge_1 output = new Vx.Core.Class_ge_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_ge_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_ge_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_ge_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist args = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_ge_1(args);
      return output;
    }

    public Vx.Core.Type_boolean vx_ge_1(Vx.Core.Type_anylist args) {
      Vx.Core.Type_boolean output = Vx.Core.f_ge_1(args);
      return output;
    }

  }

  public static Vx.Core.Func_ge_1 e_ge_1 = new Vx.Core.Class_ge_1();
  public static Vx.Core.Func_ge_1 t_ge_1 = new Vx.Core.Class_ge_1();

  public static Vx.Core.Type_boolean f_ge_1(Vx.Core.Type_anylist args) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_not(
      Vx.Core.f_lt_1(
        args
      )
    );
    return output;
  }

  /**
   * @function allowfuncs_from_security
   * Returns allowfuncs from a given security.
   * @param  {security} security
   * @return {funclist}
   * (func allowfuncs<-security)
   */
  public interface Func_allowfuncs_from_security : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_funclist vx_allowfuncs_from_security(Vx.Core.Type_security security);
  }

  public class Class_allowfuncs_from_security : Vx.Core.Class_base, Func_allowfuncs_from_security {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_allowfuncs_from_security output = new Vx.Core.Class_allowfuncs_from_security();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_allowfuncs_from_security output = new Vx.Core.Class_allowfuncs_from_security();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "allowfuncs<-security", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "funclist", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_func), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_allowfuncs_from_security;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_allowfuncs_from_security;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_security inputval = (Vx.Core.Type_security)value;
      Vx.Core.Type_any outputval = Vx.Core.f_allowfuncs_from_security(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_security security = Vx.Core.f_any_from_any(Vx.Core.t_security, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_allowfuncs_from_security(security);
      return output;
    }

    public Vx.Core.Type_funclist vx_allowfuncs_from_security(Vx.Core.Type_security security) {
      Vx.Core.Type_funclist output = Vx.Core.f_allowfuncs_from_security(security);
      return output;
    }

  }

  public static Vx.Core.Func_allowfuncs_from_security e_allowfuncs_from_security = new Vx.Core.Class_allowfuncs_from_security();
  public static Vx.Core.Func_allowfuncs_from_security t_allowfuncs_from_security = new Vx.Core.Class_allowfuncs_from_security();

  public static Vx.Core.Type_funclist f_allowfuncs_from_security(Vx.Core.Type_security security) {
    Vx.Core.Type_funclist output = Vx.Core.e_funclist;
    output = security.allowfuncs();
    return output;
  }

  /**
   * @function allowtypenames_from_typedef
   * Return allow name list from type
   * @param  {typedef} vtypedef
   * @return {stringlist}
   * (func allowtypenames<-typedef)
   */
  public interface Func_allowtypenames_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_stringlist vx_allowtypenames_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_allowtypenames_from_typedef : Vx.Core.Class_base, Func_allowtypenames_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_allowtypenames_from_typedef output = new Vx.Core.Class_allowtypenames_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_allowtypenames_from_typedef output = new Vx.Core.Class_allowtypenames_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "allowtypenames<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_string), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_allowtypenames_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_allowtypenames_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_allowtypenames_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_allowtypenames_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_stringlist vx_allowtypenames_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_stringlist output = Vx.Core.f_allowtypenames_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_allowtypenames_from_typedef e_allowtypenames_from_typedef = new Vx.Core.Class_allowtypenames_from_typedef();
  public static Vx.Core.Func_allowtypenames_from_typedef t_allowtypenames_from_typedef = new Vx.Core.Class_allowtypenames_from_typedef();

  public static Vx.Core.Type_stringlist f_allowtypenames_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_stringlist output = Vx.Core.e_stringlist;
    output = Vx.Core.f_typenames_from_typelist(
      Vx.Core.f_allowtypes_from_typedef(
        vtypedef
      )
    );
    return output;
  }

  /**
   * @function allowtypes_from_typedef
   * Return allow type list from type
   * @param  {typedef} vtypedef
   * @return {typelist}
   * (func allowtypes<-typedef)
   */
  public interface Func_allowtypes_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_typelist vx_allowtypes_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_allowtypes_from_typedef : Vx.Core.Class_base, Func_allowtypes_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_allowtypes_from_typedef output = new Vx.Core.Class_allowtypes_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_allowtypes_from_typedef output = new Vx.Core.Class_allowtypes_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "allowtypes<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_allowtypes_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_allowtypes_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_allowtypes_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_allowtypes_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_typelist vx_allowtypes_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_typelist output = Vx.Core.f_allowtypes_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_allowtypes_from_typedef e_allowtypes_from_typedef = new Vx.Core.Class_allowtypes_from_typedef();
  public static Vx.Core.Func_allowtypes_from_typedef t_allowtypes_from_typedef = new Vx.Core.Class_allowtypes_from_typedef();

  public static Vx.Core.Type_typelist f_allowtypes_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_typelist output = Vx.Core.e_typelist;
    output = vtypedef.allowtypes();
    return output;
  }

  /**
   * @function and
   * Returns true if all values are true
   * @param  {boolean} val1
   * @param  {boolean} val2
   * @return {boolean}
   * (func and)
   */
  public interface Func_and : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_and(Vx.Core.Type_boolean val1, Vx.Core.Type_boolean val2);
  }

  public class Class_and : Vx.Core.Class_base, Func_and {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_and output = new Vx.Core.Class_and();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_and output = new Vx.Core.Class_and();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_and;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_and;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_boolean val1 = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_boolean val2 = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_and(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_and(Vx.Core.Type_boolean val1, Vx.Core.Type_boolean val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_and(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_and e_and = new Vx.Core.Class_and();
  public static Vx.Core.Func_and t_and = new Vx.Core.Class_and();

  public static Vx.Core.Type_boolean f_and(Vx.Core.Type_boolean val1, Vx.Core.Type_boolean val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    };
    return output;
  }

  /**
   * @function and 1
   * Returns true if all values are true
   * @param  {booleanlist} values
   * @return {boolean}
   * (func and)
   */
  public interface Func_and_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_and_1(Vx.Core.Type_booleanlist values);
  }

  public class Class_and_1 : Vx.Core.Class_base, Func_and_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_and_1 output = new Vx.Core.Class_and_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_and_1 output = new Vx.Core.Class_and_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_and_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_and_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_booleanlist inputval = (Vx.Core.Type_booleanlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_and_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_booleanlist values = Vx.Core.f_any_from_any(Vx.Core.t_booleanlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_and_1(values);
      return output;
    }

    public Vx.Core.Type_boolean vx_and_1(Vx.Core.Type_booleanlist values) {
      Vx.Core.Type_boolean output = Vx.Core.f_and_1(values);
      return output;
    }

  }

  public static Vx.Core.Func_and_1 e_and_1 = new Vx.Core.Class_and_1();
  public static Vx.Core.Func_and_1 t_and_1 = new Vx.Core.Class_and_1();

  public static Vx.Core.Type_boolean f_and_1(Vx.Core.Type_booleanlist values) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_switch(
      Vx.Core.t_boolean,
      Vx.Core.f_length_1(
        values
      ),
      Vx.Core.vx_new(
        Vx.Core.t_thenelselist,
        Vx.Core.f_case_1(
          Vx.Core.vx_new_int(0),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_1 = Vx.Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Vx.Core.f_case_1(
          Vx.Core.vx_new_int(1),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_2 = Vx.Core.f_any_from_list(
              Vx.Core.t_boolean,
              values,
              Vx.Core.vx_new_int(1)
            );
            return output_2;
          })
        ),
        Vx.Core.f_else(
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_3 = Vx.Core.f_any_from_list_start_reduce_next(
              Vx.Core.t_boolean,
              values,
              Vx.Core.vx_new_boolean(true),
              Vx.Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) => {
                Vx.Core.Type_boolean reduce = Vx.Core.f_any_from_any(Vx.Core.t_boolean, reduce_any);
                Vx.Core.Type_boolean current = Vx.Core.f_any_from_any(Vx.Core.t_boolean, current_any);
                Vx.Core.Type_boolean next = Vx.Core.f_any_from_any(Vx.Core.t_boolean, next_any);
                Vx.Core.Type_any output_4 = Vx.Core.f_and(
                  reduce,
                  Vx.Core.f_and(
                    current,
                    next
                  )
                );
                return output_4;
              })
            );
            return output_3;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function any_from_any
   * Function Type taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any)
   */
  public interface Func_any_from_any : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_any vx_fn_new(Class_any_from_any.IFn fn);
  }

  public class Class_any_from_any : Vx.Core.Class_base, Func_any_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_any output = new Vx.Core.Class_any_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_any output = new Vx.Core.Class_any_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_any;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_any value);

    public Class_any_from_any.IFn? fn = null;

    public Vx.Core.Func_any_from_any vx_fn_new(Class_any_from_any.IFn fn) {
      Vx.Core.Class_any_from_any output = new Vx.Core.Class_any_from_any();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_any_from_any(generic_any_1, value);
      return output;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_any.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(value);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_any e_any_from_any = new Vx.Core.Class_any_from_any();
  public static Vx.Core.Func_any_from_any t_any_from_any = new Vx.Core.Class_any_from_any();

  public static T f_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    if (value is T tval) {
      output = tval;
    };
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_any_async
   * Function Type taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-async)
   */
  public interface Func_any_from_any_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_any_async<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_any_async vx_fn_new(Class_any_from_any_async.IFn fn);
  }

  public class Class_any_from_any_async : Vx.Core.Class_base, Func_any_from_any_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_any_async output = new Vx.Core.Class_any_from_any_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_any_async output = new Vx.Core.Class_any_from_any_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_any_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_any_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn(Vx.Core.Type_any value);

    public Class_any_from_any_async.IFn? fn = null;

    public Vx.Core.Func_any_from_any_async vx_fn_new(Class_any_from_any_async.IFn fn) {
      Vx.Core.Class_any_from_any_async output = new Vx.Core.Class_any_from_any_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_any_async(generic_any_1, value);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_any_async<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_any_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal(value);
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_any_async e_any_from_any_async = new Vx.Core.Class_any_from_any_async();
  public static Vx.Core.Func_any_from_any_async t_any_from_any_async = new Vx.Core.Class_any_from_any_async();

  public static Task<T> f_any_from_any_async<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_any_context
   * Function Type taking any value any-2 and returning generic any-1 using context
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-context)
   */
  public interface Func_any_from_any_context : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_any_context vx_fn_new(Class_any_from_any_context.IFn fn);
  }

  public class Class_any_from_any_context : Vx.Core.Class_base, Func_any_from_any_context {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_any_context output = new Vx.Core.Class_any_from_any_context();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_any_context output = new Vx.Core.Class_any_from_any_context();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_any_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_any_context;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_context context, Vx.Core.Type_any value);

    public Class_any_from_any_context.IFn? fn = null;

    public Vx.Core.Func_any_from_any_context vx_fn_new(Class_any_from_any_context.IFn fn) {
      Vx.Core.Class_any_from_any_context output = new Vx.Core.Class_any_from_any_context();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_any_from_any_context(generic_any_1, context, value);
      return output;
    }

    public T vx_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_any_context.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(context, value);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_any_context e_any_from_any_context = new Vx.Core.Class_any_from_any_context();
  public static Vx.Core.Func_any_from_any_context t_any_from_any_context = new Vx.Core.Class_any_from_any_context();

  public static T f_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    if (value is T tval) {
      output = tval;
    };
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_any_context_async
   * Generic Function taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-context-async)
   */
  public interface Func_any_from_any_context_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_any_context_async<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_any_context_async vx_fn_new(Class_any_from_any_context_async.IFn fn);
  }

  public class Class_any_from_any_context_async : Vx.Core.Class_base, Func_any_from_any_context_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_any_context_async output = new Vx.Core.Class_any_from_any_context_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_any_context_async output = new Vx.Core.Class_any_from_any_context_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_any_context_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_any_context_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn(Vx.Core.Type_context context, Vx.Core.Type_any value);

    public Class_any_from_any_context_async.IFn? fn = null;

    public Vx.Core.Func_any_from_any_context_async vx_fn_new(Class_any_from_any_context_async.IFn fn) {
      Vx.Core.Class_any_from_any_context_async output = new Vx.Core.Class_any_from_any_context_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_any_context_async(generic_any_1, context, value);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_any_context_async<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_any_context_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal(context, value);
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_any_context_async e_any_from_any_context_async = new Vx.Core.Class_any_from_any_context_async();
  public static Vx.Core.Func_any_from_any_context_async t_any_from_any_context_async = new Vx.Core.Class_any_from_any_context_async();

  public static Task<T> f_any_from_any_context_async<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_any_key_value
   * Generic Function returning Generic any-1 from a any-1, a key, and a value.
   * @param  {any-1} current
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-key-value)
   */
  public interface Func_any_from_any_key_value : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_any_key_value<T, U>(T generic_any_1, T current, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_any_key_value vx_fn_new(Class_any_from_any_key_value.IFn fn);
  }

  public class Class_any_from_any_key_value : Vx.Core.Class_base, Func_any_from_any_key_value {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_any_key_value output = new Vx.Core.Class_any_from_any_key_value();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_any_key_value output = new Vx.Core.Class_any_from_any_key_value();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-key-value", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_any_key_value;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_any_key_value;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_any current, Vx.Core.Type_string key, Vx.Core.Type_any value);

    public Class_any_from_any_key_value.IFn? fn = null;

    public Vx.Core.Func_any_from_any_key_value vx_fn_new(Class_any_from_any_key_value.IFn fn) {
      Vx.Core.Class_any_from_any_key_value output = new Vx.Core.Class_any_from_any_key_value();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any current = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_any_from_any_key_value(generic_any_1, current, key, value);
      return output;
    }

    public T vx_any_from_any_key_value<T, U>(T generic_any_1, T current, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_any_key_value.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(current, key, value);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_any_key_value e_any_from_any_key_value = new Vx.Core.Class_any_from_any_key_value();
  public static Vx.Core.Func_any_from_any_key_value t_any_from_any_key_value = new Vx.Core.Class_any_from_any_key_value();

  public static T f_any_from_any_key_value<T, U>(T generic_any_1, T current, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function any_from_func
   * Generic Function returning Generic any-1 with any parameters
   * @return {any-1}
   * (func any<-func)
   */
  public interface Func_any_from_func : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_func<T>(T generic_any_1) where T : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public class Class_any_from_func : Vx.Core.Class_base, Func_any_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_func output = new Vx.Core.Class_any_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_func output = new Vx.Core.Class_any_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_func;
      return output;
    }

    public delegate Vx.Core.Type_any IFn();

    public Class_any_from_func.IFn? fn = null;

    public Vx.Core.Func_any_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Vx.Core.Class_any_from_func output = new Vx.Core.Class_any_from_func();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_any_from_func(generic_any_1);
      return output;
    }

    public T vx_any_from_func<T>(T generic_any_1) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_func.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal();
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_func e_any_from_func = new Vx.Core.Class_any_from_func();
  public static Vx.Core.Func_any_from_func t_any_from_func = new Vx.Core.Class_any_from_func();

  public static T f_any_from_func<T>(T generic_any_1) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_func_async
   * Generic Function returning Generic any-1 with any parameters
   * @return {any-1}
   * (func any<-func-async)
   */
  public interface Func_any_from_func_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_func_async<T>(T generic_any_1) where T : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_func_async vx_fn_new(Class_any_from_func_async.IFn fn);
  }

  public class Class_any_from_func_async : Vx.Core.Class_base, Func_any_from_func_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_func_async output = new Vx.Core.Class_any_from_func_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_func_async output = new Vx.Core.Class_any_from_func_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-func-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_func_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_func_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn();

    public Class_any_from_func_async.IFn? fn = null;

    public Vx.Core.Func_any_from_func_async vx_fn_new(Class_any_from_func_async.IFn fn) {
      Vx.Core.Class_any_from_func_async output = new Vx.Core.Class_any_from_func_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_func_async(generic_any_1);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_func_async<T>(T generic_any_1) where T : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_func_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal();
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_func_async e_any_from_func_async = new Vx.Core.Class_any_from_func_async();
  public static Vx.Core.Func_any_from_func_async t_any_from_func_async = new Vx.Core.Class_any_from_func_async();

  public static Task<T> f_any_from_func_async<T>(T generic_any_1) where T : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_int
   * Generic Function returning Generic any-1 from an int
   * @param  {int} value
   * @return {any-1}
   * (func any<-int)
   */
  public interface Func_any_from_int : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_int<T>(T generic_any_1, Vx.Core.Type_int value) where T : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_int vx_fn_new(Class_any_from_int.IFn fn);
  }

  public class Class_any_from_int : Vx.Core.Class_base, Func_any_from_int {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_int output = new Vx.Core.Class_any_from_int();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_int output = new Vx.Core.Class_any_from_int();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-int", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_int;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_int;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_int value);

    public Class_any_from_int.IFn? fn = null;

    public Vx.Core.Func_any_from_int vx_fn_new(Class_any_from_int.IFn fn) {
      Vx.Core.Class_any_from_int output = new Vx.Core.Class_any_from_int();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int value = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_any_from_int(generic_any_1, value);
      return output;
    }

    public T vx_any_from_int<T>(T generic_any_1, Vx.Core.Type_int value) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_int.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(value);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_int e_any_from_int = new Vx.Core.Class_any_from_int();
  public static Vx.Core.Func_any_from_int t_any_from_int = new Vx.Core.Class_any_from_int();

  public static T f_any_from_int<T>(T generic_any_1, Vx.Core.Type_int value) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function any_from_int_any
   * Generic Function returning Generic any-1 from an int and a value
   * @param  {int} num
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-int-any)
   */
  public interface Func_any_from_int_any : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_int_any<T, U>(T generic_any_1, Vx.Core.Type_int num, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_int_any vx_fn_new(Class_any_from_int_any.IFn fn);
  }

  public class Class_any_from_int_any : Vx.Core.Class_base, Func_any_from_int_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_int_any output = new Vx.Core.Class_any_from_int_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_int_any output = new Vx.Core.Class_any_from_int_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-int-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_int_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_int_any;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_int num, Vx.Core.Type_any value);

    public Class_any_from_int_any.IFn? fn = null;

    public Vx.Core.Func_any_from_int_any vx_fn_new(Class_any_from_int_any.IFn fn) {
      Vx.Core.Class_any_from_int_any output = new Vx.Core.Class_any_from_int_any();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int num = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_any_from_int_any(generic_any_1, num, value);
      return output;
    }

    public T vx_any_from_int_any<T, U>(T generic_any_1, Vx.Core.Type_int num, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_int_any.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(num, value);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_int_any e_any_from_int_any = new Vx.Core.Class_any_from_int_any();
  public static Vx.Core.Func_any_from_int_any t_any_from_int_any = new Vx.Core.Class_any_from_int_any();

  public static T f_any_from_int_any<T, U>(T generic_any_1, Vx.Core.Type_int num, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function any_from_key_value
   * Generic Function returning Generic any-1 from a key and a value
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-key-value)
   */
  public interface Func_any_from_key_value : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_key_value<T, U>(T generic_any_1, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_key_value vx_fn_new(Class_any_from_key_value.IFn fn);
  }

  public class Class_any_from_key_value : Vx.Core.Class_base, Func_any_from_key_value {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_key_value output = new Vx.Core.Class_any_from_key_value();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_key_value output = new Vx.Core.Class_any_from_key_value();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_key_value;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_key_value;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_string key, Vx.Core.Type_any value);

    public Class_any_from_key_value.IFn? fn = null;

    public Vx.Core.Func_any_from_key_value vx_fn_new(Class_any_from_key_value.IFn fn) {
      Vx.Core.Class_any_from_key_value output = new Vx.Core.Class_any_from_key_value();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_any_from_key_value(generic_any_1, key, value);
      return output;
    }

    public T vx_any_from_key_value<T, U>(T generic_any_1, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_key_value.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(key, value);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_key_value e_any_from_key_value = new Vx.Core.Class_any_from_key_value();
  public static Vx.Core.Func_any_from_key_value t_any_from_key_value = new Vx.Core.Class_any_from_key_value();

  public static T f_any_from_key_value<T, U>(T generic_any_1, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_key_value_async
   * Generic Function returning Asynchronous Generic any-1 from a key and a value
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-key-value-async)
   */
  public interface Func_any_from_key_value_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_key_value_async<T, U>(T generic_any_1, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_key_value_async vx_fn_new(Class_any_from_key_value_async.IFn fn);
  }

  public class Class_any_from_key_value_async : Vx.Core.Class_base, Func_any_from_key_value_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_key_value_async output = new Vx.Core.Class_any_from_key_value_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_key_value_async output = new Vx.Core.Class_any_from_key_value_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_key_value_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_key_value_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn(Vx.Core.Type_string key, Vx.Core.Type_any value);

    public Class_any_from_key_value_async.IFn? fn = null;

    public Vx.Core.Func_any_from_key_value_async vx_fn_new(Class_any_from_key_value_async.IFn fn) {
      Vx.Core.Class_any_from_key_value_async output = new Vx.Core.Class_any_from_key_value_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_key_value_async(generic_any_1, key, value);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_key_value_async<T, U>(T generic_any_1, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_key_value_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal(key, value);
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_key_value_async e_any_from_key_value_async = new Vx.Core.Class_any_from_key_value_async();
  public static Vx.Core.Func_any_from_key_value_async t_any_from_key_value_async = new Vx.Core.Class_any_from_key_value_async();

  public static Task<T> f_any_from_key_value_async<T, U>(T generic_any_1, Vx.Core.Type_string key, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_list
   * Returns nth value from a list or none if out of bounds
   * @param  {list-1} values
   * @param  {int} index
   * @return {any-1}
   * (func any<-list)
   */
  public interface Func_any_from_list : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_list<T, X>(T generic_any_1, X values, Vx.Core.Type_int index) where T : Vx.Core.Type_any where X : Vx.Core.Type_list;
  }

  public class Class_any_from_list : Vx.Core.Class_base, Func_any_from_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_list output = new Vx.Core.Class_any_from_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_list output = new Vx.Core.Class_any_from_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_list;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int index = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_any_from_list(generic_any_1, values, index);
      return output;
    }

    public T vx_any_from_list<T, X>(T generic_any_1, X values, Vx.Core.Type_int index) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
      T output = Vx.Core.f_any_from_list(generic_any_1, values, index);
      return output;
    }

  }

  public static Vx.Core.Func_any_from_list e_any_from_list = new Vx.Core.Class_any_from_list();
  public static Vx.Core.Func_any_from_list t_any_from_list = new Vx.Core.Class_any_from_list();

  public static T f_any_from_list<T, X>(T generic_any_1, X values, Vx.Core.Type_int index) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    int intindex = index.vx_int();
    int intsize = values.vx_list().Count;
    if (intindex <= intsize) {
      List<Vx.Core.Type_any> listvalue = values.vx_list();
      Vx.Core.Type_any value = listvalue[intindex - 1];
      output = Vx.Core.f_any_from_any(generic_any_1, value);
    };
    return output;
  }

  /**
   * @function any_from_list_start_reduce
   * Returns a val from a list reduce operation
   * @param  {list-2} list
   * @param  {any-1} valstart
   * @param  {any<-reduce} fn-reduce
   * @return {any-1}
   * (func any<-list-start-reduce)
   */
  public interface Func_any_from_list_start_reduce : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_list_start_reduce<T, Y>(T generic_any_1, Y list, T valstart, Vx.Core.Func_any_from_reduce fn_reduce) where T : Vx.Core.Type_any where Y : Vx.Core.Type_list;
  }

  public class Class_any_from_list_start_reduce : Vx.Core.Class_base, Func_any_from_list_start_reduce {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_list_start_reduce output = new Vx.Core.Class_any_from_list_start_reduce();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_list_start_reduce output = new Vx.Core.Class_any_from_list_start_reduce();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_list_start_reduce;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_list_start_reduce;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list list = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any valstart = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Func_any_from_reduce fn_reduce = Vx.Core.f_any_from_any(Vx.Core.t_any_from_reduce, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
      return output;
    }

    public T vx_any_from_list_start_reduce<T, Y>(T generic_any_1, Y list, T valstart, Vx.Core.Func_any_from_reduce fn_reduce) where T : Vx.Core.Type_any where Y : Vx.Core.Type_list {
      T output = Vx.Core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
      return output;
    }

  }

  public static Vx.Core.Func_any_from_list_start_reduce e_any_from_list_start_reduce = new Vx.Core.Class_any_from_list_start_reduce();
  public static Vx.Core.Func_any_from_list_start_reduce t_any_from_list_start_reduce = new Vx.Core.Class_any_from_list_start_reduce();

  public static T f_any_from_list_start_reduce<T, Y>(T generic_any_1, Y list, T valstart, Vx.Core.Func_any_from_reduce fn_reduce) where T : Vx.Core.Type_any where Y : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.vx_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
    return output;
  }

  /**
   * @function any_from_list_start_reduce_next
   * Returns a val from a list reduce operation
   * @param  {list-2} list
   * @param  {any-1} valstart
   * @param  {any<-reduce-next} fn-reduce-next
   * @return {any-1}
   * (func any<-list-start-reduce-next)
   */
  public interface Func_any_from_list_start_reduce_next : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_list_start_reduce_next<T, Y>(T generic_any_1, Y list, T valstart, Vx.Core.Func_any_from_reduce_next fn_reduce_next) where T : Vx.Core.Type_any where Y : Vx.Core.Type_list;
  }

  public class Class_any_from_list_start_reduce_next : Vx.Core.Class_base, Func_any_from_list_start_reduce_next {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_list_start_reduce_next output = new Vx.Core.Class_any_from_list_start_reduce_next();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_list_start_reduce_next output = new Vx.Core.Class_any_from_list_start_reduce_next();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce-next", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_list_start_reduce_next;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_list_start_reduce_next;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list list = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any valstart = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Func_any_from_reduce_next fn_reduce_next = Vx.Core.f_any_from_any(Vx.Core.t_any_from_reduce_next, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next);
      return output;
    }

    public T vx_any_from_list_start_reduce_next<T, Y>(T generic_any_1, Y list, T valstart, Vx.Core.Func_any_from_reduce_next fn_reduce_next) where T : Vx.Core.Type_any where Y : Vx.Core.Type_list {
      T output = Vx.Core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next);
      return output;
    }

  }

  public static Vx.Core.Func_any_from_list_start_reduce_next e_any_from_list_start_reduce_next = new Vx.Core.Class_any_from_list_start_reduce_next();
  public static Vx.Core.Func_any_from_list_start_reduce_next t_any_from_list_start_reduce_next = new Vx.Core.Class_any_from_list_start_reduce_next();

  public static T f_any_from_list_start_reduce_next<T, Y>(T generic_any_1, Y list, T valstart, Vx.Core.Func_any_from_reduce_next fn_reduce_next) where T : Vx.Core.Type_any where Y : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.vx_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next);
    return output;
  }

  /**
   * @function any_from_map
   * Returns value from a map or empty if not found
   * @param  {map-1} valuemap
   * @param  {string} key
   * @return {any-1}
   * (func any<-map)
   */
  public interface Func_any_from_map : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_map<N, T>(T generic_any_1, N valuemap, Vx.Core.Type_string key) where N : Vx.Core.Type_map where T : Vx.Core.Type_any;
  }

  public class Class_any_from_map : Vx.Core.Class_base, Func_any_from_map {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_map output = new Vx.Core.Class_any_from_map();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_map output = new Vx.Core.Class_any_from_map();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-map", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_map;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_map;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_any_from_map(generic_any_1, valuemap, key);
      return output;
    }

    public T vx_any_from_map<N, T>(T generic_any_1, N valuemap, Vx.Core.Type_string key) where N : Vx.Core.Type_map where T : Vx.Core.Type_any {
      T output = Vx.Core.f_any_from_map(generic_any_1, valuemap, key);
      return output;
    }

  }

  public static Vx.Core.Func_any_from_map e_any_from_map = new Vx.Core.Class_any_from_map();
  public static Vx.Core.Func_any_from_map t_any_from_map = new Vx.Core.Class_any_from_map();

  public static T f_any_from_map<N, T>(T generic_any_1, N valuemap, Vx.Core.Type_string key) where N : Vx.Core.Type_map where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.vx_any_from_map(generic_any_1, valuemap, key);
    return output;
  }

  /**
   * @function any_from_map_start_reduce
   * Returns a value by reducing each element of a map.
   * @param  {map-1} map
   * @param  {any-1} start
   * @param  {any<-any-key-value} fn-reduce
   * @return {any-1}
   * (func any<-map-start-reduce)
   */
  public interface Func_any_from_map_start_reduce : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_map_start_reduce<N, T>(T generic_any_1, N map, T start, Vx.Core.Func_any_from_any_key_value fn_reduce) where N : Vx.Core.Type_map where T : Vx.Core.Type_any;
  }

  public class Class_any_from_map_start_reduce : Vx.Core.Class_base, Func_any_from_map_start_reduce {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_map_start_reduce output = new Vx.Core.Class_any_from_map_start_reduce();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_map_start_reduce output = new Vx.Core.Class_any_from_map_start_reduce();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-map-start-reduce", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_map_start_reduce;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_map_start_reduce;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map map = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any start = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Func_any_from_any_key_value fn_reduce = Vx.Core.f_any_from_any(Vx.Core.t_any_from_any_key_value, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
      return output;
    }

    public T vx_any_from_map_start_reduce<N, T>(T generic_any_1, N map, T start, Vx.Core.Func_any_from_any_key_value fn_reduce) where N : Vx.Core.Type_map where T : Vx.Core.Type_any {
      T output = Vx.Core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
      return output;
    }

  }

  public static Vx.Core.Func_any_from_map_start_reduce e_any_from_map_start_reduce = new Vx.Core.Class_any_from_map_start_reduce();
  public static Vx.Core.Func_any_from_map_start_reduce t_any_from_map_start_reduce = new Vx.Core.Class_any_from_map_start_reduce();

  public static T f_any_from_map_start_reduce<N, T>(T generic_any_1, N map, T start, Vx.Core.Func_any_from_any_key_value fn_reduce) where N : Vx.Core.Type_map where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.vx_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
    return output;
  }

  /**
   * @function any_from_none
   * Function Type returning Generic any-1 with no parameters
   * @return {any-1}
   * (func any<-none)
   */
  public interface Func_any_from_none : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_none<T>(T generic_any_1) where T : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_none vx_fn_new(Class_any_from_none.IFn fn);
  }

  public class Class_any_from_none : Vx.Core.Class_base, Func_any_from_none {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_none output = new Vx.Core.Class_any_from_none();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_none output = new Vx.Core.Class_any_from_none();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-none", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_none;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_none;
      return output;
    }

    public delegate Vx.Core.Type_any IFn();

    public Class_any_from_none.IFn? fn = null;

    public Vx.Core.Func_any_from_none vx_fn_new(Class_any_from_none.IFn fn) {
      Vx.Core.Class_any_from_none output = new Vx.Core.Class_any_from_none();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_any_from_none(generic_any_1);
      return output;
    }

    public T vx_any_from_none<T>(T generic_any_1) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_none.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal();
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_none e_any_from_none = new Vx.Core.Class_any_from_none();
  public static Vx.Core.Func_any_from_none t_any_from_none = new Vx.Core.Class_any_from_none();

  public static T f_any_from_none<T>(T generic_any_1) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_none_async
   * Function Type returning Generic any-1 with no parameters
   * @return {any-1}
   * (func any<-none-async)
   */
  public interface Func_any_from_none_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_none_async<T>(T generic_any_1) where T : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_none_async vx_fn_new(Class_any_from_none_async.IFn fn);
  }

  public class Class_any_from_none_async : Vx.Core.Class_base, Func_any_from_none_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_none_async output = new Vx.Core.Class_any_from_none_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_none_async output = new Vx.Core.Class_any_from_none_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-none-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_none_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_none_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn();

    public Class_any_from_none_async.IFn? fn = null;

    public Vx.Core.Func_any_from_none_async vx_fn_new(Class_any_from_none_async.IFn fn) {
      Vx.Core.Class_any_from_none_async output = new Vx.Core.Class_any_from_none_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_none_async(generic_any_1);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_none_async<T>(T generic_any_1) where T : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_none_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal();
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_none_async e_any_from_none_async = new Vx.Core.Class_any_from_none_async();
  public static Vx.Core.Func_any_from_none_async t_any_from_none_async = new Vx.Core.Class_any_from_none_async();

  public static Task<T> f_any_from_none_async<T>(T generic_any_1) where T : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_reduce
   * @param  {any-1} result
   * @param  {any-2} item
   * @return {any-1}
   * (func any<-reduce)
   */
  public interface Func_any_from_reduce : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_reduce<T, U>(T generic_any_1, T result, U item) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_reduce vx_fn_new(Class_any_from_reduce.IFn fn);
  }

  public class Class_any_from_reduce : Vx.Core.Class_base, Func_any_from_reduce {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_reduce output = new Vx.Core.Class_any_from_reduce();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_reduce output = new Vx.Core.Class_any_from_reduce();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_reduce;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_reduce;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_any result, Vx.Core.Type_any item);

    public Class_any_from_reduce.IFn? fn = null;

    public Vx.Core.Func_any_from_reduce vx_fn_new(Class_any_from_reduce.IFn fn) {
      Vx.Core.Class_any_from_reduce output = new Vx.Core.Class_any_from_reduce();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any result = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any item = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_any_from_reduce(generic_any_1, result, item);
      return output;
    }

    public T vx_any_from_reduce<T, U>(T generic_any_1, T result, U item) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_reduce.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(result, item);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_reduce e_any_from_reduce = new Vx.Core.Class_any_from_reduce();
  public static Vx.Core.Func_any_from_reduce t_any_from_reduce = new Vx.Core.Class_any_from_reduce();

  public static T f_any_from_reduce<T, U>(T generic_any_1, T result, U item) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_reduce_async
   * @param  {any-1} result
   * @param  {any-2} item
   * @return {any-1}
   * (func any<-reduce-async)
   */
  public interface Func_any_from_reduce_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_reduce_async<T, U>(T generic_any_1, T result, U item) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_reduce_async vx_fn_new(Class_any_from_reduce_async.IFn fn);
  }

  public class Class_any_from_reduce_async : Vx.Core.Class_base, Func_any_from_reduce_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_reduce_async output = new Vx.Core.Class_any_from_reduce_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_reduce_async output = new Vx.Core.Class_any_from_reduce_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_reduce_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_reduce_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn(Vx.Core.Type_any result, Vx.Core.Type_any item);

    public Class_any_from_reduce_async.IFn? fn = null;

    public Vx.Core.Func_any_from_reduce_async vx_fn_new(Class_any_from_reduce_async.IFn fn) {
      Vx.Core.Class_any_from_reduce_async output = new Vx.Core.Class_any_from_reduce_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any result = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any item = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_reduce_async(generic_any_1, result, item);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_reduce_async<T, U>(T generic_any_1, T result, U item) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_reduce_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal(result, item);
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_reduce_async e_any_from_reduce_async = new Vx.Core.Class_any_from_reduce_async();
  public static Vx.Core.Func_any_from_reduce_async t_any_from_reduce_async = new Vx.Core.Class_any_from_reduce_async();

  public static Task<T> f_any_from_reduce_async<T, U>(T generic_any_1, T result, U item) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_reduce_next
   * @param  {any-1} result
   * @param  {any-2} current
   * @param  {any-2} next
   * @return {any-1}
   * (func any<-reduce-next)
   */
  public interface Func_any_from_reduce_next : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_reduce_next<T, U>(T generic_any_1, T result, U current, U next) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_reduce_next vx_fn_new(Class_any_from_reduce_next.IFn fn);
  }

  public class Class_any_from_reduce_next : Vx.Core.Class_base, Func_any_from_reduce_next {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_reduce_next output = new Vx.Core.Class_any_from_reduce_next();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_reduce_next output = new Vx.Core.Class_any_from_reduce_next();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_reduce_next;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_reduce_next;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_any result, Vx.Core.Type_any current, Vx.Core.Type_any next);

    public Class_any_from_reduce_next.IFn? fn = null;

    public Vx.Core.Func_any_from_reduce_next vx_fn_new(Class_any_from_reduce_next.IFn fn) {
      Vx.Core.Class_any_from_reduce_next output = new Vx.Core.Class_any_from_reduce_next();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any result = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any current = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_any next = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_any_from_reduce_next(generic_any_1, result, current, next);
      return output;
    }

    public T vx_any_from_reduce_next<T, U>(T generic_any_1, T result, U current, U next) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Class_any_from_reduce_next.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(result, current, next);
        output = Vx.Core.f_any_from_any(generic_any_1, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_reduce_next e_any_from_reduce_next = new Vx.Core.Class_any_from_reduce_next();
  public static Vx.Core.Func_any_from_reduce_next t_any_from_reduce_next = new Vx.Core.Class_any_from_reduce_next();

  public static T f_any_from_reduce_next<T, U>(T generic_any_1, T result, U current, U next) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function any_from_reduce_next_async
   * @param  {any-1} result
   * @param  {any-2} current
   * @param  {any-2} next
   * @return {any-1}
   * (func any<-reduce-next-async)
   */
  public interface Func_any_from_reduce_next_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_any_from_reduce_next_async<T, U>(T generic_any_1, T result, U current, U next) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
    public Vx.Core.Func_any_from_reduce_next_async vx_fn_new(Class_any_from_reduce_next_async.IFn fn);
  }

  public class Class_any_from_reduce_next_async : Vx.Core.Class_base, Func_any_from_reduce_next_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_reduce_next_async output = new Vx.Core.Class_any_from_reduce_next_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_reduce_next_async output = new Vx.Core.Class_any_from_reduce_next_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_reduce_next_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_reduce_next_async;
      return output;
    }

    public delegate Task<Vx.Core.Type_any> IFn(Vx.Core.Type_any result, Vx.Core.Type_any current, Vx.Core.Type_any next);

    public Class_any_from_reduce_next_async.IFn? fn = null;

    public Vx.Core.Func_any_from_reduce_next_async vx_fn_new(Class_any_from_reduce_next_async.IFn fn) {
      Vx.Core.Class_any_from_reduce_next_async output = new Vx.Core.Class_any_from_reduce_next_async();
      output.fn = fn;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any result = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any current = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_any next = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(2)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_any_from_reduce_next_async(generic_any_1, result, current, next);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_any_from_reduce_next_async<T, U>(T generic_any_1, T result, U current, U next) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      Task<T> output;
      Class_any_from_reduce_next_async.IFn? fnlocal = this.fn;
      if (fnlocal == null) {
        output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
      } else {
        Task<Vx.Core.Type_any> future = fnlocal(result, current, next);
        output = Vx.Core.vx_async_from_async(generic_any_1, future);
      }
      return output;
    }

  }

  public static Vx.Core.Func_any_from_reduce_next_async e_any_from_reduce_next_async = new Vx.Core.Class_any_from_reduce_next_async();
  public static Vx.Core.Func_any_from_reduce_next_async t_any_from_reduce_next_async = new Vx.Core.Class_any_from_reduce_next_async();

  public static Task<T> f_any_from_reduce_next_async<T, U>(T generic_any_1, T result, U current, U next) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    return output;
  }

  /**
   * @function any_from_struct
   * Returns value from a struct
   * @param  {struct-2} vstruct
   * @param  {string} key
   * @return {any-1}
   * (func any<-struct)
   */
  public interface Func_any_from_struct : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_any_from_struct<R, T>(T generic_any_1, R vstruct, Vx.Core.Type_string key) where R : Vx.Core.Type_struct where T : Vx.Core.Type_any;
  }

  public class Class_any_from_struct : Vx.Core.Class_base, Func_any_from_struct {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_any_from_struct output = new Vx.Core.Class_any_from_struct();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_any_from_struct output = new Vx.Core.Class_any_from_struct();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "any<-struct", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_any_from_struct;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_any_from_struct;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_struct vstruct = Vx.Core.f_any_from_any(Vx.Core.t_struct, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_any_from_struct(generic_any_1, vstruct, key);
      return output;
    }

    public T vx_any_from_struct<R, T>(T generic_any_1, R vstruct, Vx.Core.Type_string key) where R : Vx.Core.Type_struct where T : Vx.Core.Type_any {
      T output = Vx.Core.f_any_from_struct(generic_any_1, vstruct, key);
      return output;
    }

  }

  public static Vx.Core.Func_any_from_struct e_any_from_struct = new Vx.Core.Class_any_from_struct();
  public static Vx.Core.Func_any_from_struct t_any_from_struct = new Vx.Core.Class_any_from_struct();

  public static T f_any_from_struct<R, T>(T generic_any_1, R vstruct, Vx.Core.Type_string key) where R : Vx.Core.Type_struct where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    Vx.Core.Type_any val = vstruct.vx_any(key);
    output = Vx.Core.f_any_from_any(generic_any_1, val);
    return output;
  }

  /**
   * 
   * @async
   * @function async
   * Returns an asynchonous version value. This exists mostly for type-casting.
   * @param  {any-1} value
   * @return {any-1}
   * (func async)
   */
  public interface Func_async : Vx.Core.Func_any_from_any_async {
    public Task<T> vx_async<T>(T generic_any_1, T value) where T : Vx.Core.Type_any;
  }

  public class Class_async : Vx.Core.Class_base, Func_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_async output = new Vx.Core.Class_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_async output = new Vx.Core.Class_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_async;
      return output;
    }

    public Vx.Core.Func_any_from_any_async vx_fn_new(Vx.Core.Class_any_from_any_async.IFn fn) {
      return Vx.Core.e_any_from_any_async;
    }

    public Task<T> vx_any_from_any_async<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T inputval = Vx.Core.f_any_from_any(generic_any_1, value);
      Task<T> output = Vx.Core.f_async(generic_any_1, inputval);
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_async(generic_any_1, value);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_async<T>(T generic_any_1, T value) where T : Vx.Core.Type_any {
      Task<T> output = Vx.Core.f_async(generic_any_1, value);
      return output;
    }

  }

  public static Vx.Core.Func_async e_async = new Vx.Core.Class_async();
  public static Vx.Core.Func_async t_async = new Vx.Core.Class_async();

  public static Task<T> f_async<T>(T generic_any_1, T value) where T : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    output = Vx.Core.vx_async_new_from_value(value);
    return output;
  }

  /**
   * @function boolean_permission_from_func
   * Returns true if the given func has permission.
   * @param  {func} func
   * @return {boolean}
   * (func boolean-permission<-func)
   */
  public interface Func_boolean_permission_from_func : Vx.Core.Func_any_from_any_context {
    public Vx.Core.Type_boolean vx_boolean_permission_from_func(Vx.Core.Type_context context, Vx.Core.Type_func func);
  }

  public class Class_boolean_permission_from_func : Vx.Core.Class_base, Func_boolean_permission_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_boolean_permission_from_func output = new Vx.Core.Class_boolean_permission_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_boolean_permission_from_func output = new Vx.Core.Class_boolean_permission_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "boolean-permission<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_boolean_permission_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_boolean_permission_from_func;
      return output;
    }

    public Vx.Core.Func_any_from_any_context vx_fn_new(Vx.Core.Class_any_from_any_context.IFn fn) {
      return Vx.Core.e_any_from_any_context;
    }

    public T vx_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_func inputval = (Vx.Core.Type_func)value;
      Vx.Core.Type_any outputval = Vx.Core.f_boolean_permission_from_func(context, inputval);
      output = Vx.Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_func func = Vx.Core.f_any_from_any(Vx.Core.t_func, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_boolean_permission_from_func(context, func);
      return output;
    }

    public Vx.Core.Type_boolean vx_boolean_permission_from_func(Vx.Core.Type_context context, Vx.Core.Type_func func) {
      Vx.Core.Type_boolean output = Vx.Core.f_boolean_permission_from_func(context, func);
      return output;
    }

  }

  public static Vx.Core.Func_boolean_permission_from_func e_boolean_permission_from_func = new Vx.Core.Class_boolean_permission_from_func();
  public static Vx.Core.Func_boolean_permission_from_func t_boolean_permission_from_func = new Vx.Core.Class_boolean_permission_from_func();

  public static Vx.Core.Type_boolean f_boolean_permission_from_func(Vx.Core.Type_context context, Vx.Core.Type_func func) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_contains_1(
      Vx.Core.f_allowfuncs_from_security(
        Vx.Core.f_security_from_context(
          context
        )
      ),
      func
    );
    return output;
  }

  /**
   * @function boolean_write_from_map_name_value
   * Returns true if it alters a mutable map false if it fails.
   * @param  {map-1} valuemap
   * @param  {string} name
   * @param  {any-1} value
   * @return {boolean}
   * (func boolean-write<-map-name-value)
   */
  public interface Func_boolean_write_from_map_name_value : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_boolean_write_from_map_name_value(Vx.Core.Type_map valuemap, Vx.Core.Type_string name, Vx.Core.Type_any value);
  }

  public class Class_boolean_write_from_map_name_value : Vx.Core.Class_base, Func_boolean_write_from_map_name_value {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_boolean_write_from_map_name_value output = new Vx.Core.Class_boolean_write_from_map_name_value();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_boolean_write_from_map_name_value output = new Vx.Core.Class_boolean_write_from_map_name_value();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "boolean-write<-map-name-value", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_boolean_write_from_map_name_value;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_boolean_write_from_map_name_value;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string name = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_boolean_write_from_map_name_value(valuemap, name, value);
      return output;
    }

    public Vx.Core.Type_boolean vx_boolean_write_from_map_name_value(Vx.Core.Type_map valuemap, Vx.Core.Type_string name, Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_boolean_write_from_map_name_value(valuemap, name, value);
      return output;
    }

  }

  public static Vx.Core.Func_boolean_write_from_map_name_value e_boolean_write_from_map_name_value = new Vx.Core.Class_boolean_write_from_map_name_value();
  public static Vx.Core.Func_boolean_write_from_map_name_value t_boolean_write_from_map_name_value = new Vx.Core.Class_boolean_write_from_map_name_value();

  public static Vx.Core.Type_boolean f_boolean_write_from_map_name_value(Vx.Core.Type_map valuemap, Vx.Core.Type_string name, Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.vx_boolean_write_from_map_name_value(valuemap, name, value);
    return output;
  }

  /**
   * @function boolean_from_any
   * Function Type taking generic any-1 and returning boolean
   * @param  {any-1} value
   * @return {boolean}
   * (func boolean<-any)
   */
  public interface Func_boolean_from_any : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_boolean_from_any(Vx.Core.Type_any value);
    public Vx.Core.Func_boolean_from_any vx_fn_new(Class_boolean_from_any.IFn fn);
  }

  public class Class_boolean_from_any : Vx.Core.Class_base, Func_boolean_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_boolean_from_any output = new Vx.Core.Class_boolean_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_boolean_from_any output = new Vx.Core.Class_boolean_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_boolean_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_boolean_from_any;
      return output;
    }

    public delegate Vx.Core.Type_any IFn(Vx.Core.Type_any value);

    public Class_boolean_from_any.IFn? fn = null;

    public Vx.Core.Func_boolean_from_any vx_fn_new(Class_boolean_from_any.IFn fn) {
      Vx.Core.Class_boolean_from_any output = new Vx.Core.Class_boolean_from_any();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_boolean_from_any(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_boolean_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      Class_boolean_from_any.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal(value);
        output = Vx.Core.f_any_from_any(Vx.Core.t_boolean, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_boolean_from_any e_boolean_from_any = new Vx.Core.Class_boolean_from_any();
  public static Vx.Core.Func_boolean_from_any t_boolean_from_any = new Vx.Core.Class_boolean_from_any();

  public static Vx.Core.Type_boolean f_boolean_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    return output;
  }

  /**
   * @function boolean_from_func
   * Function Type returning boolean with any parameters
   * @return {boolean}
   * (func boolean<-func)
   */
  public interface Func_boolean_from_func : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_boolean_from_func();
    public Vx.Core.Func_boolean_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public class Class_boolean_from_func : Vx.Core.Class_base, Func_boolean_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_boolean_from_func output = new Vx.Core.Class_boolean_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_boolean_from_func output = new Vx.Core.Class_boolean_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_boolean_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_boolean_from_func;
      return output;
    }

    public delegate Vx.Core.Type_any IFn();

    public Class_any_from_func.IFn? fn = null;

    public Vx.Core.Func_boolean_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Vx.Core.Class_boolean_from_func output = new Vx.Core.Class_boolean_from_func();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      output = Vx.Core.f_boolean_from_func();
      return output;
    }

    public Vx.Core.Type_boolean vx_boolean_from_func() {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      Vx.Core.Class_any_from_func.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal();
        output = Vx.Core.f_any_from_any(Vx.Core.t_boolean, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_boolean_from_func e_boolean_from_func = new Vx.Core.Class_boolean_from_func();
  public static Vx.Core.Func_boolean_from_func t_boolean_from_func = new Vx.Core.Class_boolean_from_func();

  public static Vx.Core.Type_boolean f_boolean_from_func() {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    return output;
  }

  /**
   * @function boolean_from_none
   * Function Type returning boolean with no parameters
   * @return {boolean}
   * (func boolean<-none)
   */
  public interface Func_boolean_from_none : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_boolean_from_none();
    public Vx.Core.Func_boolean_from_none vx_fn_new(Class_any_from_func.IFn fn);
  }

  public class Class_boolean_from_none : Vx.Core.Class_base, Func_boolean_from_none {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_boolean_from_none output = new Vx.Core.Class_boolean_from_none();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_boolean_from_none output = new Vx.Core.Class_boolean_from_none();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-none", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_boolean_from_none;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_boolean_from_none;
      return output;
    }

    public delegate Vx.Core.Type_any IFn();

    public Class_any_from_func.IFn? fn = null;

    public Vx.Core.Func_boolean_from_none vx_fn_new(Class_any_from_func.IFn fn) {
      Vx.Core.Class_boolean_from_none output = new Vx.Core.Class_boolean_from_none();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      output = Vx.Core.f_boolean_from_none();
      return output;
    }

    public Vx.Core.Type_boolean vx_boolean_from_none() {
      Vx.Core.Type_boolean output = Vx.Core.c_false;
      Vx.Core.Class_any_from_func.IFn? fnlocal = this.fn;
      if (fnlocal != null) {
        Vx.Core.Type_any anyoutput = fnlocal();
        output = Vx.Core.f_any_from_any(Vx.Core.t_boolean, anyoutput);
      }
      return output;
    }

  }

  public static Vx.Core.Func_boolean_from_none e_boolean_from_none = new Vx.Core.Class_boolean_from_none();
  public static Vx.Core.Func_boolean_from_none t_boolean_from_none = new Vx.Core.Class_boolean_from_none();

  public static Vx.Core.Type_boolean f_boolean_from_none() {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    return output;
  }

  /**
   * @function case
   * @param  {list-1} values
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func case)
   */
  public interface Func_case : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_thenelse vx_case(Vx.Core.Type_list values, Vx.Core.Func_any_from_func fn_any);
  }

  public class Class_case : Vx.Core.Class_base, Func_case {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_case output = new Vx.Core.Class_case();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_case output = new Vx.Core.Class_case();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_case;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_case;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_case(values, fn_any);
      return output;
    }

    public Vx.Core.Type_thenelse vx_case(Vx.Core.Type_list values, Vx.Core.Func_any_from_func fn_any) {
      Vx.Core.Type_thenelse output = Vx.Core.f_case(values, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_case e_case = new Vx.Core.Class_case();
  public static Vx.Core.Func_case t_case = new Vx.Core.Class_case();

  public static Vx.Core.Type_thenelse f_case(Vx.Core.Type_list values, Vx.Core.Func_any_from_func fn_any) {
    Vx.Core.Type_thenelse output = Vx.Core.e_thenelse;
    output = Vx.Core.f_new(
      Vx.Core.t_thenelse,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":code"),
        Vx.Core.vx_new_string(":casemany"),
        Vx.Core.vx_new_string(":values"),
        values,
        Vx.Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function case 1
   * @param  {any-1} value
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func case)
   */
  public interface Func_case_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_thenelse vx_case_1(Vx.Core.Type_any value, Vx.Core.Func_any_from_func fn_any);
  }

  public class Class_case_1 : Vx.Core.Class_base, Func_case_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_case_1 output = new Vx.Core.Class_case_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_case_1 output = new Vx.Core.Class_case_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_case_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_case_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_case_1(value, fn_any);
      return output;
    }

    public Vx.Core.Type_thenelse vx_case_1(Vx.Core.Type_any value, Vx.Core.Func_any_from_func fn_any) {
      Vx.Core.Type_thenelse output = Vx.Core.f_case_1(value, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_case_1 e_case_1 = new Vx.Core.Class_case_1();
  public static Vx.Core.Func_case_1 t_case_1 = new Vx.Core.Class_case_1();

  public static Vx.Core.Type_thenelse f_case_1(Vx.Core.Type_any value, Vx.Core.Func_any_from_func fn_any) {
    Vx.Core.Type_thenelse output = Vx.Core.e_thenelse;
    output = Vx.Core.f_new(
      Vx.Core.t_thenelse,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":code"),
        Vx.Core.vx_new_string(":case"),
        Vx.Core.vx_new_string(":value"),
        value,
        Vx.Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function compare
   * Returns 0 if vals are equal, 1 if val1 > val2, -1 if val1 < val2
   * @param  {any} val1
   * @param  {any} val2
   * @return {int}
   * (func compare)
   */
  public interface Func_compare : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_int vx_compare(Vx.Core.Type_any val1, Vx.Core.Type_any val2);
  }

  public class Class_compare : Vx.Core.Class_base, Func_compare {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_compare output = new Vx.Core.Class_compare();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_compare output = new Vx.Core.Class_compare();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "compare", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_compare;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_compare;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any val1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any val2 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_compare(val1, val2);
      return output;
    }

    public Vx.Core.Type_int vx_compare(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
      Vx.Core.Type_int output = Vx.Core.f_compare(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_compare e_compare = new Vx.Core.Class_compare();
  public static Vx.Core.Func_compare t_compare = new Vx.Core.Class_compare();

  public static Vx.Core.Type_int f_compare(Vx.Core.Type_any val1, Vx.Core.Type_any val2) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.vx_compare(val1, val2);
    return output;
  }

  /**
   * @function contains
   * Returns true if the given list contains the given value.
   * @param  {string} text
   * @param  {string} find
   * @return {boolean}
   * (func contains)
   */
  public interface Func_contains : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_contains(Vx.Core.Type_string text, Vx.Core.Type_string find);
  }

  public class Class_contains : Vx.Core.Class_base, Func_contains {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_contains output = new Vx.Core.Class_contains();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_contains output = new Vx.Core.Class_contains();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_contains;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_contains;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string find = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_contains(text, find);
      return output;
    }

    public Vx.Core.Type_boolean vx_contains(Vx.Core.Type_string text, Vx.Core.Type_string find) {
      Vx.Core.Type_boolean output = Vx.Core.f_contains(text, find);
      return output;
    }

  }

  public static Vx.Core.Func_contains e_contains = new Vx.Core.Class_contains();
  public static Vx.Core.Func_contains t_contains = new Vx.Core.Class_contains();

  public static Vx.Core.Type_boolean f_contains(Vx.Core.Type_string text, Vx.Core.Type_string find) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    bool check = vx_boolean_from_string_find(text.vx_string(), find.vx_string());
    output = Vx.Core.vx_new_boolean(check);
    return output;
  }

  /**
   * @function contains 1
   * Returns true if the given list contains the given value.
   * @param  {list-2} values Any list
   * @param  {any} find Any value
   * @return {boolean}
   * (func contains)
   */
  public interface Func_contains_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_contains_1(Vx.Core.Type_list values, Vx.Core.Type_any find);
  }

  public class Class_contains_1 : Vx.Core.Class_base, Func_contains_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_contains_1 output = new Vx.Core.Class_contains_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_contains_1 output = new Vx.Core.Class_contains_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_contains_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_contains_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any find = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_contains_1(values, find);
      return output;
    }

    public Vx.Core.Type_boolean vx_contains_1(Vx.Core.Type_list values, Vx.Core.Type_any find) {
      Vx.Core.Type_boolean output = Vx.Core.f_contains_1(values, find);
      return output;
    }

  }

  public static Vx.Core.Func_contains_1 e_contains_1 = new Vx.Core.Class_contains_1();
  public static Vx.Core.Func_contains_1 t_contains_1 = new Vx.Core.Class_contains_1();

  public static Vx.Core.Type_boolean f_contains_1(Vx.Core.Type_list values, Vx.Core.Type_any find) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.vx_contains_1(values, find);
    return output;
  }

  /**
   * @function context_main
   * Returns the default context for app main execution. Arguments come from the command line.
   * @param  {anylist} args
   * @return {context}
   * (func context-main)
   */
  public interface Func_context_main : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_context vx_context_main(Vx.Core.Type_anylist args);
  }

  public class Class_context_main : Vx.Core.Class_base, Func_context_main {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_context_main output = new Vx.Core.Class_context_main();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_context_main output = new Vx.Core.Class_context_main();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "context-main", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "context", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_context_main;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_context_main;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_context_main(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist args = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_context_main(args);
      return output;
    }

    public Vx.Core.Type_context vx_context_main(Vx.Core.Type_anylist args) {
      Vx.Core.Type_context output = Vx.Core.f_context_main(args);
      return output;
    }

  }

  public static Vx.Core.Func_context_main e_context_main = new Vx.Core.Class_context_main();
  public static Vx.Core.Func_context_main t_context_main = new Vx.Core.Class_context_main();

  public static Vx.Core.Type_context f_context_main(Vx.Core.Type_anylist args) {
    Vx.Core.Type_context output = Vx.Core.e_context;
    output = Vx.Core.f_empty(
      Vx.Core.t_context
    );
    return output;
  }

  /**
   * @function copy
   * Returns a copy of a given value with the given values added or updated.
   * @param  {any-1} value
   * @param  {anylist} values
   * @return {any-1}
   * (func copy)
   */
  public interface Func_copy : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_copy<T>(T value, Vx.Core.Type_anylist values) where T : Vx.Core.Type_any;
  }

  public class Class_copy : Vx.Core.Class_base, Func_copy {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_copy output = new Vx.Core.Class_copy();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_copy output = new Vx.Core.Class_copy();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "copy", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_copy;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_copy;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_anylist values = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_copy(value, values);
      return output;
    }

    public T vx_copy<T>(T value, Vx.Core.Type_anylist values) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_copy(value, values);
      return output;
    }

  }

  public static Vx.Core.Func_copy e_copy = new Vx.Core.Class_copy();
  public static Vx.Core.Func_copy t_copy = new Vx.Core.Class_copy();

  public static T f_copy<T>(T value, Vx.Core.Type_anylist values) where T : Vx.Core.Type_any {
    Vx.Core.Type_any[] arrayany = Vx.Core.arrayany_from_anylist(values);
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    T tvalue = (T)value;
    Vx.Core.Type_any anyvalue = tvalue.vx_copy(arrayobj);
    T output = (T)anyvalue;
    return output;
  }

  /**
   * @function else
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func else)
   */
  public interface Func_else : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_thenelse vx_else(Vx.Core.Func_any_from_func fn_any);
  }

  public class Class_else : Vx.Core.Class_base, Func_else {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_else output = new Vx.Core.Class_else();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_else output = new Vx.Core.Class_else();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "else", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_else;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_else;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Func_any_from_func inputval = (Vx.Core.Func_any_from_func)value;
      Vx.Core.Type_any outputval = Vx.Core.f_else(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_else(fn_any);
      return output;
    }

    public Vx.Core.Type_thenelse vx_else(Vx.Core.Func_any_from_func fn_any) {
      Vx.Core.Type_thenelse output = Vx.Core.f_else(fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_else e_else = new Vx.Core.Class_else();
  public static Vx.Core.Func_else t_else = new Vx.Core.Class_else();

  public static Vx.Core.Type_thenelse f_else(Vx.Core.Func_any_from_func fn_any) {
    Vx.Core.Type_thenelse output = Vx.Core.e_thenelse;
    output = Vx.Core.f_new(
      Vx.Core.t_thenelse,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":code"),
        Vx.Core.vx_new_string(":else"),
        Vx.Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function empty
   * Returns the empty value for a given type. Can be called using (empty type) or simply (type)
   * @param  {any-1} type
   * @return {any-1}
   * (func empty)
   */
  public interface Func_empty : Vx.Core.Func_any_from_any {
    public T vx_empty<T>(T type) where T : Vx.Core.Type_any;
  }

  public class Class_empty : Vx.Core.Class_base, Func_empty {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_empty output = new Vx.Core.Class_empty();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_empty output = new Vx.Core.Class_empty();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "empty", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_empty;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_empty;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_empty(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any type = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_empty(type);
      return output;
    }

    public T vx_empty<T>(T type) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(type);
      return output;
    }

  }

  public static Vx.Core.Func_empty e_empty = new Vx.Core.Class_empty();
  public static Vx.Core.Func_empty t_empty = new Vx.Core.Class_empty();

  public static T f_empty<T>(T type) where T : Vx.Core.Type_any {
    T output = Vx.Core.vx_empty(type);
    return output;
  }

  /**
   * @function extends_from_any
   * @param  {any-1} value
   * @return {string}
   * (func extends<-any)
   */
  public interface Func_extends_from_any : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_extends_from_any(Vx.Core.Type_any value);
  }

  public class Class_extends_from_any : Vx.Core.Class_base, Func_extends_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_extends_from_any output = new Vx.Core.Class_extends_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_extends_from_any output = new Vx.Core.Class_extends_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "extends<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_extends_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_extends_from_any;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_extends_from_any(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_extends_from_any(value);
      return output;
    }

    public Vx.Core.Type_string vx_extends_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_string output = Vx.Core.f_extends_from_any(value);
      return output;
    }

  }

  public static Vx.Core.Func_extends_from_any e_extends_from_any = new Vx.Core.Class_extends_from_any();
  public static Vx.Core.Func_extends_from_any t_extends_from_any = new Vx.Core.Class_extends_from_any();

  public static Vx.Core.Type_string f_extends_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_extends_from_typedef(
      Vx.Core.f_typedef_from_any(
        value
      )
    );
    return output;
  }

  /**
   * @function extends_from_typedef
   * Get the basetype of a given type
   * @param  {typedef} vtypedef
   * @return {string}
   * (func extends<-typedef)
   */
  public interface Func_extends_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_extends_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_extends_from_typedef : Vx.Core.Class_base, Func_extends_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_extends_from_typedef output = new Vx.Core.Class_extends_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_extends_from_typedef output = new Vx.Core.Class_extends_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "extends<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_extends_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_extends_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_extends_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_extends_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_string vx_extends_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_string output = Vx.Core.f_extends_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_extends_from_typedef e_extends_from_typedef = new Vx.Core.Class_extends_from_typedef();
  public static Vx.Core.Func_extends_from_typedef t_extends_from_typedef = new Vx.Core.Class_extends_from_typedef();

  public static Vx.Core.Type_string f_extends_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = vtypedef.extend();
    return output;
  }

  /**
   * @function first_from_list
   * Returns first value
   * @param  {list-1} values
   * @return {any-1}
   * (func first<-list)
   */
  public interface Func_first_from_list : Vx.Core.Func_any_from_any {
    public T vx_first_from_list<T, X>(T generic_any_1, X values) where T : Vx.Core.Type_any where X : Vx.Core.Type_list;
  }

  public class Class_first_from_list : Vx.Core.Class_base, Func_first_from_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_first_from_list output = new Vx.Core.Class_first_from_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_first_from_list output = new Vx.Core.Class_first_from_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "first<-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_first_from_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_first_from_list;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_first_from_list(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_first_from_list(generic_any_1, values);
      return output;
    }

    public T vx_first_from_list<T, X>(T generic_any_1, X values) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
      T output = Vx.Core.f_first_from_list(generic_any_1, values);
      return output;
    }

  }

  public static Vx.Core.Func_first_from_list e_first_from_list = new Vx.Core.Class_first_from_list();
  public static Vx.Core.Func_first_from_list t_first_from_list = new Vx.Core.Class_first_from_list();

  public static T f_first_from_list<T, X>(T generic_any_1, X values) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.f_any_from_list(
      generic_any_1,
      values,
      Vx.Core.vx_new_int(1)
    );
    return output;
  }

  /**
   * @function first_from_list_any_from_any
   * Returns first value that is not nothing
   * @param  {list-1} values
   * @param  {any<-any} fn-any<-any
   * @return {any-1}
   * (func first<-list-any<-any)
   */
  public interface Func_first_from_list_any_from_any : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_first_from_list_any_from_any<T, X>(T generic_any_1, X values, Vx.Core.Func_any_from_any fn_any_from_any) where T : Vx.Core.Type_any where X : Vx.Core.Type_list;
  }

  public class Class_first_from_list_any_from_any : Vx.Core.Class_base, Func_first_from_list_any_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_first_from_list_any_from_any output = new Vx.Core.Class_first_from_list_any_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_first_from_list_any_from_any output = new Vx.Core.Class_first_from_list_any_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "first<-list-any<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_first_from_list_any_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_first_from_list_any_from_any;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_any fn_any_from_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any);
      return output;
    }

    public T vx_first_from_list_any_from_any<T, X>(T generic_any_1, X values, Vx.Core.Func_any_from_any fn_any_from_any) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
      T output = Vx.Core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any);
      return output;
    }

  }

  public static Vx.Core.Func_first_from_list_any_from_any e_first_from_list_any_from_any = new Vx.Core.Class_first_from_list_any_from_any();
  public static Vx.Core.Func_first_from_list_any_from_any t_first_from_list_any_from_any = new Vx.Core.Class_first_from_list_any_from_any();

  public static T f_first_from_list_any_from_any<T, X>(T generic_any_1, X values, Vx.Core.Func_any_from_any fn_any_from_any) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    List<Vx.Core.Type_any> listvalue = values.vx_list();
    foreach (Vx.Core.Type_any value in listvalue) {
      if (value != Vx.Core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value);
        break;
      }
    };
    return output;
  }

  /**
   * @function float_from_string
   * Returns float from a given string.
   * @param  {string} text
   * @return {float}
   * (func float<-string)
   */
  public interface Func_float_from_string : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_float vx_float_from_string(Vx.Core.Type_string text);
  }

  public class Class_float_from_string : Vx.Core.Class_base, Func_float_from_string {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_float_from_string output = new Vx.Core.Class_float_from_string();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_float_from_string output = new Vx.Core.Class_float_from_string();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "float<-string", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "float", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_float_from_string;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_float_from_string;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_float_from_string(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_float_from_string(text);
      return output;
    }

    public Vx.Core.Type_float vx_float_from_string(Vx.Core.Type_string text) {
      Vx.Core.Type_float output = Vx.Core.f_float_from_string(text);
      return output;
    }

  }

  public static Vx.Core.Func_float_from_string e_float_from_string = new Vx.Core.Class_float_from_string();
  public static Vx.Core.Func_float_from_string t_float_from_string = new Vx.Core.Class_float_from_string();

  public static Vx.Core.Type_float f_float_from_string(Vx.Core.Type_string text) {
    Vx.Core.Type_float output = Vx.Core.e_float;
    float num = Vx.Core.vx_float_from_string(text.vx_string());
    output = Vx.Core.vx_new_float(num);
    return output;
  }

  /**
   * @function fn
   * Shell for lambda function calls
   * @param  {arglist} parameters
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func fn)
   */
  public interface Func_fn : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_fn<T>(T generic_any_1, Vx.Core.Type_arglist parameters, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any;
  }

  public class Class_fn : Vx.Core.Class_base, Func_fn {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_fn output = new Vx.Core.Class_fn();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_fn output = new Vx.Core.Class_fn();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "fn", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_fn;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_arglist parameters = Vx.Core.f_any_from_any(Vx.Core.t_arglist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_fn(generic_any_1, parameters, fn_any);
      return output;
    }

    public T vx_fn<T>(T generic_any_1, Vx.Core.Type_arglist parameters, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_fn(generic_any_1, parameters, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_fn e_fn = new Vx.Core.Class_fn();
  public static Vx.Core.Func_fn t_fn = new Vx.Core.Class_fn();

  public static T f_fn<T>(T generic_any_1, Vx.Core.Type_arglist parameters, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function funcdef_from_func
   * Returns the definition of a function
   * @param  {func} value
   * @return {funcdef}
   * (func funcdef<-func)
   */
  public interface Func_funcdef_from_func : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_funcdef vx_funcdef_from_func(Vx.Core.Type_func value);
  }

  public class Class_funcdef_from_func : Vx.Core.Class_base, Func_funcdef_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_funcdef_from_func output = new Vx.Core.Class_funcdef_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_funcdef_from_func output = new Vx.Core.Class_funcdef_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "funcdef<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "funcdef", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_funcdef_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_funcdef_from_func;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_func inputval = (Vx.Core.Type_func)value;
      Vx.Core.Type_any outputval = Vx.Core.f_funcdef_from_func(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_func value = Vx.Core.f_any_from_any(Vx.Core.t_func, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_funcdef_from_func(value);
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef_from_func(Vx.Core.Type_func value) {
      Vx.Core.Type_funcdef output = Vx.Core.f_funcdef_from_func(value);
      return output;
    }

  }

  public static Vx.Core.Func_funcdef_from_func e_funcdef_from_func = new Vx.Core.Class_funcdef_from_func();
  public static Vx.Core.Func_funcdef_from_func t_funcdef_from_func = new Vx.Core.Class_funcdef_from_func();

  public static Vx.Core.Type_funcdef f_funcdef_from_func(Vx.Core.Type_func value) {
    Vx.Core.Type_funcdef output = Vx.Core.e_funcdef;
    output = value.vx_funcdef();
    return output;
  }

  /**
   * @function funcname_from_funcdef
   * Get the name of a given funcdef
   * @param  {funcdef} funcdef
   * @return {string}
   * (func funcname<-funcdef)
   */
  public interface Func_funcname_from_funcdef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_funcname_from_funcdef(Vx.Core.Type_funcdef funcdef);
  }

  public class Class_funcname_from_funcdef : Vx.Core.Class_base, Func_funcname_from_funcdef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_funcname_from_funcdef output = new Vx.Core.Class_funcname_from_funcdef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_funcname_from_funcdef output = new Vx.Core.Class_funcname_from_funcdef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "funcname<-funcdef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_funcname_from_funcdef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_funcname_from_funcdef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_funcdef inputval = (Vx.Core.Type_funcdef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_funcname_from_funcdef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_funcdef funcdef = Vx.Core.f_any_from_any(Vx.Core.t_funcdef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_funcname_from_funcdef(funcdef);
      return output;
    }

    public Vx.Core.Type_string vx_funcname_from_funcdef(Vx.Core.Type_funcdef funcdef) {
      Vx.Core.Type_string output = Vx.Core.f_funcname_from_funcdef(funcdef);
      return output;
    }

  }

  public static Vx.Core.Func_funcname_from_funcdef e_funcname_from_funcdef = new Vx.Core.Class_funcname_from_funcdef();
  public static Vx.Core.Func_funcname_from_funcdef t_funcname_from_funcdef = new Vx.Core.Class_funcname_from_funcdef();

  public static Vx.Core.Type_string f_funcname_from_funcdef(Vx.Core.Type_funcdef funcdef) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_new(
      Vx.Core.t_string,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        funcdef.pkgname(),
        Vx.Core.vx_new_string("/"),
        funcdef.name()
      )
    );
    return output;
  }

  /**
   * @function if
   * Logical If function
   * @param  {boolean} clause
   * @param  {any-1} then
   * @return {any-1}
   * (func if)
   */
  public interface Func_if : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_if<T>(T generic_any_1, Vx.Core.Type_boolean clause, T then) where T : Vx.Core.Type_any;
  }

  public class Class_if : Vx.Core.Class_base, Func_if {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_if output = new Vx.Core.Class_if();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_if output = new Vx.Core.Class_if();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_if;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_if;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_boolean clause = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any then = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_if(generic_any_1, clause, then);
      return output;
    }

    public T vx_if<T>(T generic_any_1, Vx.Core.Type_boolean clause, T then) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_if(generic_any_1, clause, then);
      return output;
    }

  }

  public static Vx.Core.Func_if e_if = new Vx.Core.Class_if();
  public static Vx.Core.Func_if t_if = new Vx.Core.Class_if();

  public static T f_if<T>(T generic_any_1, Vx.Core.Type_boolean clause, T then) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    if (clause.vx_boolean()) {
      output = then;
    };
    return output;
  }

  /**
   * @function if 1
   * Logical If function
   * @param  {boolean} clause
   * @param  {any-1} thenval
   * @param  {any-1} elseval
   * @return {any-1}
   * (func if)
   */
  public interface Func_if_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_if_1<T>(T generic_any_1, Vx.Core.Type_boolean clause, T thenval, T elseval) where T : Vx.Core.Type_any;
  }

  public class Class_if_1 : Vx.Core.Class_base, Func_if_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_if_1 output = new Vx.Core.Class_if_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_if_1 output = new Vx.Core.Class_if_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_if_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_if_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_boolean clause = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any thenval = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_any elseval = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_if_1(generic_any_1, clause, thenval, elseval);
      return output;
    }

    public T vx_if_1<T>(T generic_any_1, Vx.Core.Type_boolean clause, T thenval, T elseval) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_if_1(generic_any_1, clause, thenval, elseval);
      return output;
    }

  }

  public static Vx.Core.Func_if_1 e_if_1 = new Vx.Core.Class_if_1();
  public static Vx.Core.Func_if_1 t_if_1 = new Vx.Core.Class_if_1();

  public static T f_if_1<T>(T generic_any_1, Vx.Core.Type_boolean clause, T thenval, T elseval) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    };
    return output;
  }

  /**
   * @function if 2
   * Logical If function
   * @param  {thenelselist} thenelselist
   * @return {any-1}
   * (func if)
   */
  public interface Func_if_2 : Vx.Core.Func_any_from_any {
    public T vx_if_2<T>(T generic_any_1, Vx.Core.Type_thenelselist thenelselist) where T : Vx.Core.Type_any;
  }

  public class Class_if_2 : Vx.Core.Class_base, Func_if_2 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_if_2 output = new Vx.Core.Class_if_2();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_if_2 output = new Vx.Core.Class_if_2();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        2, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_if_2;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_if_2;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_thenelselist inputval = (Vx.Core.Type_thenelselist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_if_2(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_thenelselist thenelselist = Vx.Core.f_any_from_any(Vx.Core.t_thenelselist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_if_2(generic_any_1, thenelselist);
      return output;
    }

    public T vx_if_2<T>(T generic_any_1, Vx.Core.Type_thenelselist thenelselist) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_if_2(generic_any_1, thenelselist);
      return output;
    }

  }

  public static Vx.Core.Func_if_2 e_if_2 = new Vx.Core.Class_if_2();
  public static Vx.Core.Func_if_2 t_if_2 = new Vx.Core.Class_if_2();

  public static T f_if_2<T>(T generic_any_1, Vx.Core.Type_thenelselist thenelselist) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.vx_if_2(generic_any_1, thenelselist);
    return output;
  }

  /**
   * @function int_from_func
   * Function Type returning int with any parameters
   * @return {int}
   * (func int<-func)
   */
  public interface Func_int_from_func : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_int vx_int_from_func();
    public Vx.Core.Func_int_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public class Class_int_from_func : Vx.Core.Class_base, Func_int_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_int_from_func output = new Vx.Core.Class_int_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_int_from_func output = new Vx.Core.Class_int_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "int<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_int_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_int_from_func;
      return output;
    }

    public Class_any_from_func.IFn? fn = null;

    public Vx.Core.Func_int_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Vx.Core.Class_int_from_func output = new Vx.Core.Class_int_from_func();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      output = Vx.Core.f_int_from_func();
      return output;
    }

    public Vx.Core.Type_int vx_int_from_func() {
      Vx.Core.Type_int output = Vx.Core.f_int_from_func();
      return output;
    }

  }

  public static Vx.Core.Func_int_from_func e_int_from_func = new Vx.Core.Class_int_from_func();
  public static Vx.Core.Func_int_from_func t_int_from_func = new Vx.Core.Class_int_from_func();

  public static Vx.Core.Type_int f_int_from_func() {
    Vx.Core.Type_int output = Vx.Core.e_int;
    return output;
  }

  /**
   * @function int_from_string
   * Function Type converting string to int
   * @param  {string} value
   * @return {int}
   * (func int<-string)
   */
  public interface Func_int_from_string : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_int_from_string(Vx.Core.Type_string value);
  }

  public class Class_int_from_string : Vx.Core.Class_base, Func_int_from_string {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_int_from_string output = new Vx.Core.Class_int_from_string();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_int_from_string output = new Vx.Core.Class_int_from_string();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "int<-string", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_int_from_string;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_int_from_string;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_int_from_string(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string value = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_int_from_string(value);
      return output;
    }

    public Vx.Core.Type_int vx_int_from_string(Vx.Core.Type_string value) {
      Vx.Core.Type_int output = Vx.Core.f_int_from_string(value);
      return output;
    }

  }

  public static Vx.Core.Func_int_from_string e_int_from_string = new Vx.Core.Class_int_from_string();
  public static Vx.Core.Func_int_from_string t_int_from_string = new Vx.Core.Class_int_from_string();

  public static Vx.Core.Type_int f_int_from_string(Vx.Core.Type_string value) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_switch(
      Vx.Core.t_int,
      value,
      Vx.Core.vx_new(
        Vx.Core.t_thenelselist,
        Vx.Core.f_case_1(
          Vx.Core.vx_new_string("notanumber"),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_1 = Vx.Core.c_notanumber;
            return output_1;
          })
        ),
        Vx.Core.f_case_1(
          Vx.Core.vx_new_string("infinity"),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_2 = Vx.Core.c_infinity;
            return output_2;
          })
        ),
        Vx.Core.f_case_1(
          Vx.Core.vx_new_string("neginfinity"),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_3 = Vx.Core.c_neginfinity;
            return output_3;
          })
        ),
        Vx.Core.f_else(
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_int intresult = Vx.Core.e_int;
            string strval = value.vx_string();
            try {
              float floatresult = float.Parse(strval);
              int iresult = (int)floatresult;
              intresult = Vx.Core.vx_new_int(iresult);
            } catch (Exception) {
              intresult = Vx.Core.c_notanumber;
            }
            return intresult;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function is_empty
   * Returns true if text is empty.
   * @param  {string} text
   * @return {boolean}
   * (func is-empty)
   */
  public interface Func_is_empty : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_is_empty(Vx.Core.Type_string text);
  }

  public class Class_is_empty : Vx.Core.Class_base, Func_is_empty {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_empty output = new Vx.Core.Class_is_empty();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_empty output = new Vx.Core.Class_is_empty();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_empty;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_empty;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_empty(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_empty(text);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_empty(Vx.Core.Type_string text) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_empty(text);
      return output;
    }

  }

  public static Vx.Core.Func_is_empty e_is_empty = new Vx.Core.Class_is_empty();
  public static Vx.Core.Func_is_empty t_is_empty = new Vx.Core.Class_is_empty();

  public static Vx.Core.Type_boolean f_is_empty(Vx.Core.Type_string text) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    if (text.vx_string().Length == 0) {
      output = Vx.Core.c_true;
    };
    return output;
  }

  /**
   * @function is_empty 1
   * Returns true if an value is empty
   * @param  {any} value
   * @return {boolean}
   * (func is-empty)
   */
  public interface Func_is_empty_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_is_empty_1(Vx.Core.Type_any value);
  }

  public class Class_is_empty_1 : Vx.Core.Class_base, Func_is_empty_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_empty_1 output = new Vx.Core.Class_is_empty_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_empty_1 output = new Vx.Core.Class_is_empty_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_empty_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_empty_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_empty_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_empty_1(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_empty_1(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_empty_1(value);
      return output;
    }

  }

  public static Vx.Core.Func_is_empty_1 e_is_empty_1 = new Vx.Core.Class_is_empty_1();
  public static Vx.Core.Func_is_empty_1 t_is_empty_1 = new Vx.Core.Class_is_empty_1();

  public static Vx.Core.Type_boolean f_is_empty_1(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    if (value == value.vx_empty()) {
      output = Vx.Core.c_true;
    } else {
      output = Vx.Core.c_false;
    };
    return output;
  }

  /**
   * @function is_endswith
   * Returns true if text ends with find.
   * @param  {string} text
   * @param  {string} find
   * @return {boolean}
   * (func is-endswith)
   */
  public interface Func_is_endswith : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_is_endswith(Vx.Core.Type_string text, Vx.Core.Type_string find);
  }

  public class Class_is_endswith : Vx.Core.Class_base, Func_is_endswith {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_endswith output = new Vx.Core.Class_is_endswith();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_endswith output = new Vx.Core.Class_is_endswith();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-endswith", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_endswith;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_endswith;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string find = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_is_endswith(text, find);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_endswith(Vx.Core.Type_string text, Vx.Core.Type_string find) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_endswith(text, find);
      return output;
    }

  }

  public static Vx.Core.Func_is_endswith e_is_endswith = new Vx.Core.Class_is_endswith();
  public static Vx.Core.Func_is_endswith t_is_endswith = new Vx.Core.Class_is_endswith();

  public static Vx.Core.Type_boolean f_is_endswith(Vx.Core.Type_string text, Vx.Core.Type_string find) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    string stext = text.vx_string();
    string sfind = find.vx_string();
    if (stext.EndsWith(sfind)) {
      output = Vx.Core.c_true;
    };
    return output;
  }

  /**
   * @function is_float
   * Returns true if the value is a float.
   * @param  {any} value
   * @return {boolean}
   * (func is-float)
   */
  public interface Func_is_float : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_is_float(Vx.Core.Type_any value);
  }

  public class Class_is_float : Vx.Core.Class_base, Func_is_float {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_float output = new Vx.Core.Class_is_float();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_float output = new Vx.Core.Class_is_float();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-float", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_float;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_float;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_float(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_float(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_float(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_float(value);
      return output;
    }

  }

  public static Vx.Core.Func_is_float e_is_float = new Vx.Core.Class_is_float();
  public static Vx.Core.Func_is_float t_is_float = new Vx.Core.Class_is_float();

  public static Vx.Core.Type_boolean f_is_float(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    bool result = Vx.Core.vx_is_float(value);
    output = Vx.Core.vx_new_boolean(result);
    return output;
  }

  /**
   * @function is_func
   * Returns true if value is a function.
   * @param  {any} value
   * @return {boolean}
   * (func is-func)
   */
  public interface Func_is_func : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_is_func(Vx.Core.Type_any value);
  }

  public class Class_is_func : Vx.Core.Class_base, Func_is_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_func output = new Vx.Core.Class_is_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_func output = new Vx.Core.Class_is_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_func;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_func(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_func(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_func(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_func(value);
      return output;
    }

  }

  public static Vx.Core.Func_is_func e_is_func = new Vx.Core.Class_is_func();
  public static Vx.Core.Func_is_func t_is_func = new Vx.Core.Class_is_func();

  public static Vx.Core.Type_boolean f_is_func(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    if (value is Vx.Core.Type_func) {
      output = Vx.Core.c_true;
    };
    return output;
  }

  /**
   * @function is_int
   * Returns true if the value is an integer.
   * @param  {any} value
   * @return {boolean}
   * (func is-int)
   */
  public interface Func_is_int : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_is_int(Vx.Core.Type_any value);
  }

  public class Class_is_int : Vx.Core.Class_base, Func_is_int {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_int output = new Vx.Core.Class_is_int();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_int output = new Vx.Core.Class_is_int();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-int", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_int;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_int;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_int(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_int(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_int(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_int(value);
      return output;
    }

  }

  public static Vx.Core.Func_is_int e_is_int = new Vx.Core.Class_is_int();
  public static Vx.Core.Func_is_int t_is_int = new Vx.Core.Class_is_int();

  public static Vx.Core.Type_boolean f_is_int(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    bool result = Vx.Core.vx_is_int(value);
    output = Vx.Core.vx_new_boolean(result);
    return output;
  }

  /**
   * @function is_number
   * Return true if value is a number
   * @param  {any} value
   * @return {boolean}
   * (func is-number)
   */
  public interface Func_is_number : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_is_number(Vx.Core.Type_any value);
  }

  public class Class_is_number : Vx.Core.Class_base, Func_is_number {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_number output = new Vx.Core.Class_is_number();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_number output = new Vx.Core.Class_is_number();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-number", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_number;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_number;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_number(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_number(value);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_number(Vx.Core.Type_any value) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_number(value);
      return output;
    }

  }

  public static Vx.Core.Func_is_number e_is_number = new Vx.Core.Class_is_number();
  public static Vx.Core.Func_is_number t_is_number = new Vx.Core.Class_is_number();

  public static Vx.Core.Type_boolean f_is_number(Vx.Core.Type_any value) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_switch(
      Vx.Core.t_boolean,
      Vx.Core.f_typename_from_any(
        value
      ),
      Vx.Core.vx_new(
        Vx.Core.t_thenelselist,
        Vx.Core.f_case(
          Vx.Core.f_new(
            Vx.Core.t_list,
            Vx.Core.vx_new(
              Vx.Core.t_anylist,
              Vx.Core.vx_new_string("vx/core/decimal"),
              Vx.Core.vx_new_string("vx/core/float"),
              Vx.Core.vx_new_string("vx/core/int"),
              Vx.Core.vx_new_string("vx/core/number")
            )
          ),
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_1 = Vx.Core.vx_new_boolean(true);
            return output_1;
          })
        ),
        Vx.Core.f_else(
          Vx.Core.t_any_from_func.vx_fn_new(() => {
            Vx.Core.Type_any output_2 = Vx.Core.vx_new_boolean(false);
            return output_2;
          })
        )
      )
    );
    return output;
  }

  /**
   * @function is_pass_from_permission
   * Returns true if permission passes.
   * @param  {permission} permission
   * @return {boolean}
   * (func is-pass<-permission)
   */
  public interface Func_is_pass_from_permission : Vx.Core.Func_any_from_any_context {
    public Vx.Core.Type_boolean vx_is_pass_from_permission(Vx.Core.Type_context context, Vx.Core.Type_permission permission);
  }

  public class Class_is_pass_from_permission : Vx.Core.Class_base, Func_is_pass_from_permission {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_is_pass_from_permission output = new Vx.Core.Class_is_pass_from_permission();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_is_pass_from_permission output = new Vx.Core.Class_is_pass_from_permission();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "is-pass<-permission", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_is_pass_from_permission;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_is_pass_from_permission;
      return output;
    }

    public Vx.Core.Func_any_from_any_context vx_fn_new(Vx.Core.Class_any_from_any_context.IFn fn) {
      return Vx.Core.e_any_from_any_context;
    }

    public T vx_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_permission inputval = (Vx.Core.Type_permission)value;
      Vx.Core.Type_any outputval = Vx.Core.f_is_pass_from_permission(context, inputval);
      output = Vx.Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_permission permission = Vx.Core.f_any_from_any(Vx.Core.t_permission, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_is_pass_from_permission(context, permission);
      return output;
    }

    public Vx.Core.Type_boolean vx_is_pass_from_permission(Vx.Core.Type_context context, Vx.Core.Type_permission permission) {
      Vx.Core.Type_boolean output = Vx.Core.f_is_pass_from_permission(context, permission);
      return output;
    }

  }

  public static Vx.Core.Func_is_pass_from_permission e_is_pass_from_permission = new Vx.Core.Class_is_pass_from_permission();
  public static Vx.Core.Func_is_pass_from_permission t_is_pass_from_permission = new Vx.Core.Class_is_pass_from_permission();

  public static Vx.Core.Type_boolean f_is_pass_from_permission(Vx.Core.Type_context context, Vx.Core.Type_permission permission) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_let(
      Vx.Core.t_boolean,
      Vx.Core.t_any_from_func.vx_fn_new(() => {
        Vx.Core.Type_string id = permission.id();
        Vx.Core.Type_permission lookup = Vx.Core.f_permission_from_id_context(
          context,
          id
        );
        Vx.Core.Type_any output_1 = Vx.Core.f_eq(
          lookup,
          permission
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function last_from_list
   * Returns last value
   * @param  {list-1} values
   * @return {any-1}
   * (func last<-list)
   */
  public interface Func_last_from_list : Vx.Core.Func_any_from_any {
    public T vx_last_from_list<T, X>(T generic_any_1, X values) where T : Vx.Core.Type_any where X : Vx.Core.Type_list;
  }

  public class Class_last_from_list : Vx.Core.Class_base, Func_last_from_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_last_from_list output = new Vx.Core.Class_last_from_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_last_from_list output = new Vx.Core.Class_last_from_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "last<-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_last_from_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_last_from_list;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_last_from_list(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_last_from_list(generic_any_1, values);
      return output;
    }

    public T vx_last_from_list<T, X>(T generic_any_1, X values) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
      T output = Vx.Core.f_last_from_list(generic_any_1, values);
      return output;
    }

  }

  public static Vx.Core.Func_last_from_list e_last_from_list = new Vx.Core.Class_last_from_list();
  public static Vx.Core.Func_last_from_list t_last_from_list = new Vx.Core.Class_last_from_list();

  public static T f_last_from_list<T, X>(T generic_any_1, X values) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.f_let(
      generic_any_1,
      Vx.Core.t_any_from_func.vx_fn_new(() => {
        Vx.Core.Type_int len = Vx.Core.f_length_1(
          values
        );
        Vx.Core.Type_any output_1 = Vx.Core.f_any_from_list(
          generic_any_1,
          values,
          len
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function length
   * Returns length of a string.
   * @param  {string} text
   * @return {int}
   * (func length)
   */
  public interface Func_length : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_length(Vx.Core.Type_string text);
  }

  public class Class_length : Vx.Core.Class_base, Func_length {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_length output = new Vx.Core.Class_length();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_length output = new Vx.Core.Class_length();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_length;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_length;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_length(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_length(text);
      return output;
    }

    public Vx.Core.Type_int vx_length(Vx.Core.Type_string text) {
      Vx.Core.Type_int output = Vx.Core.f_length(text);
      return output;
    }

  }

  public static Vx.Core.Func_length e_length = new Vx.Core.Class_length();
  public static Vx.Core.Func_length t_length = new Vx.Core.Class_length();

  public static Vx.Core.Type_int f_length(Vx.Core.Type_string text) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    int len = text.vx_string().Length;
    output = Vx.Core.vx_new_int(len);
    return output;
  }

  /**
   * @function length 1
   * Returns the currently used size/length of a list
   * @param  {list-1} values
   * @return {int}
   * (func length)
   */
  public interface Func_length_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_length_1(Vx.Core.Type_list values);
  }

  public class Class_length_1 : Vx.Core.Class_base, Func_length_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_length_1 output = new Vx.Core.Class_length_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_length_1 output = new Vx.Core.Class_length_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_length_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_length_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_length_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_length_1(values);
      return output;
    }

    public Vx.Core.Type_int vx_length_1(Vx.Core.Type_list values) {
      Vx.Core.Type_int output = Vx.Core.f_length_1(values);
      return output;
    }

  }

  public static Vx.Core.Func_length_1 e_length_1 = new Vx.Core.Class_length_1();
  public static Vx.Core.Func_length_1 t_length_1 = new Vx.Core.Class_length_1();

  public static Vx.Core.Type_int f_length_1(Vx.Core.Type_list values) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    int intresult = values.vx_list().Count();
    output = Core.vx_new_int(intresult);
    return output;
  }

  /**
   * @function length 2
   * Returns the length of the given map.
   * @param  {map-1} valuemap
   * @return {int}
   * (func length)
   */
  public interface Func_length_2 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_int vx_length_2(Vx.Core.Type_map valuemap);
  }

  public class Class_length_2 : Vx.Core.Class_base, Func_length_2 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_length_2 output = new Vx.Core.Class_length_2();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_length_2 output = new Vx.Core.Class_length_2();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        2, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_number), // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_length_2;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_length_2;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_map inputval = (Vx.Core.Type_map)value;
      Vx.Core.Type_any outputval = Vx.Core.f_length_2(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_length_2(valuemap);
      return output;
    }

    public Vx.Core.Type_int vx_length_2(Vx.Core.Type_map valuemap) {
      Vx.Core.Type_int output = Vx.Core.f_length_2(valuemap);
      return output;
    }

  }

  public static Vx.Core.Func_length_2 e_length_2 = new Vx.Core.Class_length_2();
  public static Vx.Core.Func_length_2 t_length_2 = new Vx.Core.Class_length_2();

  public static Vx.Core.Type_int f_length_2(Vx.Core.Type_map valuemap) {
    Vx.Core.Type_int output = Vx.Core.e_int;
    output = Vx.Core.f_length_1(
      Vx.Core.f_stringlist_from_map(
        valuemap
      )
    );
    return output;
  }

  /**
   * @function let
   * @param  {arglist} args
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func let)
   */
  public interface Func_let : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_let<T>(T generic_any_1, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any;
  }

  public class Class_let : Vx.Core.Class_base, Func_let {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_let output = new Vx.Core.Class_let();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_let output = new Vx.Core.Class_let();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "let", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_let;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_let;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_let(generic_any_1, fn_any);
      return output;
    }

    public T vx_let<T>(T generic_any_1, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_let(generic_any_1, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_let e_let = new Vx.Core.Class_let();
  public static Vx.Core.Func_let t_let = new Vx.Core.Class_let();

  public static T f_let<T>(T generic_any_1, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    output = fn_any.vx_any_from_func(generic_any_1);
    return output;
  }

  /**
   * 
   * @async
   * @function let_async
   * Same as normal let but returns async values.
   * @param  {arglist} args
   * @param  {any<-func-async} fn-any-async
   * @return {any-1}
   * (func let-async)
   */
  public interface Func_let_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<T> vx_let_async<T>(T generic_any_1, Vx.Core.Func_any_from_func_async fn_any_async) where T : Vx.Core.Type_any;
  }

  public class Class_let_async : Vx.Core.Class_base, Func_let_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_let_async output = new Vx.Core.Class_let_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_let_async output = new Vx.Core.Class_let_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "let-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_let_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_let_async;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func_async fn_any_async = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func_async, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_let_async(generic_any_1, fn_any_async);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_let_async<T>(T generic_any_1, Vx.Core.Func_any_from_func_async fn_any_async) where T : Vx.Core.Type_any {
      Task<T> output = Vx.Core.f_let_async(generic_any_1, fn_any_async);
      return output;
    }

  }

  public static Vx.Core.Func_let_async e_let_async = new Vx.Core.Class_let_async();
  public static Vx.Core.Func_let_async t_let_async = new Vx.Core.Class_let_async();

  public static Task<T> f_let_async<T>(T generic_any_1, Vx.Core.Func_any_from_func_async fn_any_async) where T : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    output = fn_any_async.vx_any_from_func_async(generic_any_1);
    return output;
  }

  /**
   * @function list_join_from_list
   * Returns a list by joining the valid values in each value list
   * @param  {list-2} values
   * @return {list-1}
   * (func list-join<-list)
   */
  public interface Func_list_join_from_list : Vx.Core.Func_any_from_any {
    public X vx_list_join_from_list<X, Y>(X generic_list_1, Y values) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list;
  }

  public class Class_list_join_from_list : Vx.Core.Class_base, Func_list_join_from_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_join_from_list output = new Vx.Core.Class_list_join_from_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_join_from_list output = new Vx.Core.Class_list_join_from_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_join_from_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_join_from_list;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_list_join_from_list(Vx.Core.t_list, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_list_join_from_list(generic_list_1, values);
      return output;
    }

    public X vx_list_join_from_list<X, Y>(X generic_list_1, Y values) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
      X output = Vx.Core.f_list_join_from_list(generic_list_1, values);
      return output;
    }

  }

  public static Vx.Core.Func_list_join_from_list e_list_join_from_list = new Vx.Core.Class_list_join_from_list();
  public static Vx.Core.Func_list_join_from_list t_list_join_from_list = new Vx.Core.Class_list_join_from_list();

  public static X f_list_join_from_list<X, Y>(X generic_list_1, Y values) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.f_list_join_from_list_1(
      generic_list_1,
      values,
      Vx.Core.t_any_from_any.vx_fn_new((value_any) => {
        Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, value_any);
        Vx.Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function list_join_from_list 1
   * Returns a flattened list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-any} fn-any<-any
   * @return {list-1}
   * (func list-join<-list)
   */
  public interface Func_list_join_from_list_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public X vx_list_join_from_list_1<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any fn_any_from_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list;
  }

  public class Class_list_join_from_list_1 : Vx.Core.Class_base, Func_list_join_from_list_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_join_from_list_1 output = new Vx.Core.Class_list_join_from_list_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_join_from_list_1 output = new Vx.Core.Class_list_join_from_list_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_join_from_list_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_join_from_list_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_any fn_any_from_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

    public X vx_list_join_from_list_1<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any fn_any_from_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
      X output = Vx.Core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

  }

  public static Vx.Core.Func_list_join_from_list_1 e_list_join_from_list_1 = new Vx.Core.Class_list_join_from_list_1();
  public static Vx.Core.Func_list_join_from_list_1 t_list_join_from_list_1 = new Vx.Core.Class_list_join_from_list_1();

  public static X f_list_join_from_list_1<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any fn_any_from_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.vx_list_join_from_list_1(generic_list_1, values, fn_any_from_any);
    return output;
  }

  /**
   * @function list_from_list
   * Return a list with allowed values from another list
   * @param  {list-2} values
   * @return {list-1}
   * (func list<-list)
   */
  public interface Func_list_from_list : Vx.Core.Func_any_from_any {
    public X vx_list_from_list<X, Y>(X generic_list_1, Y values) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list;
  }

  public class Class_list_from_list : Vx.Core.Class_base, Func_list_from_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_list output = new Vx.Core.Class_list_from_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_list output = new Vx.Core.Class_list_from_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_list;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_list_from_list(Vx.Core.t_list, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_list_from_list(generic_list_1, values);
      return output;
    }

    public X vx_list_from_list<X, Y>(X generic_list_1, Y values) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
      X output = Vx.Core.f_list_from_list(generic_list_1, values);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_list e_list_from_list = new Vx.Core.Class_list_from_list();
  public static Vx.Core.Func_list_from_list t_list_from_list = new Vx.Core.Class_list_from_list();

  public static X f_list_from_list<X, Y>(X generic_list_1, Y values) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.f_list_from_list_1(
      generic_list_1,
      values,
      Vx.Core.t_any_from_any.vx_fn_new((value_any) => {
        Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, value_any);
        Vx.Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function list_from_list 1
   * Returns a list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-any} fn-any<-any
   * @return {list-1}
   * (func list<-list)
   */
  public interface Func_list_from_list_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public X vx_list_from_list_1<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any fn_any_from_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list;
  }

  public class Class_list_from_list_1 : Vx.Core.Class_base, Func_list_from_list_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_list_1 output = new Vx.Core.Class_list_from_list_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_list_1 output = new Vx.Core.Class_list_from_list_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_list_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_list_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_any fn_any_from_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_list_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

    public X vx_list_from_list_1<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any fn_any_from_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
      X output = Vx.Core.f_list_from_list_1(generic_list_1, values, fn_any_from_any);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_list_1 e_list_from_list_1 = new Vx.Core.Class_list_from_list_1();
  public static Vx.Core.Func_list_from_list_1 t_list_from_list_1 = new Vx.Core.Class_list_from_list_1();

  public static X f_list_from_list_1<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any fn_any_from_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.vx_list_from_list_1(generic_list_1, values, fn_any_from_any);
    return output;
  }

  /**
   * 
   * @async
   * @function list_from_list_async
   * Returns an asynchronous list of the processed asynchronous items from another list
   * @param  {list-2} values
   * @param  {any<-any-async} fn-any<-any-async
   * @return {list-1}
   * (func list<-list-async)
   */
  public interface Func_list_from_list_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<X> vx_list_from_list_async<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any_async fn_any_from_any_async) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list;
  }

  public class Class_list_from_list_async : Vx.Core.Class_base, Func_list_from_list_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_list_async output = new Vx.Core.Class_list_from_list_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_list_async output = new Vx.Core.Class_list_from_list_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_list_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_list_async;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_any_async fn_any_from_any_async = Vx.Core.f_any_from_any(Vx.Core.t_any_from_any_async, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Task<Vx.Core.Type_list> future = Vx.Core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<X> vx_list_from_list_async<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any_async fn_any_from_any_async) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
      Task<X> output = Vx.Core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_list_async e_list_from_list_async = new Vx.Core.Class_list_from_list_async();
  public static Vx.Core.Func_list_from_list_async t_list_from_list_async = new Vx.Core.Class_list_from_list_async();

  public static Task<X> f_list_from_list_async<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_any_async fn_any_from_any_async) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
    Task<X> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_list_1));
    output = Vx.Core.vx_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
    return output;
  }

  /**
   * @function list_from_list_intany
   * Returns a list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-int-any} fn-any<-int-any
   * @return {list-1}
   * (func list<-list-intany)
   */
  public interface Func_list_from_list_intany : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public X vx_list_from_list_intany<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_int_any fn_any_from_int_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list;
  }

  public class Class_list_from_list_intany : Vx.Core.Class_base, Func_list_from_list_intany {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_list_intany output = new Vx.Core.Class_list_from_list_intany();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_list_intany output = new Vx.Core.Class_list_from_list_intany();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-intany", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_list_intany;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_list_intany;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list values = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_int_any fn_any_from_int_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_int_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
      return output;
    }

    public X vx_list_from_list_intany<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_int_any fn_any_from_int_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
      X output = Vx.Core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_list_intany e_list_from_list_intany = new Vx.Core.Class_list_from_list_intany();
  public static Vx.Core.Func_list_from_list_intany t_list_from_list_intany = new Vx.Core.Class_list_from_list_intany();

  public static X f_list_from_list_intany<X, Y>(X generic_list_1, Y values, Vx.Core.Func_any_from_int_any fn_any_from_int_any) where X : Vx.Core.Type_list where Y : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.vx_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
    return output;
  }

  /**
   * @function list_from_map
   * Returns a list of allowed values from a map.
   * @param  {map-2} valuemap
   * @return {list-1}
   * (func list<-map)
   */
  public interface Func_list_from_map : Vx.Core.Func_any_from_any {
    public X vx_list_from_map<O, X>(X generic_list_1, O valuemap) where O : Vx.Core.Type_map where X : Vx.Core.Type_list;
  }

  public class Class_list_from_map : Vx.Core.Class_base, Func_list_from_map {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_map output = new Vx.Core.Class_list_from_map();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_map output = new Vx.Core.Class_list_from_map();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_map;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_map;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_map inputval = (Vx.Core.Type_map)value;
      Vx.Core.Type_any outputval = Vx.Core.f_list_from_map(Vx.Core.t_list, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_list_from_map(generic_list_1, valuemap);
      return output;
    }

    public X vx_list_from_map<O, X>(X generic_list_1, O valuemap) where O : Vx.Core.Type_map where X : Vx.Core.Type_list {
      X output = Vx.Core.f_list_from_map(generic_list_1, valuemap);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_map e_list_from_map = new Vx.Core.Class_list_from_map();
  public static Vx.Core.Func_list_from_map t_list_from_map = new Vx.Core.Class_list_from_map();

  public static X f_list_from_map<O, X>(X generic_list_1, O valuemap) where O : Vx.Core.Type_map where X : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.f_list_from_map_1(
      generic_list_1,
      valuemap,
      Vx.Core.t_any_from_key_value.vx_fn_new((key_any, value_any) => {
        Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, key_any);
        Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, value_any);
        Vx.Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function list_from_map 1
   * Returns a list from a map by applying a function to each key value.
   * @param  {map-2} valuemap
   * @param  {any<-key-value} fn-any<-key-value
   * @return {list-1}
   * (func list<-map)
   */
  public interface Func_list_from_map_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public X vx_list_from_map_1<O, X>(X generic_list_1, O valuemap, Vx.Core.Func_any_from_key_value fn_any_from_key_value) where O : Vx.Core.Type_map where X : Vx.Core.Type_list;
  }

  public class Class_list_from_map_1 : Vx.Core.Class_base, Func_list_from_map_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_map_1 output = new Vx.Core.Class_list_from_map_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_map_1 output = new Vx.Core.Class_list_from_map_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_map_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_map_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_key_value fn_any_from_key_value = Vx.Core.f_any_from_any(Vx.Core.t_any_from_key_value, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value);
      return output;
    }

    public X vx_list_from_map_1<O, X>(X generic_list_1, O valuemap, Vx.Core.Func_any_from_key_value fn_any_from_key_value) where O : Vx.Core.Type_map where X : Vx.Core.Type_list {
      X output = Vx.Core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_map_1 e_list_from_map_1 = new Vx.Core.Class_list_from_map_1();
  public static Vx.Core.Func_list_from_map_1 t_list_from_map_1 = new Vx.Core.Class_list_from_map_1();

  public static X f_list_from_map_1<O, X>(X generic_list_1, O valuemap, Vx.Core.Func_any_from_key_value fn_any_from_key_value) where O : Vx.Core.Type_map where X : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.vx_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value);
    return output;
  }

  /**
   * 
   * @async
   * @function list_from_map_async
   * @param  {map-2} valuemap
   * @param  {any<-key-value-async} fn-any<-key-value-async
   * @return {list-1}
   * (func list<-map-async)
   */
  public interface Func_list_from_map_async : Vx.Core.Type_func, Vx.Core.Type_replfunc_async {
    public Task<X> vx_list_from_map_async<O, X>(X generic_list_1, O valuemap, Vx.Core.Func_any_from_key_value_async fn_any_from_key_value_async) where O : Vx.Core.Type_map where X : Vx.Core.Type_list;
  }

  public class Class_list_from_map_async : Vx.Core.Class_base, Func_list_from_map_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_map_async output = new Vx.Core.Class_list_from_map_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_map_async output = new Vx.Core.Class_list_from_map_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-map-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_map_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_map_async;
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_key_value_async fn_any_from_key_value_async = Vx.Core.f_any_from_any(Vx.Core.t_any_from_key_value_async, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Task<Vx.Core.Type_list> future = Vx.Core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<X> vx_list_from_map_async<O, X>(X generic_list_1, O valuemap, Vx.Core.Func_any_from_key_value_async fn_any_from_key_value_async) where O : Vx.Core.Type_map where X : Vx.Core.Type_list {
      Task<X> output = Vx.Core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_map_async e_list_from_map_async = new Vx.Core.Class_list_from_map_async();
  public static Vx.Core.Func_list_from_map_async t_list_from_map_async = new Vx.Core.Class_list_from_map_async();

  public static Task<X> f_list_from_map_async<O, X>(X generic_list_1, O valuemap, Vx.Core.Func_any_from_key_value_async fn_any_from_key_value_async) where O : Vx.Core.Type_map where X : Vx.Core.Type_list {
    Task<X> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_list_1));
    return output;
  }

  /**
   * @function list_from_type
   * Create an empty list from a type. Used internally for default lists
   * @param  {any} type
   * @return {any}
   * (func list<-type)
   */
  public interface Func_list_from_type : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_any vx_list_from_type(Vx.Core.Type_any type);
  }

  public class Class_list_from_type : Vx.Core.Class_base, Func_list_from_type {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_list_from_type output = new Vx.Core.Class_list_from_type();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_list_from_type output = new Vx.Core.Class_list_from_type();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "list<-type", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_list_from_type;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_list_from_type;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_list_from_type(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any type = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_list_from_type(type);
      return output;
    }

    public Vx.Core.Type_any vx_list_from_type(Vx.Core.Type_any type) {
      Vx.Core.Type_any output = Vx.Core.f_list_from_type(type);
      return output;
    }

  }

  public static Vx.Core.Func_list_from_type e_list_from_type = new Vx.Core.Class_list_from_type();
  public static Vx.Core.Func_list_from_type t_list_from_type = new Vx.Core.Class_list_from_type();

  public static Vx.Core.Type_any f_list_from_type(Vx.Core.Type_any type) {
    Vx.Core.Type_any output = Vx.Core.e_any;
    return output;
  }

  /**
   * @function log
   * Writes a value to the console.
   * @param  {any} value
   * @return {any}
   * (func log)
   */
  public interface Func_log : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_any vx_log(Vx.Core.Type_any value);
  }

  public class Class_log : Vx.Core.Class_base, Func_log {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_log output = new Vx.Core.Class_log();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_log output = new Vx.Core.Class_log();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_log;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_log;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_log(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_log(value);
      return output;
    }

    public Vx.Core.Type_any vx_log(Vx.Core.Type_any value) {
      Vx.Core.Type_any output = Vx.Core.f_log(value);
      return output;
    }

  }

  public static Vx.Core.Func_log e_log = new Vx.Core.Class_log();
  public static Vx.Core.Func_log t_log = new Vx.Core.Class_log();

  public static Vx.Core.Type_any f_log(Vx.Core.Type_any value) {
    Vx.Core.Type_any output = Vx.Core.e_any;
    Vx.Core.vx_log(value);
    output = value;
    return output;
  }

  /**
   * @function log 1
   * Writes a string and a value to the console.
   * @param  {string} text
   * @param  {any-1} value
   * @return {any-1}
   * (func log)
   */
  public interface Func_log_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_log_1<T>(T generic_any_1, Vx.Core.Type_string text, T value) where T : Vx.Core.Type_any;
  }

  public class Class_log_1 : Vx.Core.Class_base, Func_log_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_log_1 output = new Vx.Core.Class_log_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_log_1 output = new Vx.Core.Class_log_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_log_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_log_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_log_1(generic_any_1, text, value);
      return output;
    }

    public T vx_log_1<T>(T generic_any_1, Vx.Core.Type_string text, T value) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_log_1(generic_any_1, text, value);
      return output;
    }

  }

  public static Vx.Core.Func_log_1 e_log_1 = new Vx.Core.Class_log_1();
  public static Vx.Core.Func_log_1 t_log_1 = new Vx.Core.Class_log_1();

  public static T f_log_1<T>(T generic_any_1, Vx.Core.Type_string text, T value) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    Vx.Core.vx_log(text);
    Vx.Core.vx_log(value);
    output = value;
    return output;
  }

  /**
   * @function main
   * The default function for app main execution. Arguments come from the command line.
   * @param  {anylist} args
   * @return {string}
   * (func main)
   */
  public interface Func_main : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_main(Vx.Core.Type_anylist args);
  }

  public class Class_main : Vx.Core.Class_base, Func_main {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_main output = new Vx.Core.Class_main();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_main output = new Vx.Core.Class_main();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "main", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_main;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_main;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_main(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_anylist args = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_main(args);
      return output;
    }

    public Vx.Core.Type_string vx_main(Vx.Core.Type_anylist args) {
      Vx.Core.Type_string output = Vx.Core.f_main(args);
      return output;
    }

  }

  public static Vx.Core.Func_main e_main = new Vx.Core.Class_main();
  public static Vx.Core.Func_main t_main = new Vx.Core.Class_main();

  public static Vx.Core.Type_string f_main(Vx.Core.Type_anylist args) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_new(
      Vx.Core.t_string,
      args
    );
    return output;
  }

  /**
   * @function map_from_list
   * Returns a map from a list by applying a function to generate a key for each value.
   * @param  {list-2} vallist
   * @param  {any<-any} fn-any<-any
   * @return {map-1}
   * (func map<-list)
   */
  public interface Func_map_from_list : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public N vx_map_from_list<N, Y>(N generic_map_1, Y vallist, Vx.Core.Func_any_from_any fn_any_from_any) where N : Vx.Core.Type_map where Y : Vx.Core.Type_list;
  }

  public class Class_map_from_list : Vx.Core.Class_base, Func_map_from_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_map_from_list output = new Vx.Core.Class_map_from_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_map_from_list output = new Vx.Core.Class_map_from_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "map<-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_map_from_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_map_from_list;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_map generic_map_1 = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list vallist = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_any fn_any_from_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_map_from_list(generic_map_1, vallist, fn_any_from_any);
      return output;
    }

    public N vx_map_from_list<N, Y>(N generic_map_1, Y vallist, Vx.Core.Func_any_from_any fn_any_from_any) where N : Vx.Core.Type_map where Y : Vx.Core.Type_list {
      N output = Vx.Core.f_map_from_list(generic_map_1, vallist, fn_any_from_any);
      return output;
    }

  }

  public static Vx.Core.Func_map_from_list e_map_from_list = new Vx.Core.Class_map_from_list();
  public static Vx.Core.Func_map_from_list t_map_from_list = new Vx.Core.Class_map_from_list();

  public static N f_map_from_list<N, Y>(N generic_map_1, Y vallist, Vx.Core.Func_any_from_any fn_any_from_any) where N : Vx.Core.Type_map where Y : Vx.Core.Type_list {
    N output = Vx.Core.f_empty(generic_map_1);
    output = Vx.Core.vx_map_from_list(generic_map_1, vallist, fn_any_from_any);
    return output;
  }

  /**
   * @function map_from_map
   * Return a map with allowed values from another map
   * @param  {map-2} valuemap
   * @return {map-1}
   * (func map<-map)
   */
  public interface Func_map_from_map : Vx.Core.Func_any_from_any {
    public N vx_map_from_map<N, O>(N generic_map_1, O valuemap) where N : Vx.Core.Type_map where O : Vx.Core.Type_map;
  }

  public class Class_map_from_map : Vx.Core.Class_base, Func_map_from_map {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_map_from_map output = new Vx.Core.Class_map_from_map();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_map_from_map output = new Vx.Core.Class_map_from_map();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_map_from_map;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_map_from_map;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_map inputval = (Vx.Core.Type_map)value;
      Vx.Core.Type_any outputval = Vx.Core.f_map_from_map(Vx.Core.t_map, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_map generic_map_1 = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_map_from_map(generic_map_1, valuemap);
      return output;
    }

    public N vx_map_from_map<N, O>(N generic_map_1, O valuemap) where N : Vx.Core.Type_map where O : Vx.Core.Type_map {
      N output = Vx.Core.f_map_from_map(generic_map_1, valuemap);
      return output;
    }

  }

  public static Vx.Core.Func_map_from_map e_map_from_map = new Vx.Core.Class_map_from_map();
  public static Vx.Core.Func_map_from_map t_map_from_map = new Vx.Core.Class_map_from_map();

  public static N f_map_from_map<N, O>(N generic_map_1, O valuemap) where N : Vx.Core.Type_map where O : Vx.Core.Type_map {
    N output = Vx.Core.f_empty(generic_map_1);
    output = Vx.Core.f_map_from_map_1(
      generic_map_1,
      valuemap,
      Vx.Core.t_any_from_key_value.vx_fn_new((key_any, value_any) => {
        Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, key_any);
        Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, value_any);
        Vx.Core.Type_any output_1 = value;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function map_from_map 1
   * Returns a map from a map by applying a function to each key value.
   * @param  {map-2} valuemap
   * @param  {any<-key-value} fn-any<-key-value
   * @return {map-1}
   * (func map<-map)
   */
  public interface Func_map_from_map_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public N vx_map_from_map_1<N, O>(N generic_map_1, O valuemap, Vx.Core.Func_any_from_key_value fn_any_from_key_value) where N : Vx.Core.Type_map where O : Vx.Core.Type_map;
  }

  public class Class_map_from_map_1 : Vx.Core.Class_base, Func_map_from_map_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_map_from_map_1 output = new Vx.Core.Class_map_from_map_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_map_from_map_1 output = new Vx.Core.Class_map_from_map_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_map_from_map_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_map_from_map_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_map generic_map_1 = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_map valuemap = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_key_value fn_any_from_key_value = Vx.Core.f_any_from_any(Vx.Core.t_any_from_key_value, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value);
      return output;
    }

    public N vx_map_from_map_1<N, O>(N generic_map_1, O valuemap, Vx.Core.Func_any_from_key_value fn_any_from_key_value) where N : Vx.Core.Type_map where O : Vx.Core.Type_map {
      N output = Vx.Core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value);
      return output;
    }

  }

  public static Vx.Core.Func_map_from_map_1 e_map_from_map_1 = new Vx.Core.Class_map_from_map_1();
  public static Vx.Core.Func_map_from_map_1 t_map_from_map_1 = new Vx.Core.Class_map_from_map_1();

  public static N f_map_from_map_1<N, O>(N generic_map_1, O valuemap, Vx.Core.Func_any_from_key_value fn_any_from_key_value) where N : Vx.Core.Type_map where O : Vx.Core.Type_map {
    N output = Vx.Core.f_empty(generic_map_1);
    output = Vx.Core.vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value);
    return output;
  }

  /**
   * @function msg_from_error
   * Returns a msg from error string
   * @param  {string} error
   * @return {msg}
   * (func msg<-error)
   */
  public interface Func_msg_from_error : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_msg vx_msg_from_error(Vx.Core.Type_string error);
  }

  public class Class_msg_from_error : Vx.Core.Class_base, Func_msg_from_error {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_msg_from_error output = new Vx.Core.Class_msg_from_error();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_msg_from_error output = new Vx.Core.Class_msg_from_error();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msg_from_error;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msg_from_error;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_msg_from_error(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string error = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_msg_from_error(error);
      return output;
    }

    public Vx.Core.Type_msg vx_msg_from_error(Vx.Core.Type_string error) {
      Vx.Core.Type_msg output = Vx.Core.f_msg_from_error(error);
      return output;
    }

  }

  public static Vx.Core.Func_msg_from_error e_msg_from_error = new Vx.Core.Class_msg_from_error();
  public static Vx.Core.Func_msg_from_error t_msg_from_error = new Vx.Core.Class_msg_from_error();

  public static Vx.Core.Type_msg f_msg_from_error(Vx.Core.Type_string error) {
    Vx.Core.Type_msg output = Vx.Core.e_msg;
    output = Vx.Core.f_new(
      Vx.Core.t_msg,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":severity"),
        Vx.Core.c_msg_error,
        Vx.Core.vx_new_string(":text"),
        error
      )
    );
    return output;
  }

  /**
   * @function msg_from_error 1
   * Returns a msg from error code and detail
   * @param  {string} code
   * @param  {any} detail
   * @return {msg}
   * (func msg<-error)
   */
  public interface Func_msg_from_error_1 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_msg vx_msg_from_error_1(Vx.Core.Type_string code, Vx.Core.Type_any detail);
  }

  public class Class_msg_from_error_1 : Vx.Core.Class_base, Func_msg_from_error_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_msg_from_error_1 output = new Vx.Core.Class_msg_from_error_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_msg_from_error_1 output = new Vx.Core.Class_msg_from_error_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msg_from_error_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msg_from_error_1;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string code = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any detail = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_msg_from_error_1(code, detail);
      return output;
    }

    public Vx.Core.Type_msg vx_msg_from_error_1(Vx.Core.Type_string code, Vx.Core.Type_any detail) {
      Vx.Core.Type_msg output = Vx.Core.f_msg_from_error_1(code, detail);
      return output;
    }

  }

  public static Vx.Core.Func_msg_from_error_1 e_msg_from_error_1 = new Vx.Core.Class_msg_from_error_1();
  public static Vx.Core.Func_msg_from_error_1 t_msg_from_error_1 = new Vx.Core.Class_msg_from_error_1();

  public static Vx.Core.Type_msg f_msg_from_error_1(Vx.Core.Type_string code, Vx.Core.Type_any detail) {
    Vx.Core.Type_msg output = Vx.Core.e_msg;
    output = Vx.Core.f_new(
      Vx.Core.t_msg,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":code"),
        code,
        Vx.Core.vx_new_string(":detail"),
        detail,
        Vx.Core.vx_new_string(":severity"),
        Vx.Core.c_msg_error
      )
    );
    return output;
  }

  /**
   * @function msg_from_error 2
   * Returns a msg from error path code and detail
   * @param  {string} path
   * @param  {string} code
   * @param  {any} detail
   * @return {msg}
   * (func msg<-error)
   */
  public interface Func_msg_from_error_2 : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_msg vx_msg_from_error_2(Vx.Core.Type_string path, Vx.Core.Type_string code, Vx.Core.Type_any detail);
  }

  public class Class_msg_from_error_2 : Vx.Core.Class_base, Func_msg_from_error_2 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_msg_from_error_2 output = new Vx.Core.Class_msg_from_error_2();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_msg_from_error_2 output = new Vx.Core.Class_msg_from_error_2();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        2, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msg_from_error_2;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msg_from_error_2;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string path = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string code = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_any detail = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_msg_from_error_2(path, code, detail);
      return output;
    }

    public Vx.Core.Type_msg vx_msg_from_error_2(Vx.Core.Type_string path, Vx.Core.Type_string code, Vx.Core.Type_any detail) {
      Vx.Core.Type_msg output = Vx.Core.f_msg_from_error_2(path, code, detail);
      return output;
    }

  }

  public static Vx.Core.Func_msg_from_error_2 e_msg_from_error_2 = new Vx.Core.Class_msg_from_error_2();
  public static Vx.Core.Func_msg_from_error_2 t_msg_from_error_2 = new Vx.Core.Class_msg_from_error_2();

  public static Vx.Core.Type_msg f_msg_from_error_2(Vx.Core.Type_string path, Vx.Core.Type_string code, Vx.Core.Type_any detail) {
    Vx.Core.Type_msg output = Vx.Core.e_msg;
    output = Vx.Core.f_new(
      Vx.Core.t_msg,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":code"),
        code,
        Vx.Core.vx_new_string(":path"),
        path,
        Vx.Core.vx_new_string(":severity"),
        Vx.Core.c_msg_error,
        Vx.Core.vx_new_string(":detail"),
        detail
      )
    );
    return output;
  }

  /**
   * @function msg_from_warning
   * Returns a msg from a warning string
   * @param  {string} warning
   * @return {msg}
   * (func msg<-warning)
   */
  public interface Func_msg_from_warning : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_msg vx_msg_from_warning(Vx.Core.Type_string warning);
  }

  public class Class_msg_from_warning : Vx.Core.Class_base, Func_msg_from_warning {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_msg_from_warning output = new Vx.Core.Class_msg_from_warning();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_msg_from_warning output = new Vx.Core.Class_msg_from_warning();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "msg<-warning", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msg_from_warning;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msg_from_warning;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_msg_from_warning(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string warning = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_msg_from_warning(warning);
      return output;
    }

    public Vx.Core.Type_msg vx_msg_from_warning(Vx.Core.Type_string warning) {
      Vx.Core.Type_msg output = Vx.Core.f_msg_from_warning(warning);
      return output;
    }

  }

  public static Vx.Core.Func_msg_from_warning e_msg_from_warning = new Vx.Core.Class_msg_from_warning();
  public static Vx.Core.Func_msg_from_warning t_msg_from_warning = new Vx.Core.Class_msg_from_warning();

  public static Vx.Core.Type_msg f_msg_from_warning(Vx.Core.Type_string warning) {
    Vx.Core.Type_msg output = Vx.Core.e_msg;
    output = Vx.Core.f_new(
      Vx.Core.t_msg,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":severity"),
        Vx.Core.c_msg_warning,
        Vx.Core.vx_new_string(":text"),
        warning
      )
    );
    return output;
  }

  /**
   * @function msgblock_from_msgblock_msg
   * Return a new Msgblock with the added msg
   * @param  {msgblock} origblock
   * @param  {msg} addmsg
   * @return {msgblock}
   * (func msgblock<-msgblock-msg)
   */
  public interface Func_msgblock_from_msgblock_msg : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_msgblock vx_msgblock_from_msgblock_msg(Vx.Core.Type_msgblock origblock, Vx.Core.Type_msg addmsg);
  }

  public class Class_msgblock_from_msgblock_msg : Vx.Core.Class_base, Func_msgblock_from_msgblock_msg {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_msgblock_from_msgblock_msg output = new Vx.Core.Class_msgblock_from_msgblock_msg();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_msgblock_from_msgblock_msg output = new Vx.Core.Class_msgblock_from_msgblock_msg();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msg", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msgblock_from_msgblock_msg;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msgblock_from_msgblock_msg;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_msgblock origblock = Vx.Core.f_any_from_any(Vx.Core.t_msgblock, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_msg addmsg = Vx.Core.f_any_from_any(Vx.Core.t_msg, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_msgblock_from_msgblock_msg(origblock, addmsg);
      return output;
    }

    public Vx.Core.Type_msgblock vx_msgblock_from_msgblock_msg(Vx.Core.Type_msgblock origblock, Vx.Core.Type_msg addmsg) {
      Vx.Core.Type_msgblock output = Vx.Core.f_msgblock_from_msgblock_msg(origblock, addmsg);
      return output;
    }

  }

  public static Vx.Core.Func_msgblock_from_msgblock_msg e_msgblock_from_msgblock_msg = new Vx.Core.Class_msgblock_from_msgblock_msg();
  public static Vx.Core.Func_msgblock_from_msgblock_msg t_msgblock_from_msgblock_msg = new Vx.Core.Class_msgblock_from_msgblock_msg();

  public static Vx.Core.Type_msgblock f_msgblock_from_msgblock_msg(Vx.Core.Type_msgblock origblock, Vx.Core.Type_msg addmsg) {
    Vx.Core.Type_msgblock output = Vx.Core.e_msgblock;
    output = Vx.Core.f_copy(
      origblock,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        addmsg
      )
    );
    return output;
  }

  /**
   * @function msgblock_from_msgblock_msgblock
   * Return a new Msgblock with the added block
   * @param  {msgblock} origblock
   * @param  {msgblock} addblock
   * @return {msgblock}
   * (func msgblock<-msgblock-msgblock)
   */
  public interface Func_msgblock_from_msgblock_msgblock : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_msgblock vx_msgblock_from_msgblock_msgblock(Vx.Core.Type_msgblock origblock, Vx.Core.Type_msgblock addblock);
  }

  public class Class_msgblock_from_msgblock_msgblock : Vx.Core.Class_base, Func_msgblock_from_msgblock_msgblock {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_msgblock_from_msgblock_msgblock output = new Vx.Core.Class_msgblock_from_msgblock_msgblock();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_msgblock_from_msgblock_msgblock output = new Vx.Core.Class_msgblock_from_msgblock_msgblock();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msgblock", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_msgblock_from_msgblock_msgblock;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_msgblock_from_msgblock_msgblock;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_msgblock origblock = Vx.Core.f_any_from_any(Vx.Core.t_msgblock, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_msgblock addblock = Vx.Core.f_any_from_any(Vx.Core.t_msgblock, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_msgblock_from_msgblock_msgblock(origblock, addblock);
      return output;
    }

    public Vx.Core.Type_msgblock vx_msgblock_from_msgblock_msgblock(Vx.Core.Type_msgblock origblock, Vx.Core.Type_msgblock addblock) {
      Vx.Core.Type_msgblock output = Vx.Core.f_msgblock_from_msgblock_msgblock(origblock, addblock);
      return output;
    }

  }

  public static Vx.Core.Func_msgblock_from_msgblock_msgblock e_msgblock_from_msgblock_msgblock = new Vx.Core.Class_msgblock_from_msgblock_msgblock();
  public static Vx.Core.Func_msgblock_from_msgblock_msgblock t_msgblock_from_msgblock_msgblock = new Vx.Core.Class_msgblock_from_msgblock_msgblock();

  public static Vx.Core.Type_msgblock f_msgblock_from_msgblock_msgblock(Vx.Core.Type_msgblock origblock, Vx.Core.Type_msgblock addblock) {
    Vx.Core.Type_msgblock output = Vx.Core.e_msgblock;
    output = Vx.Core.f_new(
      Vx.Core.t_msgblock,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        origblock,
        addblock
      )
    );
    return output;
  }

  /**
   * @function name_from_typedef
   * Returns the name from a typedef.
   * @param  {typedef} vtypedef
   * @return {string}
   * (func name<-typedef)
   */
  public interface Func_name_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_name_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_name_from_typedef : Vx.Core.Class_base, Func_name_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_name_from_typedef output = new Vx.Core.Class_name_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_name_from_typedef output = new Vx.Core.Class_name_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "name<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_name_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_name_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_name_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_name_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_string vx_name_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_string output = Vx.Core.f_name_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_name_from_typedef e_name_from_typedef = new Vx.Core.Class_name_from_typedef();
  public static Vx.Core.Func_name_from_typedef t_name_from_typedef = new Vx.Core.Class_name_from_typedef();

  public static Vx.Core.Type_string f_name_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = vtypedef.name();
    return output;
  }

  /**
   * @function native
   * Native Function Call
   * @param  {anylist} clauses
   * @return {any-1}
   * (func native)
   */
  public interface Func_native : Vx.Core.Func_any_from_any {
    public T vx_native<T>(T generic_any_1, Vx.Core.Type_anylist clauses) where T : Vx.Core.Type_any;
  }

  public class Class_native : Vx.Core.Class_base, Func_native {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_native output = new Vx.Core.Class_native();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_native output = new Vx.Core.Class_native();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "native", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_native;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_native;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_anylist inputval = (Vx.Core.Type_anylist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_native(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_anylist clauses = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_native(generic_any_1, clauses);
      return output;
    }

    public T vx_native<T>(T generic_any_1, Vx.Core.Type_anylist clauses) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_native(generic_any_1, clauses);
      return output;
    }

  }

  public static Vx.Core.Func_native e_native = new Vx.Core.Class_native();
  public static Vx.Core.Func_native t_native = new Vx.Core.Class_native();

  public static T f_native<T>(T generic_any_1, Vx.Core.Type_anylist clauses) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    return output;
  }

  /**
   * @function native_from_any
   * Returns native value of value object
   * @param  {any-1} value
   * @return {any}
   * (func native<-any)
   */
  public interface Func_native_from_any : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_any vx_native_from_any(Vx.Core.Type_any value);
  }

  public class Class_native_from_any : Vx.Core.Class_base, Func_native_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_native_from_any output = new Vx.Core.Class_native_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_native_from_any output = new Vx.Core.Class_native_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "native<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_native_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_native_from_any;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_native_from_any(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_native_from_any(value);
      return output;
    }

    public Vx.Core.Type_any vx_native_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_any output = Vx.Core.f_native_from_any(value);
      return output;
    }

  }

  public static Vx.Core.Func_native_from_any e_native_from_any = new Vx.Core.Class_native_from_any();
  public static Vx.Core.Func_native_from_any t_native_from_any = new Vx.Core.Class_native_from_any();

  public static Vx.Core.Type_any f_native_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_any output = Vx.Core.e_any;
    return output;
  }

  /**
   * @function new
   * Create a new Value of Type A
   * @param  {any-1} type
   * @param  {anylist} values
   * @return {any-1}
   * (func new)
   */
  public interface Func_new : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_new<T>(T type, Vx.Core.Type_anylist values) where T : Vx.Core.Type_any;
  }

  public class Class_new : Vx.Core.Class_base, Func_new {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_new output = new Vx.Core.Class_new();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_new output = new Vx.Core.Class_new();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "new", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_new;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_new;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any type = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_anylist values = Vx.Core.f_any_from_any(Vx.Core.t_anylist, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_new(type, values);
      return output;
    }

    public T vx_new<T>(T type, Vx.Core.Type_anylist values) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_new(type, values);
      return output;
    }

  }

  public static Vx.Core.Func_new e_new = new Vx.Core.Class_new();
  public static Vx.Core.Func_new t_new = new Vx.Core.Class_new();

  public static T f_new<T>(T type, Vx.Core.Type_anylist values) where T : Vx.Core.Type_any {
    Vx.Core.Type_any[] arrayany = Vx.Core.arrayany_from_anylist(values);
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));
    return output;
  }

  /**
   * @function number_from_func
   * Function Type returning number with any parameters
   * @return {number}
   * (func number<-func)
   */
  public interface Func_number_from_func : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_number vx_number_from_func();
  }

  public class Class_number_from_func : Vx.Core.Class_base, Func_number_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_number_from_func output = new Vx.Core.Class_number_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_number_from_func output = new Vx.Core.Class_number_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "number<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_int, Vx.Core.t_float, Vx.Core.t_decimal), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_number_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_number_from_func;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      output = Vx.Core.f_number_from_func();
      return output;
    }

    public Vx.Core.Type_number vx_number_from_func() {
      Vx.Core.Type_number output = Vx.Core.f_number_from_func();
      return output;
    }

  }

  public static Vx.Core.Func_number_from_func e_number_from_func = new Vx.Core.Class_number_from_func();
  public static Vx.Core.Func_number_from_func t_number_from_func = new Vx.Core.Class_number_from_func();

  public static Vx.Core.Type_number f_number_from_func() {
    Vx.Core.Type_number output = Vx.Core.e_number;
    return output;
  }

  /**
   * @function or
   * Returns true if any value is true
   * @param  {boolean} val1
   * @param  {boolean} val2
   * @return {boolean}
   * (func or)
   */
  public interface Func_or : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_boolean vx_or(Vx.Core.Type_boolean val1, Vx.Core.Type_boolean val2);
  }

  public class Class_or : Vx.Core.Class_base, Func_or {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_or output = new Vx.Core.Class_or();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_or output = new Vx.Core.Class_or();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_or;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_or;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_boolean val1 = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_boolean val2 = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_or(val1, val2);
      return output;
    }

    public Vx.Core.Type_boolean vx_or(Vx.Core.Type_boolean val1, Vx.Core.Type_boolean val2) {
      Vx.Core.Type_boolean output = Vx.Core.f_or(val1, val2);
      return output;
    }

  }

  public static Vx.Core.Func_or e_or = new Vx.Core.Class_or();
  public static Vx.Core.Func_or t_or = new Vx.Core.Class_or();

  public static Vx.Core.Type_boolean f_or(Vx.Core.Type_boolean val1, Vx.Core.Type_boolean val2) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Vx.Core.c_true;
    } else {
      output = Vx.Core.c_false;
    };
    return output;
  }

  /**
   * @function or 1
   * Returns true if any value is true
   * @param  {booleanlist} values
   * @return {boolean}
   * (func or)
   */
  public interface Func_or_1 : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_boolean vx_or_1(Vx.Core.Type_booleanlist values);
  }

  public class Class_or_1 : Vx.Core.Class_base, Func_or_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_or_1 output = new Vx.Core.Class_or_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_or_1 output = new Vx.Core.Class_or_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_or_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_or_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_booleanlist inputval = (Vx.Core.Type_booleanlist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_or_1(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_booleanlist values = Vx.Core.f_any_from_any(Vx.Core.t_booleanlist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_or_1(values);
      return output;
    }

    public Vx.Core.Type_boolean vx_or_1(Vx.Core.Type_booleanlist values) {
      Vx.Core.Type_boolean output = Vx.Core.f_or_1(values);
      return output;
    }

  }

  public static Vx.Core.Func_or_1 e_or_1 = new Vx.Core.Class_or_1();
  public static Vx.Core.Func_or_1 t_or_1 = new Vx.Core.Class_or_1();

  public static Vx.Core.Type_boolean f_or_1(Vx.Core.Type_booleanlist values) {
    Vx.Core.Type_boolean output = Vx.Core.e_boolean;
    output = Vx.Core.f_any_from_list_start_reduce_next(
      Vx.Core.t_boolean,
      values,
      Vx.Core.vx_new_boolean(false),
      Vx.Core.t_any_from_reduce_next.vx_fn_new((reduce_any, current_any, next_any) => {
        Vx.Core.Type_boolean reduce = Vx.Core.f_any_from_any(Vx.Core.t_boolean, reduce_any);
        Vx.Core.Type_boolean current = Vx.Core.f_any_from_any(Vx.Core.t_boolean, current_any);
        Vx.Core.Type_boolean next = Vx.Core.f_any_from_any(Vx.Core.t_boolean, next_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_or(
          reduce,
          Vx.Core.f_or(
            current,
            next
          )
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function package_global_from_name
   * Returns a package from global with the given name.
   * @param  {string} name
   * @return {package}
   * (func package-global<-name)
   */
  public interface Func_package_global_from_name : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_package vx_package_global_from_name(Vx.Core.Type_string name);
  }

  public class Class_package_global_from_name : Vx.Core.Class_base, Func_package_global_from_name {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_package_global_from_name output = new Vx.Core.Class_package_global_from_name();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_package_global_from_name output = new Vx.Core.Class_package_global_from_name();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "package-global<-name", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "package", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_package_global_from_name;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_package_global_from_name;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_package_global_from_name(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string name = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_package_global_from_name(name);
      return output;
    }

    public Vx.Core.Type_package vx_package_global_from_name(Vx.Core.Type_string name) {
      Vx.Core.Type_package output = Vx.Core.f_package_global_from_name(name);
      return output;
    }

  }

  public static Vx.Core.Func_package_global_from_name e_package_global_from_name = new Vx.Core.Class_package_global_from_name();
  public static Vx.Core.Func_package_global_from_name t_package_global_from_name = new Vx.Core.Class_package_global_from_name();

  public static Vx.Core.Type_package f_package_global_from_name(Vx.Core.Type_string name) {
    Vx.Core.Type_package output = Vx.Core.e_package;
    output = Vx.Core.f_any_from_map(
      Vx.Core.t_package,
      Vx.Core.c_global.packagemap(),
      name
    );
    return output;
  }

  /**
   * @function packagename_from_typedef
   * Returns the package name from a typedef.
   * @param  {typedef} vtypedef
   * @return {string}
   * (func packagename<-typedef)
   */
  public interface Func_packagename_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_packagename_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_packagename_from_typedef : Vx.Core.Class_base, Func_packagename_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_packagename_from_typedef output = new Vx.Core.Class_packagename_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_packagename_from_typedef output = new Vx.Core.Class_packagename_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "packagename<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_packagename_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_packagename_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_packagename_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_packagename_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_string vx_packagename_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_string output = Vx.Core.f_packagename_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_packagename_from_typedef e_packagename_from_typedef = new Vx.Core.Class_packagename_from_typedef();
  public static Vx.Core.Func_packagename_from_typedef t_packagename_from_typedef = new Vx.Core.Class_packagename_from_typedef();

  public static Vx.Core.Type_string f_packagename_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = vtypedef.pkgname();
    return output;
  }

  /**
   * @function path_from_context_path
   * Returns a path from a context
   * @param  {string} path
   * @return {string}
   * (func path<-context-path)
   */
  public interface Func_path_from_context_path : Vx.Core.Func_any_from_any_context {
    public Vx.Core.Type_string vx_path_from_context_path(Vx.Core.Type_context context, Vx.Core.Type_string path);
  }

  public class Class_path_from_context_path : Vx.Core.Class_base, Func_path_from_context_path {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_path_from_context_path output = new Vx.Core.Class_path_from_context_path();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_path_from_context_path output = new Vx.Core.Class_path_from_context_path();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "path<-context-path", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_path_from_context_path;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_path_from_context_path;
      return output;
    }

    public Vx.Core.Func_any_from_any_context vx_fn_new(Vx.Core.Class_any_from_any_context.IFn fn) {
      return Vx.Core.e_any_from_any_context;
    }

    public T vx_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_path_from_context_path(context, inputval);
      output = Vx.Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string path = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_path_from_context_path(context, path);
      return output;
    }

    public Vx.Core.Type_string vx_path_from_context_path(Vx.Core.Type_context context, Vx.Core.Type_string path) {
      Vx.Core.Type_string output = Vx.Core.f_path_from_context_path(context, path);
      return output;
    }

  }

  public static Vx.Core.Func_path_from_context_path e_path_from_context_path = new Vx.Core.Class_path_from_context_path();
  public static Vx.Core.Func_path_from_context_path t_path_from_context_path = new Vx.Core.Class_path_from_context_path();

  public static Vx.Core.Type_string f_path_from_context_path(Vx.Core.Type_context context, Vx.Core.Type_string path) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_path_from_setting_path(
      Vx.Core.f_setting_from_context(
        context
      ),
      path
    );
    return output;
  }

  /**
   * @function path_from_setting_path
   * Returns a path from a setting
   * @param  {setting} session
   * @param  {string} path
   * @return {string}
   * (func path<-setting-path)
   */
  public interface Func_path_from_setting_path : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_string vx_path_from_setting_path(Vx.Core.Type_setting session, Vx.Core.Type_string path);
  }

  public class Class_path_from_setting_path : Vx.Core.Class_base, Func_path_from_setting_path {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_path_from_setting_path output = new Vx.Core.Class_path_from_setting_path();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_path_from_setting_path output = new Vx.Core.Class_path_from_setting_path();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "path<-setting-path", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_path_from_setting_path;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_path_from_setting_path;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_setting session = Vx.Core.f_any_from_any(Vx.Core.t_setting, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string path = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_path_from_setting_path(session, path);
      return output;
    }

    public Vx.Core.Type_string vx_path_from_setting_path(Vx.Core.Type_setting session, Vx.Core.Type_string path) {
      Vx.Core.Type_string output = Vx.Core.f_path_from_setting_path(session, path);
      return output;
    }

  }

  public static Vx.Core.Func_path_from_setting_path e_path_from_setting_path = new Vx.Core.Class_path_from_setting_path();
  public static Vx.Core.Func_path_from_setting_path t_path_from_setting_path = new Vx.Core.Class_path_from_setting_path();

  public static Vx.Core.Type_string f_path_from_setting_path(Vx.Core.Type_setting session, Vx.Core.Type_string path) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    return output;
  }

  /**
   * @function permission_from_id_context
   * Return a permission from context by id
   * @param  {string} id
   * @return {permission}
   * (func permission<-id-context)
   */
  public interface Func_permission_from_id_context : Vx.Core.Func_any_from_any_context {
    public Vx.Core.Type_permission vx_permission_from_id_context(Vx.Core.Type_context context, Vx.Core.Type_string id);
  }

  public class Class_permission_from_id_context : Vx.Core.Class_base, Func_permission_from_id_context {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_permission_from_id_context output = new Vx.Core.Class_permission_from_id_context();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_permission_from_id_context output = new Vx.Core.Class_permission_from_id_context();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "permission<-id-context", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "permission", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_permission_from_id_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_permission_from_id_context;
      return output;
    }

    public Vx.Core.Func_any_from_any_context vx_fn_new(Vx.Core.Class_any_from_any_context.IFn fn) {
      return Vx.Core.e_any_from_any_context;
    }

    public T vx_any_from_any_context<T, U>(T generic_any_1, Vx.Core.Type_context context, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_string inputval = (Vx.Core.Type_string)value;
      Vx.Core.Type_any outputval = Vx.Core.f_permission_from_id_context(context, inputval);
      output = Vx.Core.f_any_from_any_context(generic_any_1, context, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string id = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_permission_from_id_context(context, id);
      return output;
    }

    public Vx.Core.Type_permission vx_permission_from_id_context(Vx.Core.Type_context context, Vx.Core.Type_string id) {
      Vx.Core.Type_permission output = Vx.Core.f_permission_from_id_context(context, id);
      return output;
    }

  }

  public static Vx.Core.Func_permission_from_id_context e_permission_from_id_context = new Vx.Core.Class_permission_from_id_context();
  public static Vx.Core.Func_permission_from_id_context t_permission_from_id_context = new Vx.Core.Class_permission_from_id_context();

  public static Vx.Core.Type_permission f_permission_from_id_context(Vx.Core.Type_context context, Vx.Core.Type_string id) {
    Vx.Core.Type_permission output = Vx.Core.e_permission;
    output = Vx.Core.f_let(
      Vx.Core.t_permission,
      Vx.Core.t_any_from_func.vx_fn_new(() => {
        Vx.Core.Type_user user = Vx.Core.f_user_from_context(
          context
        );
        Vx.Core.Type_security security = user.security();
        Vx.Core.Type_permissionmap permissionmap = security.permissionmap();
        Vx.Core.Type_any output_1 = Vx.Core.f_any_from_map(
          Vx.Core.t_permission,
          permissionmap,
          Vx.Core.vx_new_string(":id")
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function properties_from_typedef
   * Return property map from typedef
   * @param  {typedef} vtypedef
   * @return {argmap}
   * (func properties<-typedef)
   */
  public interface Func_properties_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_argmap vx_properties_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_properties_from_typedef : Vx.Core.Class_base, Func_properties_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_properties_from_typedef output = new Vx.Core.Class_properties_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_properties_from_typedef output = new Vx.Core.Class_properties_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "properties<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "argmap", // name
          ":map", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_arg), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_properties_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_properties_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_properties_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_properties_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_argmap vx_properties_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_argmap output = Vx.Core.f_properties_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_properties_from_typedef e_properties_from_typedef = new Vx.Core.Class_properties_from_typedef();
  public static Vx.Core.Func_properties_from_typedef t_properties_from_typedef = new Vx.Core.Class_properties_from_typedef();

  public static Vx.Core.Type_argmap f_properties_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_argmap output = Vx.Core.e_argmap;
    output = vtypedef.properties();
    return output;
  }

  /**
   * @function proplast_from_typedef
   * Return last property from typedef
   * @param  {typedef} vtypedef
   * @return {arg}
   * (func proplast<-typedef)
   */
  public interface Func_proplast_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_arg vx_proplast_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_proplast_from_typedef : Vx.Core.Class_base, Func_proplast_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_proplast_from_typedef output = new Vx.Core.Class_proplast_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_proplast_from_typedef output = new Vx.Core.Class_proplast_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "proplast<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "arg", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_proplast_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_proplast_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_proplast_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_proplast_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_arg vx_proplast_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_arg output = Vx.Core.f_proplast_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_proplast_from_typedef e_proplast_from_typedef = new Vx.Core.Class_proplast_from_typedef();
  public static Vx.Core.Func_proplast_from_typedef t_proplast_from_typedef = new Vx.Core.Class_proplast_from_typedef();

  public static Vx.Core.Type_arg f_proplast_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_arg output = Vx.Core.e_arg;
    output = vtypedef.proplast();
    return output;
  }

  /**
   * @function resolve
   * @param  {any-1} value
   * @return {any-1}
   * (func resolve)
   */
  public interface Func_resolve : Vx.Core.Func_any_from_any {
    public T vx_resolve<T>(T generic_any_1, T value) where T : Vx.Core.Type_any;
  }

  public class Class_resolve : Vx.Core.Class_base, Func_resolve {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_resolve output = new Vx.Core.Class_resolve();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_resolve output = new Vx.Core.Class_resolve();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_resolve;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_resolve;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_resolve(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_resolve(generic_any_1, value);
      return output;
    }

    public T vx_resolve<T>(T generic_any_1, T value) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_resolve(generic_any_1, value);
      return output;
    }

  }

  public static Vx.Core.Func_resolve e_resolve = new Vx.Core.Class_resolve();
  public static Vx.Core.Func_resolve t_resolve = new Vx.Core.Class_resolve();

  public static T f_resolve<T>(T generic_any_1, T value) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    output = value;
    return output;
  }

  /**
   * @function resolve 1
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func resolve)
   */
  public interface Func_resolve_1 : Vx.Core.Func_any_from_any {
    public T vx_resolve_1<T>(T generic_any_1, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any;
  }

  public class Class_resolve_1 : Vx.Core.Class_base, Func_resolve_1 {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_resolve_1 output = new Vx.Core.Class_resolve_1();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_resolve_1 output = new Vx.Core.Class_resolve_1();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        1, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_resolve_1;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_resolve_1;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Func_any_from_func inputval = (Vx.Core.Func_any_from_func)value;
      Vx.Core.Type_any outputval = Vx.Core.f_resolve_1(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_resolve_1(generic_any_1, fn_any);
      return output;
    }

    public T vx_resolve_1<T>(T generic_any_1, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any {
      T output = Vx.Core.f_resolve_1(generic_any_1, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_resolve_1 e_resolve_1 = new Vx.Core.Class_resolve_1();
  public static Vx.Core.Func_resolve_1 t_resolve_1 = new Vx.Core.Class_resolve_1();

  public static T f_resolve_1<T>(T generic_any_1, Vx.Core.Func_any_from_func fn_any) where T : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    if (fn_any == null) {
    } else if (fn_any == Vx.Core.e_any_from_func) {
    } else {
      output = fn_any.vx_any_from_func(generic_any_1);
    };
    return output;
  }

  /**
   * 
   * @async
   * @function resolve_async
   * @param  {any<-func-async} fn-any
   * @return {any-1}
   * (func resolve-async)
   */
  public interface Func_resolve_async : Vx.Core.Func_any_from_any_async {
    public Task<T> vx_resolve_async<T>(T generic_any_1, Vx.Core.Func_any_from_func_async fn_any) where T : Vx.Core.Type_any;
  }

  public class Class_resolve_async : Vx.Core.Class_base, Func_resolve_async {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_resolve_async output = new Vx.Core.Class_resolve_async();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_resolve_async output = new Vx.Core.Class_resolve_async();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "resolve-async", // name
        0, // idx
        true, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_resolve_async;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_resolve_async;
      return output;
    }

    public Vx.Core.Func_any_from_any_async vx_fn_new(Vx.Core.Class_any_from_any_async.IFn fn) {
      return Vx.Core.e_any_from_any_async;
    }

    public Task<T> vx_any_from_any_async<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T inputval = Vx.Core.f_any_from_any(generic_any_1, value);
      Task<T> output = Vx.Core.f_async(generic_any_1, inputval);
      return output;
    }

    public Task<Vx.Core.Type_any> vx_repl(Vx.Core.Type_anylist arglist) {
      Task<Vx.Core.Type_any> output = Vx.Core.vx_async_new_from_value(Vx.Core.e_any);
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func_async fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func_async, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Task<Vx.Core.Type_any> future = Vx.Core.f_resolve_async(generic_any_1, fn_any);
      output = Vx.Core.vx_async_from_async(Vx.Core.t_any, future);
      return output;
    }

    public Task<T> vx_resolve_async<T>(T generic_any_1, Vx.Core.Func_any_from_func_async fn_any) where T : Vx.Core.Type_any {
      Task<T> output = Vx.Core.f_resolve_async(generic_any_1, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_resolve_async e_resolve_async = new Vx.Core.Class_resolve_async();
  public static Vx.Core.Func_resolve_async t_resolve_async = new Vx.Core.Class_resolve_async();

  public static Task<T> f_resolve_async<T>(T generic_any_1, Vx.Core.Func_any_from_func_async fn_any) where T : Vx.Core.Type_any {
    Task<T> output = Vx.Core.vx_async_new_from_value(Vx.Core.f_empty(generic_any_1));
    if (fn_any == null) {
    } else if (fn_any == Vx.Core.e_any_from_func_async) {
    } else {
      output = fn_any.vx_any_from_func_async(generic_any_1);
    };
    return output;
  }

  /**
   * @function resolve_first
   * Returns the first value that is not nothing
   * @param  {list-1} clauses
   * @return {any-1}
   * (func resolve-first)
   */
  public interface Func_resolve_first : Vx.Core.Func_any_from_any {
    public T vx_resolve_first<T, X>(T generic_any_1, X clauses) where T : Vx.Core.Type_any where X : Vx.Core.Type_list;
  }

  public class Class_resolve_first : Vx.Core.Class_base, Func_resolve_first {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_resolve_first output = new Vx.Core.Class_resolve_first();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_resolve_first output = new Vx.Core.Class_resolve_first();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "resolve-first", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_resolve_first;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_resolve_first;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_resolve_first(Vx.Core.t_any, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list clauses = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_resolve_first(generic_any_1, clauses);
      return output;
    }

    public T vx_resolve_first<T, X>(T generic_any_1, X clauses) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
      T output = Vx.Core.f_resolve_first(generic_any_1, clauses);
      return output;
    }

  }

  public static Vx.Core.Func_resolve_first e_resolve_first = new Vx.Core.Class_resolve_first();
  public static Vx.Core.Func_resolve_first t_resolve_first = new Vx.Core.Class_resolve_first();

  public static T f_resolve_first<T, X>(T generic_any_1, X clauses) where T : Vx.Core.Type_any where X : Vx.Core.Type_list {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.f_first_from_list_any_from_any(
      generic_any_1,
      clauses,
      Vx.Core.t_resolve
    );
    return output;
  }

  /**
   * @function resolve_list
   * @param  {list-1} clauses
   * @return {list-1}
   * (func resolve-list)
   */
  public interface Func_resolve_list : Vx.Core.Func_any_from_any {
    public X vx_resolve_list<X>(X generic_list_1, X clauses) where X : Vx.Core.Type_list;
  }

  public class Class_resolve_list : Vx.Core.Class_base, Func_resolve_list {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_resolve_list output = new Vx.Core.Class_resolve_list();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_resolve_list output = new Vx.Core.Class_resolve_list();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "resolve-list", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_resolve_list;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_resolve_list;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_list inputval = (Vx.Core.Type_list)value;
      Vx.Core.Type_any outputval = Vx.Core.f_resolve_list(Vx.Core.t_list, inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_list generic_list_1 = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_list clauses = Vx.Core.f_any_from_any(Vx.Core.t_list, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_resolve_list(generic_list_1, clauses);
      return output;
    }

    public X vx_resolve_list<X>(X generic_list_1, X clauses) where X : Vx.Core.Type_list {
      X output = Vx.Core.f_resolve_list(generic_list_1, clauses);
      return output;
    }

  }

  public static Vx.Core.Func_resolve_list e_resolve_list = new Vx.Core.Class_resolve_list();
  public static Vx.Core.Func_resolve_list t_resolve_list = new Vx.Core.Class_resolve_list();

  public static X f_resolve_list<X>(X generic_list_1, X clauses) where X : Vx.Core.Type_list {
    X output = Vx.Core.f_empty(generic_list_1);
    output = Vx.Core.f_list_from_list_1(
      generic_list_1,
      clauses,
      Vx.Core.t_resolve
    );
    return output;
  }

  /**
   * @function security_from_context
   * Return security from the given context.
   * @return {security}
   * (func security<-context)
   */
  public interface Func_security_from_context : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_security vx_security_from_context(Vx.Core.Type_context context);
  }

  public class Class_security_from_context : Vx.Core.Class_base, Func_security_from_context {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_security_from_context output = new Vx.Core.Class_security_from_context();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_security_from_context output = new Vx.Core.Class_security_from_context();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "security<-context", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_security_from_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_security_from_context;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_security_from_context(context);
      return output;
    }

    public Vx.Core.Type_security vx_security_from_context(Vx.Core.Type_context context) {
      Vx.Core.Type_security output = Vx.Core.f_security_from_context(context);
      return output;
    }

  }

  public static Vx.Core.Func_security_from_context e_security_from_context = new Vx.Core.Class_security_from_context();
  public static Vx.Core.Func_security_from_context t_security_from_context = new Vx.Core.Class_security_from_context();

  public static Vx.Core.Type_security f_security_from_context(Vx.Core.Type_context context) {
    Vx.Core.Type_security output = Vx.Core.e_security;
    output = Vx.Core.f_security_from_user(
      Vx.Core.f_user_from_context(
        context
      )
    );
    return output;
  }

  /**
   * @function security_from_user
   * Return security from the given user.
   * @param  {user} user
   * @return {security}
   * (func security<-user)
   */
  public interface Func_security_from_user : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_security vx_security_from_user(Vx.Core.Type_user user);
  }

  public class Class_security_from_user : Vx.Core.Class_base, Func_security_from_user {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_security_from_user output = new Vx.Core.Class_security_from_user();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_security_from_user output = new Vx.Core.Class_security_from_user();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "security<-user", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_security_from_user;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_security_from_user;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_user inputval = (Vx.Core.Type_user)value;
      Vx.Core.Type_any outputval = Vx.Core.f_security_from_user(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_user user = Vx.Core.f_any_from_any(Vx.Core.t_user, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_security_from_user(user);
      return output;
    }

    public Vx.Core.Type_security vx_security_from_user(Vx.Core.Type_user user) {
      Vx.Core.Type_security output = Vx.Core.f_security_from_user(user);
      return output;
    }

  }

  public static Vx.Core.Func_security_from_user e_security_from_user = new Vx.Core.Class_security_from_user();
  public static Vx.Core.Func_security_from_user t_security_from_user = new Vx.Core.Class_security_from_user();

  public static Vx.Core.Type_security f_security_from_user(Vx.Core.Type_user user) {
    Vx.Core.Type_security output = Vx.Core.e_security;
    output = user.security();
    return output;
  }

  /**
   * @function session_from_context
   * Returns session from a context
   * @return {session}
   * (func session<-context)
   */
  public interface Func_session_from_context : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_session vx_session_from_context(Vx.Core.Type_context context);
  }

  public class Class_session_from_context : Vx.Core.Class_base, Func_session_from_context {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_session_from_context output = new Vx.Core.Class_session_from_context();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_session_from_context output = new Vx.Core.Class_session_from_context();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "session<-context", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "session", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_session_from_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_session_from_context;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_session_from_context(context);
      return output;
    }

    public Vx.Core.Type_session vx_session_from_context(Vx.Core.Type_context context) {
      Vx.Core.Type_session output = Vx.Core.f_session_from_context(context);
      return output;
    }

  }

  public static Vx.Core.Func_session_from_context e_session_from_context = new Vx.Core.Class_session_from_context();
  public static Vx.Core.Func_session_from_context t_session_from_context = new Vx.Core.Class_session_from_context();

  public static Vx.Core.Type_session f_session_from_context(Vx.Core.Type_context context) {
    Vx.Core.Type_session output = Vx.Core.e_session;
    output = context.session();
    return output;
  }

  /**
   * @function setting_from_context
   * Returns setting from a context
   * @return {setting}
   * (func setting<-context)
   */
  public interface Func_setting_from_context : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_setting vx_setting_from_context(Vx.Core.Type_context context);
  }

  public class Class_setting_from_context : Vx.Core.Class_base, Func_setting_from_context {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_setting_from_context output = new Vx.Core.Class_setting_from_context();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_setting_from_context output = new Vx.Core.Class_setting_from_context();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "setting<-context", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "setting", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_setting_from_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_setting_from_context;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_setting_from_context(context);
      return output;
    }

    public Vx.Core.Type_setting vx_setting_from_context(Vx.Core.Type_context context) {
      Vx.Core.Type_setting output = Vx.Core.f_setting_from_context(context);
      return output;
    }

  }

  public static Vx.Core.Func_setting_from_context e_setting_from_context = new Vx.Core.Class_setting_from_context();
  public static Vx.Core.Func_setting_from_context t_setting_from_context = new Vx.Core.Class_setting_from_context();

  public static Vx.Core.Type_setting f_setting_from_context(Vx.Core.Type_context context) {
    Vx.Core.Type_setting output = Vx.Core.e_setting;
    output = context.setting();
    return output;
  }

  /**
   * @function string_repeat
   * @param  {string} text
   * @param  {int} repeat
   * @return {string}
   * (func string-repeat)
   */
  public interface Func_string_repeat : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_string vx_string_repeat(Vx.Core.Type_string text, Vx.Core.Type_int repeat);
  }

  public class Class_string_repeat : Vx.Core.Class_base, Func_string_repeat {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_string_repeat output = new Vx.Core.Class_string_repeat();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_string_repeat output = new Vx.Core.Class_string_repeat();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "string-repeat", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_string_repeat;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_string_repeat;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int repeat = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_string_repeat(text, repeat);
      return output;
    }

    public Vx.Core.Type_string vx_string_repeat(Vx.Core.Type_string text, Vx.Core.Type_int repeat) {
      Vx.Core.Type_string output = Vx.Core.f_string_repeat(text, repeat);
      return output;
    }

  }

  public static Vx.Core.Func_string_repeat e_string_repeat = new Vx.Core.Class_string_repeat();
  public static Vx.Core.Func_string_repeat t_string_repeat = new Vx.Core.Class_string_repeat();

  public static Vx.Core.Type_string f_string_repeat(Vx.Core.Type_string text, Vx.Core.Type_int repeat) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.vx_string_repeat(text, repeat);
    return output;
  }

  /**
   * @function string_from_any
   * Return a string representation of a value
   * @param  {any} value
   * @return {string}
   * (func string<-any)
   */
  public interface Func_string_from_any : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_string_from_any(Vx.Core.Type_any value);
  }

  public class Class_string_from_any : Vx.Core.Class_base, Func_string_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_string_from_any output = new Vx.Core.Class_string_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_string_from_any output = new Vx.Core.Class_string_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "string<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_string_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_string_from_any;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_string_from_any(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_string_from_any(value);
      return output;
    }

    public Vx.Core.Type_string vx_string_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_string output = Vx.Core.f_string_from_any(value);
      return output;
    }

  }

  public static Vx.Core.Func_string_from_any e_string_from_any = new Vx.Core.Class_string_from_any();
  public static Vx.Core.Func_string_from_any t_string_from_any = new Vx.Core.Class_string_from_any();

  public static Vx.Core.Type_string f_string_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_string_from_any_indent(
      value,
      Vx.Core.vx_new_int(0),
      Vx.Core.vx_new_boolean(true)
    );
    return output;
  }

  /**
   * @function string_from_any_indent
   * Return a string representation of a value
   * @param  {any} value
   * @param  {int} indent
   * @param  {boolean} linefeed
   * @return {string}
   * (func string<-any-indent)
   */
  public interface Func_string_from_any_indent : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_string vx_string_from_any_indent(Vx.Core.Type_any value, Vx.Core.Type_int indent, Vx.Core.Type_boolean linefeed);
  }

  public class Class_string_from_any_indent : Vx.Core.Class_base, Func_string_from_any_indent {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_string_from_any_indent output = new Vx.Core.Class_string_from_any_indent();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_string_from_any_indent output = new Vx.Core.Class_string_from_any_indent();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "string<-any-indent", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_string_from_any_indent;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_string_from_any_indent;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_int indent = Vx.Core.f_any_from_any(Vx.Core.t_int, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_boolean linefeed = Vx.Core.f_any_from_any(Vx.Core.t_boolean, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_string_from_any_indent(value, indent, linefeed);
      return output;
    }

    public Vx.Core.Type_string vx_string_from_any_indent(Vx.Core.Type_any value, Vx.Core.Type_int indent, Vx.Core.Type_boolean linefeed) {
      Vx.Core.Type_string output = Vx.Core.f_string_from_any_indent(value, indent, linefeed);
      return output;
    }

  }

  public static Vx.Core.Func_string_from_any_indent e_string_from_any_indent = new Vx.Core.Class_string_from_any_indent();
  public static Vx.Core.Func_string_from_any_indent t_string_from_any_indent = new Vx.Core.Class_string_from_any_indent();

  public static Vx.Core.Type_string f_string_from_any_indent(Vx.Core.Type_any value, Vx.Core.Type_int indent, Vx.Core.Type_boolean linefeed) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.vx_string_from_any_indent(value, indent, linefeed);
    return output;
  }

  /**
   * @function string_from_func
   * Function Type returning string with any parameters
   * @return {string}
   * (func string<-func)
   */
  public interface Func_string_from_func : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_string vx_string_from_func();
    public Vx.Core.Func_string_from_func vx_fn_new(Class_any_from_func.IFn fn);
  }

  public class Class_string_from_func : Vx.Core.Class_base, Func_string_from_func {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_string_from_func output = new Vx.Core.Class_string_from_func();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_string_from_func output = new Vx.Core.Class_string_from_func();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "string<-func", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_string_from_func;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_string_from_func;
      return output;
    }

    public Class_any_from_func.IFn? fn = null;

    public Vx.Core.Func_string_from_func vx_fn_new(Class_any_from_func.IFn fn) {
      Vx.Core.Class_string_from_func output = new Vx.Core.Class_string_from_func();
      output.fn = fn;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      output = Vx.Core.f_string_from_func();
      return output;
    }

    public Vx.Core.Type_string vx_string_from_func() {
      Vx.Core.Type_string output = Vx.Core.f_string_from_func();
      return output;
    }

  }

  public static Vx.Core.Func_string_from_func e_string_from_func = new Vx.Core.Class_string_from_func();
  public static Vx.Core.Func_string_from_func t_string_from_func = new Vx.Core.Class_string_from_func();

  public static Vx.Core.Type_string f_string_from_func() {
    Vx.Core.Type_string output = Vx.Core.e_string;
    return output;
  }

  /**
   * @function string_from_string_find_replace
   * Returns a string with all instances of find replaced by replace.
   * @param  {string} text
   * @param  {string} find
   * @param  {string} replace
   * @return {string}
   * (func string<-string-find-replace)
   */
  public interface Func_string_from_string_find_replace : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_string vx_string_from_string_find_replace(Vx.Core.Type_string text, Vx.Core.Type_string find, Vx.Core.Type_string replace);
  }

  public class Class_string_from_string_find_replace : Vx.Core.Class_base, Func_string_from_string_find_replace {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_string_from_string_find_replace output = new Vx.Core.Class_string_from_string_find_replace();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_string_from_string_find_replace output = new Vx.Core.Class_string_from_string_find_replace();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "string<-string-find-replace", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_string_from_string_find_replace;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_string_from_string_find_replace;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_string text = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_string find = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(1)));
      Vx.Core.Type_string replace = Vx.Core.f_any_from_any(Vx.Core.t_string, arglist.vx_any(Vx.Core.vx_new_int(2)));
      output = Vx.Core.f_string_from_string_find_replace(text, find, replace);
      return output;
    }

    public Vx.Core.Type_string vx_string_from_string_find_replace(Vx.Core.Type_string text, Vx.Core.Type_string find, Vx.Core.Type_string replace) {
      Vx.Core.Type_string output = Vx.Core.f_string_from_string_find_replace(text, find, replace);
      return output;
    }

  }

  public static Vx.Core.Func_string_from_string_find_replace e_string_from_string_find_replace = new Vx.Core.Class_string_from_string_find_replace();
  public static Vx.Core.Func_string_from_string_find_replace t_string_from_string_find_replace = new Vx.Core.Class_string_from_string_find_replace();

  public static Vx.Core.Type_string f_string_from_string_find_replace(Vx.Core.Type_string text, Vx.Core.Type_string find, Vx.Core.Type_string replace) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.vx_string_from_string_find_replace(text, find, replace);
    return output;
  }

  /**
   * @function stringlist_from_map
   * Returns a stringlist of keys from any map in entry order.
   * @param  {map-1} map
   * @return {stringlist}
   * (func stringlist<-map)
   */
  public interface Func_stringlist_from_map : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_stringlist vx_stringlist_from_map(Vx.Core.Type_map map);
  }

  public class Class_stringlist_from_map : Vx.Core.Class_base, Func_stringlist_from_map {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_stringlist_from_map output = new Vx.Core.Class_stringlist_from_map();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_stringlist_from_map output = new Vx.Core.Class_stringlist_from_map();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "stringlist<-map", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_string), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_stringlist_from_map;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_stringlist_from_map;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_map inputval = (Vx.Core.Type_map)value;
      Vx.Core.Type_any outputval = Vx.Core.f_stringlist_from_map(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_map map = Vx.Core.f_any_from_any(Vx.Core.t_map, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_stringlist_from_map(map);
      return output;
    }

    public Vx.Core.Type_stringlist vx_stringlist_from_map(Vx.Core.Type_map map) {
      Vx.Core.Type_stringlist output = Vx.Core.f_stringlist_from_map(map);
      return output;
    }

  }

  public static Vx.Core.Func_stringlist_from_map e_stringlist_from_map = new Vx.Core.Class_stringlist_from_map();
  public static Vx.Core.Func_stringlist_from_map t_stringlist_from_map = new Vx.Core.Class_stringlist_from_map();

  public static Vx.Core.Type_stringlist f_stringlist_from_map(Vx.Core.Type_map map) {
    Vx.Core.Type_stringlist output = Vx.Core.e_stringlist;
    output = Vx.Core.f_list_from_map_1(
      Vx.Core.t_stringlist,
      map,
      Vx.Core.t_any_from_key_value.vx_fn_new((key_any, value_any) => {
        Vx.Core.Type_string key = Vx.Core.f_any_from_any(Vx.Core.t_string, key_any);
        Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, value_any);
        Vx.Core.Type_any output_1 = key;
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function switch
   * Returns a value based on a logical switch
   * @param  {any-2} value
   * @param  {thenelselist} thenelselist
   * @return {any-1}
   * (func switch)
   */
  public interface Func_switch : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public T vx_switch<T, U>(T generic_any_1, U value, Vx.Core.Type_thenelselist thenelselist) where T : Vx.Core.Type_any where U : Vx.Core.Type_any;
  }

  public class Class_switch : Vx.Core.Class_base, Func_switch {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_switch output = new Vx.Core.Class_switch();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_switch output = new Vx.Core.Class_switch();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "switch", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_switch;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_switch;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any generic_any_1 = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Type_thenelselist thenelselist = Vx.Core.f_any_from_any(Vx.Core.t_thenelselist, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_switch(generic_any_1, value, thenelselist);
      return output;
    }

    public T vx_switch<T, U>(T generic_any_1, U value, Vx.Core.Type_thenelselist thenelselist) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_switch(generic_any_1, value, thenelselist);
      return output;
    }

  }

  public static Vx.Core.Func_switch e_switch = new Vx.Core.Class_switch();
  public static Vx.Core.Func_switch t_switch = new Vx.Core.Class_switch();

  public static T f_switch<T, U>(T generic_any_1, U value, Vx.Core.Type_thenelselist thenelselist) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
    T output = Vx.Core.f_empty(generic_any_1);
    output = Vx.Core.vx_switch(generic_any_1, value, thenelselist);
    return output;
  }

  /**
   * @function then
   * Returns a thenelse struct from a given condition function and value function
   * @param  {boolean<-func} fn-cond
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func then)
   */
  public interface Func_then : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_thenelse vx_then(Vx.Core.Func_boolean_from_func fn_cond, Vx.Core.Func_any_from_func fn_any);
  }

  public class Class_then : Vx.Core.Class_base, Func_then {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_then output = new Vx.Core.Class_then();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_then output = new Vx.Core.Class_then();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "then", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_then;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_then;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Func_boolean_from_func fn_cond = Vx.Core.f_any_from_any(Vx.Core.t_boolean_from_func, arglist.vx_any(Vx.Core.vx_new_int(0)));
      Vx.Core.Func_any_from_func fn_any = Vx.Core.f_any_from_any(Vx.Core.t_any_from_func, arglist.vx_any(Vx.Core.vx_new_int(1)));
      output = Vx.Core.f_then(fn_cond, fn_any);
      return output;
    }

    public Vx.Core.Type_thenelse vx_then(Vx.Core.Func_boolean_from_func fn_cond, Vx.Core.Func_any_from_func fn_any) {
      Vx.Core.Type_thenelse output = Vx.Core.f_then(fn_cond, fn_any);
      return output;
    }

  }

  public static Vx.Core.Func_then e_then = new Vx.Core.Class_then();
  public static Vx.Core.Func_then t_then = new Vx.Core.Class_then();

  public static Vx.Core.Type_thenelse f_then(Vx.Core.Func_boolean_from_func fn_cond, Vx.Core.Func_any_from_func fn_any) {
    Vx.Core.Type_thenelse output = Vx.Core.e_thenelse;
    output = Vx.Core.f_new(
      Vx.Core.t_thenelse,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        Vx.Core.vx_new_string(":code"),
        Vx.Core.vx_new_string(":then"),
        Vx.Core.vx_new_string(":fn-cond"),
        fn_cond,
        Vx.Core.vx_new_string(":fn-any"),
        fn_any
      )
    );
    return output;
  }

  /**
   * @function traits_from_typedef
   * Return trait list from type
   * @param  {typedef} vtypedef
   * @return {typelist}
   * (func traits<-typedef)
   */
  public interface Func_traits_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_typelist vx_traits_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_traits_from_typedef : Vx.Core.Class_base, Func_traits_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_traits_from_typedef output = new Vx.Core.Class_traits_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_traits_from_typedef output = new Vx.Core.Class_traits_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "traits<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_any), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_traits_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_traits_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_traits_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_traits_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_typelist vx_traits_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_typelist output = Vx.Core.f_traits_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_traits_from_typedef e_traits_from_typedef = new Vx.Core.Class_traits_from_typedef();
  public static Vx.Core.Func_traits_from_typedef t_traits_from_typedef = new Vx.Core.Class_traits_from_typedef();

  public static Vx.Core.Type_typelist f_traits_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_typelist output = Vx.Core.e_typelist;
    output = vtypedef.traits();
    return output;
  }

  /**
   * @function type_from_any
   * Gets the Type of a given Value
   * @param  {any-1} value
   * @return {any}
   * (func type<-any)
   */
  public interface Func_type_from_any : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_any vx_type_from_any(Vx.Core.Type_any value);
  }

  public class Class_type_from_any : Vx.Core.Class_base, Func_type_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_type_from_any output = new Vx.Core.Class_type_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_type_from_any output = new Vx.Core.Class_type_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "type<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_type_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_type_from_any;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_type_from_any(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_type_from_any(value);
      return output;
    }

    public Vx.Core.Type_any vx_type_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_any output = Vx.Core.f_type_from_any(value);
      return output;
    }

  }

  public static Vx.Core.Func_type_from_any e_type_from_any = new Vx.Core.Class_type_from_any();
  public static Vx.Core.Func_type_from_any t_type_from_any = new Vx.Core.Class_type_from_any();

  public static Vx.Core.Type_any f_type_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_any output = Vx.Core.e_any;
    output = value.vx_type();
    return output;
  }

  /**
   * @function typedef_from_any
   * Gets the typedef of a given value
   * @param  {any} value
   * @return {typedef}
   * (func typedef<-any)
   */
  public interface Func_typedef_from_any : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_typedef vx_typedef_from_any(Vx.Core.Type_any value);
  }

  public class Class_typedef_from_any : Vx.Core.Class_base, Func_typedef_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_typedef_from_any output = new Vx.Core.Class_typedef_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_typedef_from_any output = new Vx.Core.Class_typedef_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typedef_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typedef_from_any;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_typedef_from_any(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_typedef_from_any(value);
      return output;
    }

    public Vx.Core.Type_typedef vx_typedef_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_typedef output = Vx.Core.f_typedef_from_any(value);
      return output;
    }

  }

  public static Vx.Core.Func_typedef_from_any e_typedef_from_any = new Vx.Core.Class_typedef_from_any();
  public static Vx.Core.Func_typedef_from_any t_typedef_from_any = new Vx.Core.Class_typedef_from_any();

  public static Vx.Core.Type_typedef f_typedef_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_typedef output = Vx.Core.e_typedef;
    output = Vx.Core.f_typedef_from_type(
      Vx.Core.f_type_from_any(
        value
      )
    );
    return output;
  }

  /**
   * @function typedef_from_type
   * Gets the typedef of a given type
   * @param  {any} value
   * @return {typedef}
   * (func typedef<-type)
   */
  public interface Func_typedef_from_type : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_typedef vx_typedef_from_type(Vx.Core.Type_any value);
  }

  public class Class_typedef_from_type : Vx.Core.Class_base, Func_typedef_from_type {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_typedef_from_type output = new Vx.Core.Class_typedef_from_type();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_typedef_from_type output = new Vx.Core.Class_typedef_from_type();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-type", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typedef_from_type;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typedef_from_type;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_typedef_from_type(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_typedef_from_type(value);
      return output;
    }

    public Vx.Core.Type_typedef vx_typedef_from_type(Vx.Core.Type_any value) {
      Vx.Core.Type_typedef output = Vx.Core.f_typedef_from_type(value);
      return output;
    }

  }

  public static Vx.Core.Func_typedef_from_type e_typedef_from_type = new Vx.Core.Class_typedef_from_type();
  public static Vx.Core.Func_typedef_from_type t_typedef_from_type = new Vx.Core.Class_typedef_from_type();

  public static Vx.Core.Type_typedef f_typedef_from_type(Vx.Core.Type_any value) {
    Vx.Core.Type_typedef output = Vx.Core.e_typedef;
    output = value.vx_typedef();
    return output;
  }

  /**
   * @function typename_from_any
   * Gets the typename of a given value
   * @param  {any-2} value
   * @return {string}
   * (func typename<-any)
   */
  public interface Func_typename_from_any : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_typename_from_any(Vx.Core.Type_any value);
  }

  public class Class_typename_from_any : Vx.Core.Class_base, Func_typename_from_any {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_typename_from_any output = new Vx.Core.Class_typename_from_any();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_typename_from_any output = new Vx.Core.Class_typename_from_any();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "typename<-any", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typename_from_any;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typename_from_any;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_typename_from_any(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any value = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_typename_from_any(value);
      return output;
    }

    public Vx.Core.Type_string vx_typename_from_any(Vx.Core.Type_any value) {
      Vx.Core.Type_string output = Vx.Core.f_typename_from_any(value);
      return output;
    }

  }

  public static Vx.Core.Func_typename_from_any e_typename_from_any = new Vx.Core.Class_typename_from_any();
  public static Vx.Core.Func_typename_from_any t_typename_from_any = new Vx.Core.Class_typename_from_any();

  public static Vx.Core.Type_string f_typename_from_any(Vx.Core.Type_any value) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_typename_from_type(
      Vx.Core.f_type_from_any(
        value
      )
    );
    return output;
  }

  /**
   * @function typename_from_type
   * Get the name of a given type
   * @param  {any} type
   * @return {string}
   * (func typename<-type)
   */
  public interface Func_typename_from_type : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_typename_from_type(Vx.Core.Type_any type);
  }

  public class Class_typename_from_type : Vx.Core.Class_base, Func_typename_from_type {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_typename_from_type output = new Vx.Core.Class_typename_from_type();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_typename_from_type output = new Vx.Core.Class_typename_from_type();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "typename<-type", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typename_from_type;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typename_from_type;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_any inputval = (Vx.Core.Type_any)value;
      Vx.Core.Type_any outputval = Vx.Core.f_typename_from_type(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_any type = Vx.Core.f_any_from_any(Vx.Core.t_any, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_typename_from_type(type);
      return output;
    }

    public Vx.Core.Type_string vx_typename_from_type(Vx.Core.Type_any type) {
      Vx.Core.Type_string output = Vx.Core.f_typename_from_type(type);
      return output;
    }

  }

  public static Vx.Core.Func_typename_from_type e_typename_from_type = new Vx.Core.Class_typename_from_type();
  public static Vx.Core.Func_typename_from_type t_typename_from_type = new Vx.Core.Class_typename_from_type();

  public static Vx.Core.Type_string f_typename_from_type(Vx.Core.Type_any type) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_typename_from_typedef(
      Vx.Core.f_typedef_from_type(
        type
      )
    );
    return output;
  }

  /**
   * @function typename_from_typedef
   * Get the name of a given type
   * @param  {typedef} vtypedef
   * @return {string}
   * (func typename<-typedef)
   */
  public interface Func_typename_from_typedef : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_string vx_typename_from_typedef(Vx.Core.Type_typedef vtypedef);
  }

  public class Class_typename_from_typedef : Vx.Core.Class_base, Func_typename_from_typedef {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_typename_from_typedef output = new Vx.Core.Class_typename_from_typedef();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_typename_from_typedef output = new Vx.Core.Class_typename_from_typedef();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "typename<-typedef", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typename_from_typedef;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typename_from_typedef;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typedef inputval = (Vx.Core.Type_typedef)value;
      Vx.Core.Type_any outputval = Vx.Core.f_typename_from_typedef(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typedef vtypedef = Vx.Core.f_any_from_any(Vx.Core.t_typedef, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_typename_from_typedef(vtypedef);
      return output;
    }

    public Vx.Core.Type_string vx_typename_from_typedef(Vx.Core.Type_typedef vtypedef) {
      Vx.Core.Type_string output = Vx.Core.f_typename_from_typedef(vtypedef);
      return output;
    }

  }

  public static Vx.Core.Func_typename_from_typedef e_typename_from_typedef = new Vx.Core.Class_typename_from_typedef();
  public static Vx.Core.Func_typename_from_typedef t_typename_from_typedef = new Vx.Core.Class_typename_from_typedef();

  public static Vx.Core.Type_string f_typename_from_typedef(Vx.Core.Type_typedef vtypedef) {
    Vx.Core.Type_string output = Vx.Core.e_string;
    output = Vx.Core.f_new(
      Vx.Core.t_string,
      Vx.Core.vx_new(
        Vx.Core.t_anylist,
        vtypedef.pkgname(),
        Vx.Core.vx_new_string("/"),
        vtypedef.name()
      )
    );
    return output;
  }

  /**
   * @function typenames_from_typelist
   * Get the names from a type list
   * @param  {typelist} typelist
   * @return {stringlist}
   * (func typenames<-typelist)
   */
  public interface Func_typenames_from_typelist : Vx.Core.Func_any_from_any {
    public Vx.Core.Type_stringlist vx_typenames_from_typelist(Vx.Core.Type_typelist typelist);
  }

  public class Class_typenames_from_typelist : Vx.Core.Class_base, Func_typenames_from_typelist {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_typenames_from_typelist output = new Vx.Core.Class_typenames_from_typelist();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_typenames_from_typelist output = new Vx.Core.Class_typenames_from_typelist();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "typenames<-typelist", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.vx_new(Vx.Core.t_typelist, Vx.Core.t_string), // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_typenames_from_typelist;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_typenames_from_typelist;
      return output;
    }

    public Vx.Core.Func_any_from_any vx_fn_new(Vx.Core.Class_any_from_any.IFn fn) {
      return Vx.Core.e_any_from_any;
    }

    public T vx_any_from_any<T, U>(T generic_any_1, U value) where T : Vx.Core.Type_any where U : Vx.Core.Type_any {
      T output = Vx.Core.f_empty(generic_any_1);
      Vx.Core.Type_typelist inputval = (Vx.Core.Type_typelist)value;
      Vx.Core.Type_any outputval = Vx.Core.f_typenames_from_typelist(inputval);
      output = Vx.Core.f_any_from_any(generic_any_1, outputval);
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_typelist typelist = Vx.Core.f_any_from_any(Vx.Core.t_typelist, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_typenames_from_typelist(typelist);
      return output;
    }

    public Vx.Core.Type_stringlist vx_typenames_from_typelist(Vx.Core.Type_typelist typelist) {
      Vx.Core.Type_stringlist output = Vx.Core.f_typenames_from_typelist(typelist);
      return output;
    }

  }

  public static Vx.Core.Func_typenames_from_typelist e_typenames_from_typelist = new Vx.Core.Class_typenames_from_typelist();
  public static Vx.Core.Func_typenames_from_typelist t_typenames_from_typelist = new Vx.Core.Class_typenames_from_typelist();

  public static Vx.Core.Type_stringlist f_typenames_from_typelist(Vx.Core.Type_typelist typelist) {
    Vx.Core.Type_stringlist output = Vx.Core.e_stringlist;
    output = Vx.Core.f_list_from_list_1(
      Vx.Core.t_stringlist,
      typelist,
      Vx.Core.t_any_from_any.vx_fn_new((type_any) => {
        Vx.Core.Type_any type = Vx.Core.f_any_from_any(Vx.Core.t_any, type_any);
        Vx.Core.Type_any output_1 = Vx.Core.f_typename_from_type(
          type
        );
        return output_1;
      })
    );
    return output;
  }

  /**
   * @function user_from_context
   * Returns the current user from context.
   * @return {user}
   * (func user<-context)
   */
  public interface Func_user_from_context : Vx.Core.Type_func, Vx.Core.Type_replfunc {
    public Vx.Core.Type_user vx_user_from_context(Vx.Core.Type_context context);
  }

  public class Class_user_from_context : Vx.Core.Class_base, Func_user_from_context {

    public override Vx.Core.Type_any vx_new(params object[] vals) {
      Vx.Core.Class_user_from_context output = new Vx.Core.Class_user_from_context();
      return output;
    }

    public override Vx.Core.Type_any vx_copy(params object[] vals) {
      Vx.Core.Class_user_from_context output = new Vx.Core.Class_user_from_context();
      return output;
    }

    public override Vx.Core.Type_typedef vx_typedef() {
      Vx.Core.Type_typedef output = Vx.Core.t_func.vx_typedef();
      return output;
    }

    public Vx.Core.Type_funcdef vx_funcdef() {
      Vx.Core.Type_funcdef output = Vx.Core.funcdef_new(
        "vx/core", // pkgname
        "user<-context", // name
        0, // idx
        false, // async
        Vx.Core.typedef_new(
          "vx/core", // pkgname
          "user", // name
          ":struct", // extends
          Vx.Core.e_typelist, // traits
          Vx.Core.e_typelist, // allowtypes
          Vx.Core.e_typelist, // disallowtypes
          Vx.Core.e_funclist, // allowfuncs
          Vx.Core.e_funclist, // disallowfuncs
          Vx.Core.e_anylist, // allowvalues
          Vx.Core.e_anylist, // disallowvalues
          Vx.Core.e_argmap // properties
        ) // typedef
      );
      return output;
    }

    public override Vx.Core.Type_any vx_empty() {
      Vx.Core.Type_any output = Vx.Core.e_user_from_context;
      return output;
    }

    public override Vx.Core.Type_any vx_type() {
      Vx.Core.Type_any output = Vx.Core.t_user_from_context;
      return output;
    }

    public Vx.Core.Type_any vx_repl(Vx.Core.Type_anylist arglist) {
      Vx.Core.Type_any output = Vx.Core.e_any;
      Vx.Core.Type_context context = Vx.Core.f_any_from_any(Vx.Core.t_context, arglist.vx_any(Vx.Core.vx_new_int(0)));
      output = Vx.Core.f_user_from_context(context);
      return output;
    }

    public Vx.Core.Type_user vx_user_from_context(Vx.Core.Type_context context) {
      Vx.Core.Type_user output = Vx.Core.f_user_from_context(context);
      return output;
    }

  }

  public static Vx.Core.Func_user_from_context e_user_from_context = new Vx.Core.Class_user_from_context();
  public static Vx.Core.Func_user_from_context t_user_from_context = new Vx.Core.Class_user_from_context();

  public static Vx.Core.Type_user f_user_from_context(Vx.Core.Type_context context) {
    Vx.Core.Type_user output = Vx.Core.e_user;
    output = Vx.Core.f_session_from_context(
      context
    ).user();
    return output;
  }


  public static class PackageRunOnce {
    public static bool RunOnce() {
    Const_false.const_new(c_false);
    Const_global.const_new(c_global);
    Const_infinity.const_new(c_infinity);
    Const_mempool_active.const_new(c_mempool_active);
    Const_msg_error.const_new(c_msg_error);
    Const_msg_info.const_new(c_msg_info);
    Const_msg_severe.const_new(c_msg_severe);
    Const_msg_warning.const_new(c_msg_warning);
    Const_neginfinity.const_new(c_neginfinity);
    Const_newline.const_new(c_newline);
    Const_notanumber.const_new(c_notanumber);
    Const_nothing.const_new(c_nothing);
    Const_path_test_resources.const_new(c_path_test_resources);
    Const_quote.const_new(c_quote);
    Const_true.const_new(c_true);
    Vx.Core.Map<string, Vx.Core.Type_any> maptype = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
    Vx.Core.Map<string, Vx.Core.Type_any> mapconst = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_any>();
    Vx.Core.Map<string, Vx.Core.Type_func> mapfunc = new Vx.Core.LinkedHashMap<string, Vx.Core.Type_func>();
    maptype.put("any", Vx.Core.t_any);
    maptype.put("any-async<-func", Vx.Core.t_any_async_from_func);
    maptype.put("any<-anylist", Vx.Core.t_any_from_anylist);
    maptype.put("anylist", Vx.Core.t_anylist);
    maptype.put("anymap", Vx.Core.t_anymap);
    maptype.put("anytype", Vx.Core.t_anytype);
    maptype.put("arg", Vx.Core.t_arg);
    maptype.put("arglist", Vx.Core.t_arglist);
    maptype.put("argmap", Vx.Core.t_argmap);
    maptype.put("boolean", Vx.Core.t_boolean);
    maptype.put("booleanlist", Vx.Core.t_booleanlist);
    maptype.put("collection", Vx.Core.t_collection);
    maptype.put("compilelanguages", Vx.Core.t_compilelanguages);
    maptype.put("connect", Vx.Core.t_connect);
    maptype.put("connectlist", Vx.Core.t_connectlist);
    maptype.put("connectmap", Vx.Core.t_connectmap);
    maptype.put("const", Vx.Core.t_const);
    maptype.put("constdef", Vx.Core.t_constdef);
    maptype.put("constlist", Vx.Core.t_constlist);
    maptype.put("constmap", Vx.Core.t_constmap);
    maptype.put("context", Vx.Core.t_context);
    maptype.put("date", Vx.Core.t_date);
    maptype.put("decimal", Vx.Core.t_decimal);
    maptype.put("error", Vx.Core.t_error);
    maptype.put("float", Vx.Core.t_float);
    maptype.put("func", Vx.Core.t_func);
    maptype.put("funcdef", Vx.Core.t_funcdef);
    maptype.put("funclist", Vx.Core.t_funclist);
    maptype.put("funcmap", Vx.Core.t_funcmap);
    maptype.put("int", Vx.Core.t_int);
    maptype.put("intlist", Vx.Core.t_intlist);
    maptype.put("intmap", Vx.Core.t_intmap);
    maptype.put("list", Vx.Core.t_list);
    maptype.put("listtype", Vx.Core.t_listtype);
    maptype.put("locale", Vx.Core.t_locale);
    maptype.put("map", Vx.Core.t_map);
    maptype.put("maptype", Vx.Core.t_maptype);
    maptype.put("mempool", Vx.Core.t_mempool);
    maptype.put("msg", Vx.Core.t_msg);
    maptype.put("msgblock", Vx.Core.t_msgblock);
    maptype.put("msgblocklist", Vx.Core.t_msgblocklist);
    maptype.put("msglist", Vx.Core.t_msglist);
    maptype.put("none", Vx.Core.t_none);
    maptype.put("notype", Vx.Core.t_notype);
    maptype.put("number", Vx.Core.t_number);
    maptype.put("numberlist", Vx.Core.t_numberlist);
    maptype.put("numbermap", Vx.Core.t_numbermap);
    maptype.put("package", Vx.Core.t_package);
    maptype.put("packagemap", Vx.Core.t_packagemap);
    maptype.put("permission", Vx.Core.t_permission);
    maptype.put("permissionlist", Vx.Core.t_permissionlist);
    maptype.put("permissionmap", Vx.Core.t_permissionmap);
    maptype.put("project", Vx.Core.t_project);
    maptype.put("security", Vx.Core.t_security);
    maptype.put("session", Vx.Core.t_session);
    maptype.put("setting", Vx.Core.t_setting);
    maptype.put("state", Vx.Core.t_state);
    maptype.put("statelistener", Vx.Core.t_statelistener);
    maptype.put("statelistenermap", Vx.Core.t_statelistenermap);
    maptype.put("string", Vx.Core.t_string);
    maptype.put("stringlist", Vx.Core.t_stringlist);
    maptype.put("stringlistlist", Vx.Core.t_stringlistlist);
    maptype.put("stringmap", Vx.Core.t_stringmap);
    maptype.put("stringmutablemap", Vx.Core.t_stringmutablemap);
    maptype.put("struct", Vx.Core.t_struct);
    maptype.put("thenelse", Vx.Core.t_thenelse);
    maptype.put("thenelselist", Vx.Core.t_thenelselist);
    maptype.put("translation", Vx.Core.t_translation);
    maptype.put("translationlist", Vx.Core.t_translationlist);
    maptype.put("translationmap", Vx.Core.t_translationmap);
    maptype.put("type", Vx.Core.t_type);
    maptype.put("typedef", Vx.Core.t_typedef);
    maptype.put("typelist", Vx.Core.t_typelist);
    maptype.put("typemap", Vx.Core.t_typemap);
    maptype.put("user", Vx.Core.t_user);
    maptype.put("value", Vx.Core.t_value);
    mapconst.put("false", Vx.Core.c_false);
    mapconst.put("global", Vx.Core.c_global);
    mapconst.put("infinity", Vx.Core.c_infinity);
    mapconst.put("mempool-active", Vx.Core.c_mempool_active);
    mapconst.put("msg-error", Vx.Core.c_msg_error);
    mapconst.put("msg-info", Vx.Core.c_msg_info);
    mapconst.put("msg-severe", Vx.Core.c_msg_severe);
    mapconst.put("msg-warning", Vx.Core.c_msg_warning);
    mapconst.put("neginfinity", Vx.Core.c_neginfinity);
    mapconst.put("newline", Vx.Core.c_newline);
    mapconst.put("notanumber", Vx.Core.c_notanumber);
    mapconst.put("nothing", Vx.Core.c_nothing);
    mapconst.put("path-test-resources", Vx.Core.c_path_test_resources);
    mapconst.put("quote", Vx.Core.c_quote);
    mapconst.put("true", Vx.Core.c_true);
    mapfunc.put("!", Vx.Core.t_not);
    mapfunc.put("!-empty", Vx.Core.t_notempty);
    mapfunc.put("!-empty_1", Vx.Core.t_notempty_1);
    mapfunc.put("!=", Vx.Core.t_ne);
    mapfunc.put("!==", Vx.Core.t_neqeq);
    mapfunc.put("*", Vx.Core.t_multiply);
    mapfunc.put("*_1", Vx.Core.t_multiply_1);
    mapfunc.put("*_2", Vx.Core.t_multiply_2);
    mapfunc.put("*_3", Vx.Core.t_multiply_3);
    mapfunc.put("+", Vx.Core.t_plus);
    mapfunc.put("+_1", Vx.Core.t_plus_1);
    mapfunc.put("+_2", Vx.Core.t_plus_2);
    mapfunc.put("+_3", Vx.Core.t_plus_3);
    mapfunc.put("+1", Vx.Core.t_plus1);
    mapfunc.put("-", Vx.Core.t_minus);
    mapfunc.put("-_1", Vx.Core.t_minus_1);
    mapfunc.put("-_2", Vx.Core.t_minus_2);
    mapfunc.put("-_3", Vx.Core.t_minus_3);
    mapfunc.put("-1", Vx.Core.t_minus1);
    mapfunc.put(".", Vx.Core.t_dotmethod);
    mapfunc.put("/", Vx.Core.t_divide);
    mapfunc.put("<", Vx.Core.t_lt);
    mapfunc.put("<_1", Vx.Core.t_lt_1);
    mapfunc.put("<-", Vx.Core.t_chainfirst);
    mapfunc.put("<<-", Vx.Core.t_chainlast);
    mapfunc.put("<=", Vx.Core.t_le);
    mapfunc.put("<=_1", Vx.Core.t_le_1);
    mapfunc.put("=", Vx.Core.t_eq);
    mapfunc.put("=_1", Vx.Core.t_eq_1);
    mapfunc.put("==", Vx.Core.t_eqeq);
    mapfunc.put(">", Vx.Core.t_gt);
    mapfunc.put(">_1", Vx.Core.t_gt_1);
    mapfunc.put(">=", Vx.Core.t_ge);
    mapfunc.put(">=_1", Vx.Core.t_ge_1);
    mapfunc.put("allowfuncs<-security", Vx.Core.t_allowfuncs_from_security);
    mapfunc.put("allowtypenames<-typedef", Vx.Core.t_allowtypenames_from_typedef);
    mapfunc.put("allowtypes<-typedef", Vx.Core.t_allowtypes_from_typedef);
    mapfunc.put("and", Vx.Core.t_and);
    mapfunc.put("and_1", Vx.Core.t_and_1);
    mapfunc.put("any<-any", Vx.Core.t_any_from_any);
    mapfunc.put("any<-any-async", Vx.Core.t_any_from_any_async);
    mapfunc.put("any<-any-context", Vx.Core.t_any_from_any_context);
    mapfunc.put("any<-any-context-async", Vx.Core.t_any_from_any_context_async);
    mapfunc.put("any<-any-key-value", Vx.Core.t_any_from_any_key_value);
    mapfunc.put("any<-func", Vx.Core.t_any_from_func);
    mapfunc.put("any<-func-async", Vx.Core.t_any_from_func_async);
    mapfunc.put("any<-int", Vx.Core.t_any_from_int);
    mapfunc.put("any<-int-any", Vx.Core.t_any_from_int_any);
    mapfunc.put("any<-key-value", Vx.Core.t_any_from_key_value);
    mapfunc.put("any<-key-value-async", Vx.Core.t_any_from_key_value_async);
    mapfunc.put("any<-list", Vx.Core.t_any_from_list);
    mapfunc.put("any<-list-start-reduce", Vx.Core.t_any_from_list_start_reduce);
    mapfunc.put("any<-list-start-reduce-next", Vx.Core.t_any_from_list_start_reduce_next);
    mapfunc.put("any<-map", Vx.Core.t_any_from_map);
    mapfunc.put("any<-map-start-reduce", Vx.Core.t_any_from_map_start_reduce);
    mapfunc.put("any<-none", Vx.Core.t_any_from_none);
    mapfunc.put("any<-none-async", Vx.Core.t_any_from_none_async);
    mapfunc.put("any<-reduce", Vx.Core.t_any_from_reduce);
    mapfunc.put("any<-reduce-async", Vx.Core.t_any_from_reduce_async);
    mapfunc.put("any<-reduce-next", Vx.Core.t_any_from_reduce_next);
    mapfunc.put("any<-reduce-next-async", Vx.Core.t_any_from_reduce_next_async);
    mapfunc.put("any<-struct", Vx.Core.t_any_from_struct);
    mapfunc.put("async", Vx.Core.t_async);
    mapfunc.put("boolean-permission<-func", Vx.Core.t_boolean_permission_from_func);
    mapfunc.put("boolean-write<-map-name-value", Vx.Core.t_boolean_write_from_map_name_value);
    mapfunc.put("boolean<-any", Vx.Core.t_boolean_from_any);
    mapfunc.put("boolean<-func", Vx.Core.t_boolean_from_func);
    mapfunc.put("boolean<-none", Vx.Core.t_boolean_from_none);
    mapfunc.put("case", Vx.Core.t_case);
    mapfunc.put("case_1", Vx.Core.t_case_1);
    mapfunc.put("compare", Vx.Core.t_compare);
    mapfunc.put("contains", Vx.Core.t_contains);
    mapfunc.put("contains_1", Vx.Core.t_contains_1);
    mapfunc.put("context-main", Vx.Core.t_context_main);
    mapfunc.put("copy", Vx.Core.t_copy);
    mapfunc.put("else", Vx.Core.t_else);
    mapfunc.put("empty", Vx.Core.t_empty);
    mapfunc.put("extends<-any", Vx.Core.t_extends_from_any);
    mapfunc.put("extends<-typedef", Vx.Core.t_extends_from_typedef);
    mapfunc.put("first<-list", Vx.Core.t_first_from_list);
    mapfunc.put("first<-list-any<-any", Vx.Core.t_first_from_list_any_from_any);
    mapfunc.put("float<-string", Vx.Core.t_float_from_string);
    mapfunc.put("fn", Vx.Core.t_fn);
    mapfunc.put("funcdef<-func", Vx.Core.t_funcdef_from_func);
    mapfunc.put("funcname<-funcdef", Vx.Core.t_funcname_from_funcdef);
    mapfunc.put("if", Vx.Core.t_if);
    mapfunc.put("if_1", Vx.Core.t_if_1);
    mapfunc.put("if_2", Vx.Core.t_if_2);
    mapfunc.put("int<-func", Vx.Core.t_int_from_func);
    mapfunc.put("int<-string", Vx.Core.t_int_from_string);
    mapfunc.put("is-empty", Vx.Core.t_is_empty);
    mapfunc.put("is-empty_1", Vx.Core.t_is_empty_1);
    mapfunc.put("is-endswith", Vx.Core.t_is_endswith);
    mapfunc.put("is-float", Vx.Core.t_is_float);
    mapfunc.put("is-func", Vx.Core.t_is_func);
    mapfunc.put("is-int", Vx.Core.t_is_int);
    mapfunc.put("is-number", Vx.Core.t_is_number);
    mapfunc.put("is-pass<-permission", Vx.Core.t_is_pass_from_permission);
    mapfunc.put("last<-list", Vx.Core.t_last_from_list);
    mapfunc.put("length", Vx.Core.t_length);
    mapfunc.put("length_1", Vx.Core.t_length_1);
    mapfunc.put("length_2", Vx.Core.t_length_2);
    mapfunc.put("let", Vx.Core.t_let);
    mapfunc.put("let-async", Vx.Core.t_let_async);
    mapfunc.put("list-join<-list", Vx.Core.t_list_join_from_list);
    mapfunc.put("list-join<-list_1", Vx.Core.t_list_join_from_list_1);
    mapfunc.put("list<-list", Vx.Core.t_list_from_list);
    mapfunc.put("list<-list_1", Vx.Core.t_list_from_list_1);
    mapfunc.put("list<-list-async", Vx.Core.t_list_from_list_async);
    mapfunc.put("list<-list-intany", Vx.Core.t_list_from_list_intany);
    mapfunc.put("list<-map", Vx.Core.t_list_from_map);
    mapfunc.put("list<-map_1", Vx.Core.t_list_from_map_1);
    mapfunc.put("list<-map-async", Vx.Core.t_list_from_map_async);
    mapfunc.put("list<-type", Vx.Core.t_list_from_type);
    mapfunc.put("log", Vx.Core.t_log);
    mapfunc.put("log_1", Vx.Core.t_log_1);
    mapfunc.put("main", Vx.Core.t_main);
    mapfunc.put("map<-list", Vx.Core.t_map_from_list);
    mapfunc.put("map<-map", Vx.Core.t_map_from_map);
    mapfunc.put("map<-map_1", Vx.Core.t_map_from_map_1);
    mapfunc.put("msg<-error", Vx.Core.t_msg_from_error);
    mapfunc.put("msg<-error_1", Vx.Core.t_msg_from_error_1);
    mapfunc.put("msg<-error_2", Vx.Core.t_msg_from_error_2);
    mapfunc.put("msg<-warning", Vx.Core.t_msg_from_warning);
    mapfunc.put("msgblock<-msgblock-msg", Vx.Core.t_msgblock_from_msgblock_msg);
    mapfunc.put("msgblock<-msgblock-msgblock", Vx.Core.t_msgblock_from_msgblock_msgblock);
    mapfunc.put("name<-typedef", Vx.Core.t_name_from_typedef);
    mapfunc.put("native", Vx.Core.t_native);
    mapfunc.put("native<-any", Vx.Core.t_native_from_any);
    mapfunc.put("new", Vx.Core.t_new);
    mapfunc.put("number<-func", Vx.Core.t_number_from_func);
    mapfunc.put("or", Vx.Core.t_or);
    mapfunc.put("or_1", Vx.Core.t_or_1);
    mapfunc.put("package-global<-name", Vx.Core.t_package_global_from_name);
    mapfunc.put("packagename<-typedef", Vx.Core.t_packagename_from_typedef);
    mapfunc.put("path<-context-path", Vx.Core.t_path_from_context_path);
    mapfunc.put("path<-setting-path", Vx.Core.t_path_from_setting_path);
    mapfunc.put("permission<-id-context", Vx.Core.t_permission_from_id_context);
    mapfunc.put("properties<-typedef", Vx.Core.t_properties_from_typedef);
    mapfunc.put("proplast<-typedef", Vx.Core.t_proplast_from_typedef);
    mapfunc.put("resolve", Vx.Core.t_resolve);
    mapfunc.put("resolve_1", Vx.Core.t_resolve_1);
    mapfunc.put("resolve-async", Vx.Core.t_resolve_async);
    mapfunc.put("resolve-first", Vx.Core.t_resolve_first);
    mapfunc.put("resolve-list", Vx.Core.t_resolve_list);
    mapfunc.put("security<-context", Vx.Core.t_security_from_context);
    mapfunc.put("security<-user", Vx.Core.t_security_from_user);
    mapfunc.put("session<-context", Vx.Core.t_session_from_context);
    mapfunc.put("setting<-context", Vx.Core.t_setting_from_context);
    mapfunc.put("string-repeat", Vx.Core.t_string_repeat);
    mapfunc.put("string<-any", Vx.Core.t_string_from_any);
    mapfunc.put("string<-any-indent", Vx.Core.t_string_from_any_indent);
    mapfunc.put("string<-func", Vx.Core.t_string_from_func);
    mapfunc.put("string<-string-find-replace", Vx.Core.t_string_from_string_find_replace);
    mapfunc.put("stringlist<-map", Vx.Core.t_stringlist_from_map);
    mapfunc.put("switch", Vx.Core.t_switch);
    mapfunc.put("then", Vx.Core.t_then);
    mapfunc.put("traits<-typedef", Vx.Core.t_traits_from_typedef);
    mapfunc.put("type<-any", Vx.Core.t_type_from_any);
    mapfunc.put("typedef<-any", Vx.Core.t_typedef_from_any);
    mapfunc.put("typedef<-type", Vx.Core.t_typedef_from_type);
    mapfunc.put("typename<-any", Vx.Core.t_typename_from_any);
    mapfunc.put("typename<-type", Vx.Core.t_typename_from_type);
    mapfunc.put("typename<-typedef", Vx.Core.t_typename_from_typedef);
    mapfunc.put("typenames<-typelist", Vx.Core.t_typenames_from_typelist);
    mapfunc.put("user<-context", Vx.Core.t_user_from_context);
    Vx.Core.vx_global_package_set("vx/core", maptype, mapconst, mapfunc);
      return true;
    }
  }

  public static bool ranonce = PackageRunOnce.RunOnce();

}
